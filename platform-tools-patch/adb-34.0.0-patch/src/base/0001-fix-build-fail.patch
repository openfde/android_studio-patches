From 14cddbede9892a3fa7469fbd3681acd125d04577 Mon Sep 17 00:00:00 2001
From: pngcui <pngcui1224@163.com>
Date: Tue, 23 Sep 2025 19:27:16 +0800
Subject: [PATCH] fix build fail

---
 libs/androidfw/AssetManager2.cpp              |    12 +-
 libs/androidfw/LoadedArsc.cpp                 |     1 +
 .../include/androidfw/AssetManager2.h         |     8 +-
 libs/androidfw/include/androidfw/LoadedArsc.h |     2 +-
 tools/aapt/Command.cpp                        |     1 +
 tools/aapt2/Configuration.pb.cc               |  1445 ++
 tools/aapt2/Configuration.pb.h                |  1987 ++
 tools/aapt2/Resources.pb.cc                   | 15857 +++++++++++++
 tools/aapt2/Resources.pb.h                    | 18784 ++++++++++++++++
 tools/aapt2/Resources.proto                   |     2 +-
 tools/aapt2/ResourcesInternal.pb.cc           |   774 +
 tools/aapt2/ResourcesInternal.pb.h            |   858 +
 tools/aapt2/ResourcesInternal.proto           |     4 +-
 tools/aapt2/util/Files.cpp                    |     2 +-
 14 files changed, 39725 insertions(+), 12 deletions(-)
 create mode 100644 tools/aapt2/Configuration.pb.cc
 create mode 100644 tools/aapt2/Configuration.pb.h
 create mode 100644 tools/aapt2/Resources.pb.cc
 create mode 100644 tools/aapt2/Resources.pb.h
 create mode 100644 tools/aapt2/ResourcesInternal.pb.cc
 create mode 100644 tools/aapt2/ResourcesInternal.pb.h

diff --git a/libs/androidfw/AssetManager2.cpp b/libs/androidfw/AssetManager2.cpp
index 400829e1..28db78a8 100644
--- a/libs/androidfw/AssetManager2.cpp
+++ b/libs/androidfw/AssetManager2.cpp
@@ -1411,12 +1411,12 @@ Theme::Theme(AssetManager2* asset_manager) : asset_manager_(asset_manager) {
 
 Theme::~Theme() = default;
 
-struct Theme::Entry {
-  uint32_t attr_res_id;
-  ApkAssetsCookie cookie;
-  uint32_t type_spec_flags;
-  Res_value value;
-};
+// struct Theme::Entry {
+//   uint32_t attr_res_id;
+//   ApkAssetsCookie cookie;
+//   uint32_t type_spec_flags;
+//   Res_value value;
+// };
 
 namespace {
 struct ThemeEntryKeyComparer {
diff --git a/libs/androidfw/LoadedArsc.cpp b/libs/androidfw/LoadedArsc.cpp
index 35b6170f..066fa603 100644
--- a/libs/androidfw/LoadedArsc.cpp
+++ b/libs/androidfw/LoadedArsc.cpp
@@ -21,6 +21,7 @@
 #include <algorithm>
 #include <cstddef>
 #include <limits>
+#include <optional>
 
 #include "android-base/logging.h"
 #include "android-base/stringprintf.h"
diff --git a/libs/androidfw/include/androidfw/AssetManager2.h b/libs/androidfw/include/androidfw/AssetManager2.h
index 1bde792d..7a049408 100644
--- a/libs/androidfw/include/androidfw/AssetManager2.h
+++ b/libs/androidfw/include/androidfw/AssetManager2.h
@@ -563,7 +563,13 @@ class Theme {
 
   void Dump() const;
 
-  struct Entry;
+  // struct Entry;
+  struct Entry {
+    uint32_t attr_res_id;
+    ApkAssetsCookie cookie;
+    uint32_t type_spec_flags;
+    Res_value value;
+  };
  private:
   DISALLOW_COPY_AND_ASSIGN(Theme);
 
diff --git a/libs/androidfw/include/androidfw/LoadedArsc.h b/libs/androidfw/include/androidfw/LoadedArsc.h
index b3d6a4dc..76e3e7f8 100644
--- a/libs/androidfw/include/androidfw/LoadedArsc.h
+++ b/libs/androidfw/include/androidfw/LoadedArsc.h
@@ -295,7 +295,7 @@ class LoadedPackage {
   std::unordered_map<uint8_t, TypeSpec> type_specs_;
   ByteBucketArray<uint32_t> resource_ids_;
   std::vector<DynamicPackageEntry> dynamic_package_map_;
-  std::vector<const std::pair<OverlayableInfo, std::unordered_set<uint32_t>>> overlayable_infos_;
+  std::vector<std::pair<OverlayableInfo, std::unordered_set<uint32_t>>> overlayable_infos_;
   std::map<uint32_t, uint32_t> alias_id_map_;
 
   // A map of overlayable name to actor
diff --git a/tools/aapt/Command.cpp b/tools/aapt/Command.cpp
index d02fd83d..ff8dd81e 100644
--- a/tools/aapt/Command.cpp
+++ b/tools/aapt/Command.cpp
@@ -2446,6 +2446,7 @@ bail:
     if (asset) {
         delete asset;
     }
+
     return (result != NO_ERROR);
 }
 
diff --git a/tools/aapt2/Configuration.pb.cc b/tools/aapt2/Configuration.pb.cc
new file mode 100644
index 00000000..8eb3ab11
--- /dev/null
+++ b/tools/aapt2/Configuration.pb.cc
@@ -0,0 +1,1445 @@
+// Generated by the protocol buffer compiler.  DO NOT EDIT!
+// source: Configuration.proto
+
+#include "Configuration.pb.h"
+
+#include <algorithm>
+#include <cstdint>
+
+#include <google/protobuf/io/coded_stream.h>
+#include <google/protobuf/extension_set.h>
+#include <google/protobuf/wire_format_lite.h>
+#include <google/protobuf/descriptor.h>
+#include <google/protobuf/generated_message_reflection.h>
+#include <google/protobuf/reflection_ops.h>
+#include <google/protobuf/wire_format.h>
+// @@protoc_insertion_point(includes)
+#include <google/protobuf/port_def.inc>
+
+PROTOBUF_PRAGMA_INIT_SEG
+
+namespace _pb = ::PROTOBUF_NAMESPACE_ID;
+namespace _pbi = _pb::internal;
+
+namespace aapt {
+namespace pb {
+PROTOBUF_CONSTEXPR Configuration::Configuration(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.locale_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.product_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.mcc_)*/0u
+  , /*decltype(_impl_.mnc_)*/0u
+  , /*decltype(_impl_.layout_direction_)*/0
+  , /*decltype(_impl_.screen_width_)*/0u
+  , /*decltype(_impl_.screen_height_)*/0u
+  , /*decltype(_impl_.screen_width_dp_)*/0u
+  , /*decltype(_impl_.screen_height_dp_)*/0u
+  , /*decltype(_impl_.smallest_screen_width_dp_)*/0u
+  , /*decltype(_impl_.screen_layout_size_)*/0
+  , /*decltype(_impl_.screen_layout_long_)*/0
+  , /*decltype(_impl_.screen_round_)*/0
+  , /*decltype(_impl_.wide_color_gamut_)*/0
+  , /*decltype(_impl_.hdr_)*/0
+  , /*decltype(_impl_.orientation_)*/0
+  , /*decltype(_impl_.ui_mode_type_)*/0
+  , /*decltype(_impl_.ui_mode_night_)*/0
+  , /*decltype(_impl_.density_)*/0u
+  , /*decltype(_impl_.touchscreen_)*/0
+  , /*decltype(_impl_.keys_hidden_)*/0
+  , /*decltype(_impl_.keyboard_)*/0
+  , /*decltype(_impl_.nav_hidden_)*/0
+  , /*decltype(_impl_.navigation_)*/0
+  , /*decltype(_impl_.sdk_version_)*/0u
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct ConfigurationDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR ConfigurationDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~ConfigurationDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Configuration _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigurationDefaultTypeInternal _Configuration_default_instance_;
+}  // namespace pb
+}  // namespace aapt
+static ::_pb::Metadata file_level_metadata_Configuration_2eproto[1];
+static const ::_pb::EnumDescriptor* file_level_enum_descriptors_Configuration_2eproto[14];
+static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_Configuration_2eproto = nullptr;
+
+const ::uint32_t TableStruct_Configuration_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.mcc_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.mnc_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.locale_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.layout_direction_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.screen_width_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.screen_height_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.screen_width_dp_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.screen_height_dp_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.smallest_screen_width_dp_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.screen_layout_size_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.screen_layout_long_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.screen_round_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.wide_color_gamut_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.hdr_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.orientation_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.ui_mode_type_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.ui_mode_night_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.density_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.touchscreen_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.keys_hidden_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.keyboard_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.nav_hidden_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.navigation_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.sdk_version_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Configuration, _impl_.product_),
+};
+static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
+  { 0, -1, -1, sizeof(::aapt::pb::Configuration)},
+};
+
+static const ::_pb::Message* const file_default_instances[] = {
+  &::aapt::pb::_Configuration_default_instance_._instance,
+};
+
+const char descriptor_table_protodef_Configuration_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
+  "\n\023Configuration.proto\022\007aapt.pb\"\331\024\n\rConfi"
+  "guration\022\013\n\003mcc\030\001 \001(\r\022\013\n\003mnc\030\002 \001(\r\022\016\n\006lo"
+  "cale\030\003 \001(\t\022@\n\020layout_direction\030\004 \001(\0162&.a"
+  "apt.pb.Configuration.LayoutDirection\022\024\n\014"
+  "screen_width\030\005 \001(\r\022\025\n\rscreen_height\030\006 \001("
+  "\r\022\027\n\017screen_width_dp\030\007 \001(\r\022\030\n\020screen_hei"
+  "ght_dp\030\010 \001(\r\022 \n\030smallest_screen_width_dp"
+  "\030\t \001(\r\022C\n\022screen_layout_size\030\n \001(\0162\'.aap"
+  "t.pb.Configuration.ScreenLayoutSize\022C\n\022s"
+  "creen_layout_long\030\013 \001(\0162\'.aapt.pb.Config"
+  "uration.ScreenLayoutLong\0228\n\014screen_round"
+  "\030\014 \001(\0162\".aapt.pb.Configuration.ScreenRou"
+  "nd\022\?\n\020wide_color_gamut\030\r \001(\0162%.aapt.pb.C"
+  "onfiguration.WideColorGamut\022\'\n\003hdr\030\016 \001(\016"
+  "2\032.aapt.pb.Configuration.Hdr\0227\n\013orientat"
+  "ion\030\017 \001(\0162\".aapt.pb.Configuration.Orient"
+  "ation\0227\n\014ui_mode_type\030\020 \001(\0162!.aapt.pb.Co"
+  "nfiguration.UiModeType\0229\n\rui_mode_night\030"
+  "\021 \001(\0162\".aapt.pb.Configuration.UiModeNigh"
+  "t\022\017\n\007density\030\022 \001(\r\0227\n\013touchscreen\030\023 \001(\0162"
+  "\".aapt.pb.Configuration.Touchscreen\0226\n\013k"
+  "eys_hidden\030\024 \001(\0162!.aapt.pb.Configuration"
+  ".KeysHidden\0221\n\010keyboard\030\025 \001(\0162\037.aapt.pb."
+  "Configuration.Keyboard\0224\n\nnav_hidden\030\026 \001"
+  "(\0162 .aapt.pb.Configuration.NavHidden\0225\n\n"
+  "navigation\030\027 \001(\0162!.aapt.pb.Configuration"
+  ".Navigation\022\023\n\013sdk_version\030\030 \001(\r\022\017\n\007prod"
+  "uct\030\031 \001(\t\"a\n\017LayoutDirection\022\032\n\026LAYOUT_D"
+  "IRECTION_UNSET\020\000\022\030\n\024LAYOUT_DIRECTION_LTR"
+  "\020\001\022\030\n\024LAYOUT_DIRECTION_RTL\020\002\"\252\001\n\020ScreenL"
+  "ayoutSize\022\034\n\030SCREEN_LAYOUT_SIZE_UNSET\020\000\022"
+  "\034\n\030SCREEN_LAYOUT_SIZE_SMALL\020\001\022\035\n\031SCREEN_"
+  "LAYOUT_SIZE_NORMAL\020\002\022\034\n\030SCREEN_LAYOUT_SI"
+  "ZE_LARGE\020\003\022\035\n\031SCREEN_LAYOUT_SIZE_XLARGE\020"
+  "\004\"m\n\020ScreenLayoutLong\022\034\n\030SCREEN_LAYOUT_L"
+  "ONG_UNSET\020\000\022\033\n\027SCREEN_LAYOUT_LONG_LONG\020\001"
+  "\022\036\n\032SCREEN_LAYOUT_LONG_NOTLONG\020\002\"X\n\013Scre"
+  "enRound\022\026\n\022SCREEN_ROUND_UNSET\020\000\022\026\n\022SCREE"
+  "N_ROUND_ROUND\020\001\022\031\n\025SCREEN_ROUND_NOTROUND"
+  "\020\002\"h\n\016WideColorGamut\022\032\n\026WIDE_COLOR_GAMUT"
+  "_UNSET\020\000\022\033\n\027WIDE_COLOR_GAMUT_WIDECG\020\001\022\035\n"
+  "\031WIDE_COLOR_GAMUT_NOWIDECG\020\002\"3\n\003Hdr\022\r\n\tH"
+  "DR_UNSET\020\000\022\016\n\nHDR_HIGHDR\020\001\022\r\n\tHDR_LOWDR\020"
+  "\002\"h\n\013Orientation\022\025\n\021ORIENTATION_UNSET\020\000\022"
+  "\024\n\020ORIENTATION_PORT\020\001\022\024\n\020ORIENTATION_LAN"
+  "D\020\002\022\026\n\022ORIENTATION_SQUARE\020\003\"\327\001\n\nUiModeTy"
+  "pe\022\026\n\022UI_MODE_TYPE_UNSET\020\000\022\027\n\023UI_MODE_TY"
+  "PE_NORMAL\020\001\022\025\n\021UI_MODE_TYPE_DESK\020\002\022\024\n\020UI"
+  "_MODE_TYPE_CAR\020\003\022\033\n\027UI_MODE_TYPE_TELEVIS"
+  "ION\020\004\022\032\n\026UI_MODE_TYPE_APPLIANCE\020\005\022\026\n\022UI_"
+  "MODE_TYPE_WATCH\020\006\022\032\n\026UI_MODE_TYPE_VRHEAD"
+  "SET\020\007\"[\n\013UiModeNight\022\027\n\023UI_MODE_NIGHT_UN"
+  "SET\020\000\022\027\n\023UI_MODE_NIGHT_NIGHT\020\001\022\032\n\026UI_MOD"
+  "E_NIGHT_NOTNIGHT\020\002\"m\n\013Touchscreen\022\025\n\021TOU"
+  "CHSCREEN_UNSET\020\000\022\027\n\023TOUCHSCREEN_NOTOUCH\020"
+  "\001\022\026\n\022TOUCHSCREEN_STYLUS\020\002\022\026\n\022TOUCHSCREEN"
+  "_FINGER\020\003\"v\n\nKeysHidden\022\025\n\021KEYS_HIDDEN_U"
+  "NSET\020\000\022\033\n\027KEYS_HIDDEN_KEYSEXPOSED\020\001\022\032\n\026K"
+  "EYS_HIDDEN_KEYSHIDDEN\020\002\022\030\n\024KEYS_HIDDEN_K"
+  "EYSSOFT\020\003\"`\n\010Keyboard\022\022\n\016KEYBOARD_UNSET\020"
+  "\000\022\023\n\017KEYBOARD_NOKEYS\020\001\022\023\n\017KEYBOARD_QWERT"
+  "Y\020\002\022\026\n\022KEYBOARD_TWELVEKEY\020\003\"V\n\tNavHidden"
+  "\022\024\n\020NAV_HIDDEN_UNSET\020\000\022\031\n\025NAV_HIDDEN_NAV"
+  "EXPOSED\020\001\022\030\n\024NAV_HIDDEN_NAVHIDDEN\020\002\"}\n\nN"
+  "avigation\022\024\n\020NAVIGATION_UNSET\020\000\022\024\n\020NAVIG"
+  "ATION_NONAV\020\001\022\023\n\017NAVIGATION_DPAD\020\002\022\030\n\024NA"
+  "VIGATION_TRACKBALL\020\003\022\024\n\020NAVIGATION_WHEEL"
+  "\020\004B\022\n\020com.android.aaptb\006proto3"
+  ;
+static ::_pbi::once_flag descriptor_table_Configuration_2eproto_once;
+const ::_pbi::DescriptorTable descriptor_table_Configuration_2eproto = {
+    false, false, 2710, descriptor_table_protodef_Configuration_2eproto,
+    "Configuration.proto",
+    &descriptor_table_Configuration_2eproto_once, nullptr, 0, 1,
+    schemas, file_default_instances, TableStruct_Configuration_2eproto::offsets,
+    file_level_metadata_Configuration_2eproto, file_level_enum_descriptors_Configuration_2eproto,
+    file_level_service_descriptors_Configuration_2eproto,
+};
+PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_Configuration_2eproto_getter() {
+  return &descriptor_table_Configuration_2eproto;
+}
+
+// Force running AddDescriptors() at dynamic initialization time.
+PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_Configuration_2eproto(&descriptor_table_Configuration_2eproto);
+namespace aapt {
+namespace pb {
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_LayoutDirection_descriptor() {
+  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Configuration_2eproto);
+  return file_level_enum_descriptors_Configuration_2eproto[0];
+}
+bool Configuration_LayoutDirection_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+    case 2:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+constexpr Configuration_LayoutDirection Configuration::LAYOUT_DIRECTION_UNSET;
+constexpr Configuration_LayoutDirection Configuration::LAYOUT_DIRECTION_LTR;
+constexpr Configuration_LayoutDirection Configuration::LAYOUT_DIRECTION_RTL;
+constexpr Configuration_LayoutDirection Configuration::LayoutDirection_MIN;
+constexpr Configuration_LayoutDirection Configuration::LayoutDirection_MAX;
+constexpr int Configuration::LayoutDirection_ARRAYSIZE;
+#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_ScreenLayoutSize_descriptor() {
+  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Configuration_2eproto);
+  return file_level_enum_descriptors_Configuration_2eproto[1];
+}
+bool Configuration_ScreenLayoutSize_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+constexpr Configuration_ScreenLayoutSize Configuration::SCREEN_LAYOUT_SIZE_UNSET;
+constexpr Configuration_ScreenLayoutSize Configuration::SCREEN_LAYOUT_SIZE_SMALL;
+constexpr Configuration_ScreenLayoutSize Configuration::SCREEN_LAYOUT_SIZE_NORMAL;
+constexpr Configuration_ScreenLayoutSize Configuration::SCREEN_LAYOUT_SIZE_LARGE;
+constexpr Configuration_ScreenLayoutSize Configuration::SCREEN_LAYOUT_SIZE_XLARGE;
+constexpr Configuration_ScreenLayoutSize Configuration::ScreenLayoutSize_MIN;
+constexpr Configuration_ScreenLayoutSize Configuration::ScreenLayoutSize_MAX;
+constexpr int Configuration::ScreenLayoutSize_ARRAYSIZE;
+#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_ScreenLayoutLong_descriptor() {
+  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Configuration_2eproto);
+  return file_level_enum_descriptors_Configuration_2eproto[2];
+}
+bool Configuration_ScreenLayoutLong_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+    case 2:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+constexpr Configuration_ScreenLayoutLong Configuration::SCREEN_LAYOUT_LONG_UNSET;
+constexpr Configuration_ScreenLayoutLong Configuration::SCREEN_LAYOUT_LONG_LONG;
+constexpr Configuration_ScreenLayoutLong Configuration::SCREEN_LAYOUT_LONG_NOTLONG;
+constexpr Configuration_ScreenLayoutLong Configuration::ScreenLayoutLong_MIN;
+constexpr Configuration_ScreenLayoutLong Configuration::ScreenLayoutLong_MAX;
+constexpr int Configuration::ScreenLayoutLong_ARRAYSIZE;
+#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_ScreenRound_descriptor() {
+  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Configuration_2eproto);
+  return file_level_enum_descriptors_Configuration_2eproto[3];
+}
+bool Configuration_ScreenRound_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+    case 2:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+constexpr Configuration_ScreenRound Configuration::SCREEN_ROUND_UNSET;
+constexpr Configuration_ScreenRound Configuration::SCREEN_ROUND_ROUND;
+constexpr Configuration_ScreenRound Configuration::SCREEN_ROUND_NOTROUND;
+constexpr Configuration_ScreenRound Configuration::ScreenRound_MIN;
+constexpr Configuration_ScreenRound Configuration::ScreenRound_MAX;
+constexpr int Configuration::ScreenRound_ARRAYSIZE;
+#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_WideColorGamut_descriptor() {
+  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Configuration_2eproto);
+  return file_level_enum_descriptors_Configuration_2eproto[4];
+}
+bool Configuration_WideColorGamut_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+    case 2:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+constexpr Configuration_WideColorGamut Configuration::WIDE_COLOR_GAMUT_UNSET;
+constexpr Configuration_WideColorGamut Configuration::WIDE_COLOR_GAMUT_WIDECG;
+constexpr Configuration_WideColorGamut Configuration::WIDE_COLOR_GAMUT_NOWIDECG;
+constexpr Configuration_WideColorGamut Configuration::WideColorGamut_MIN;
+constexpr Configuration_WideColorGamut Configuration::WideColorGamut_MAX;
+constexpr int Configuration::WideColorGamut_ARRAYSIZE;
+#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_Hdr_descriptor() {
+  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Configuration_2eproto);
+  return file_level_enum_descriptors_Configuration_2eproto[5];
+}
+bool Configuration_Hdr_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+    case 2:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+constexpr Configuration_Hdr Configuration::HDR_UNSET;
+constexpr Configuration_Hdr Configuration::HDR_HIGHDR;
+constexpr Configuration_Hdr Configuration::HDR_LOWDR;
+constexpr Configuration_Hdr Configuration::Hdr_MIN;
+constexpr Configuration_Hdr Configuration::Hdr_MAX;
+constexpr int Configuration::Hdr_ARRAYSIZE;
+#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_Orientation_descriptor() {
+  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Configuration_2eproto);
+  return file_level_enum_descriptors_Configuration_2eproto[6];
+}
+bool Configuration_Orientation_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+constexpr Configuration_Orientation Configuration::ORIENTATION_UNSET;
+constexpr Configuration_Orientation Configuration::ORIENTATION_PORT;
+constexpr Configuration_Orientation Configuration::ORIENTATION_LAND;
+constexpr Configuration_Orientation Configuration::ORIENTATION_SQUARE;
+constexpr Configuration_Orientation Configuration::Orientation_MIN;
+constexpr Configuration_Orientation Configuration::Orientation_MAX;
+constexpr int Configuration::Orientation_ARRAYSIZE;
+#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_UiModeType_descriptor() {
+  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Configuration_2eproto);
+  return file_level_enum_descriptors_Configuration_2eproto[7];
+}
+bool Configuration_UiModeType_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+    case 5:
+    case 6:
+    case 7:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+constexpr Configuration_UiModeType Configuration::UI_MODE_TYPE_UNSET;
+constexpr Configuration_UiModeType Configuration::UI_MODE_TYPE_NORMAL;
+constexpr Configuration_UiModeType Configuration::UI_MODE_TYPE_DESK;
+constexpr Configuration_UiModeType Configuration::UI_MODE_TYPE_CAR;
+constexpr Configuration_UiModeType Configuration::UI_MODE_TYPE_TELEVISION;
+constexpr Configuration_UiModeType Configuration::UI_MODE_TYPE_APPLIANCE;
+constexpr Configuration_UiModeType Configuration::UI_MODE_TYPE_WATCH;
+constexpr Configuration_UiModeType Configuration::UI_MODE_TYPE_VRHEADSET;
+constexpr Configuration_UiModeType Configuration::UiModeType_MIN;
+constexpr Configuration_UiModeType Configuration::UiModeType_MAX;
+constexpr int Configuration::UiModeType_ARRAYSIZE;
+#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_UiModeNight_descriptor() {
+  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Configuration_2eproto);
+  return file_level_enum_descriptors_Configuration_2eproto[8];
+}
+bool Configuration_UiModeNight_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+    case 2:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+constexpr Configuration_UiModeNight Configuration::UI_MODE_NIGHT_UNSET;
+constexpr Configuration_UiModeNight Configuration::UI_MODE_NIGHT_NIGHT;
+constexpr Configuration_UiModeNight Configuration::UI_MODE_NIGHT_NOTNIGHT;
+constexpr Configuration_UiModeNight Configuration::UiModeNight_MIN;
+constexpr Configuration_UiModeNight Configuration::UiModeNight_MAX;
+constexpr int Configuration::UiModeNight_ARRAYSIZE;
+#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_Touchscreen_descriptor() {
+  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Configuration_2eproto);
+  return file_level_enum_descriptors_Configuration_2eproto[9];
+}
+bool Configuration_Touchscreen_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+constexpr Configuration_Touchscreen Configuration::TOUCHSCREEN_UNSET;
+constexpr Configuration_Touchscreen Configuration::TOUCHSCREEN_NOTOUCH;
+constexpr Configuration_Touchscreen Configuration::TOUCHSCREEN_STYLUS;
+constexpr Configuration_Touchscreen Configuration::TOUCHSCREEN_FINGER;
+constexpr Configuration_Touchscreen Configuration::Touchscreen_MIN;
+constexpr Configuration_Touchscreen Configuration::Touchscreen_MAX;
+constexpr int Configuration::Touchscreen_ARRAYSIZE;
+#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_KeysHidden_descriptor() {
+  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Configuration_2eproto);
+  return file_level_enum_descriptors_Configuration_2eproto[10];
+}
+bool Configuration_KeysHidden_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+constexpr Configuration_KeysHidden Configuration::KEYS_HIDDEN_UNSET;
+constexpr Configuration_KeysHidden Configuration::KEYS_HIDDEN_KEYSEXPOSED;
+constexpr Configuration_KeysHidden Configuration::KEYS_HIDDEN_KEYSHIDDEN;
+constexpr Configuration_KeysHidden Configuration::KEYS_HIDDEN_KEYSSOFT;
+constexpr Configuration_KeysHidden Configuration::KeysHidden_MIN;
+constexpr Configuration_KeysHidden Configuration::KeysHidden_MAX;
+constexpr int Configuration::KeysHidden_ARRAYSIZE;
+#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_Keyboard_descriptor() {
+  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Configuration_2eproto);
+  return file_level_enum_descriptors_Configuration_2eproto[11];
+}
+bool Configuration_Keyboard_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+constexpr Configuration_Keyboard Configuration::KEYBOARD_UNSET;
+constexpr Configuration_Keyboard Configuration::KEYBOARD_NOKEYS;
+constexpr Configuration_Keyboard Configuration::KEYBOARD_QWERTY;
+constexpr Configuration_Keyboard Configuration::KEYBOARD_TWELVEKEY;
+constexpr Configuration_Keyboard Configuration::Keyboard_MIN;
+constexpr Configuration_Keyboard Configuration::Keyboard_MAX;
+constexpr int Configuration::Keyboard_ARRAYSIZE;
+#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_NavHidden_descriptor() {
+  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Configuration_2eproto);
+  return file_level_enum_descriptors_Configuration_2eproto[12];
+}
+bool Configuration_NavHidden_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+    case 2:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+constexpr Configuration_NavHidden Configuration::NAV_HIDDEN_UNSET;
+constexpr Configuration_NavHidden Configuration::NAV_HIDDEN_NAVEXPOSED;
+constexpr Configuration_NavHidden Configuration::NAV_HIDDEN_NAVHIDDEN;
+constexpr Configuration_NavHidden Configuration::NavHidden_MIN;
+constexpr Configuration_NavHidden Configuration::NavHidden_MAX;
+constexpr int Configuration::NavHidden_ARRAYSIZE;
+#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_Navigation_descriptor() {
+  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Configuration_2eproto);
+  return file_level_enum_descriptors_Configuration_2eproto[13];
+}
+bool Configuration_Navigation_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+constexpr Configuration_Navigation Configuration::NAVIGATION_UNSET;
+constexpr Configuration_Navigation Configuration::NAVIGATION_NONAV;
+constexpr Configuration_Navigation Configuration::NAVIGATION_DPAD;
+constexpr Configuration_Navigation Configuration::NAVIGATION_TRACKBALL;
+constexpr Configuration_Navigation Configuration::NAVIGATION_WHEEL;
+constexpr Configuration_Navigation Configuration::Navigation_MIN;
+constexpr Configuration_Navigation Configuration::Navigation_MAX;
+constexpr int Configuration::Navigation_ARRAYSIZE;
+#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+
+// ===================================================================
+
+class Configuration::_Internal {
+ public:
+};
+
+Configuration::Configuration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Configuration)
+}
+Configuration::Configuration(const Configuration& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Configuration* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.locale_){}
+    , decltype(_impl_.product_){}
+    , decltype(_impl_.mcc_){}
+    , decltype(_impl_.mnc_){}
+    , decltype(_impl_.layout_direction_){}
+    , decltype(_impl_.screen_width_){}
+    , decltype(_impl_.screen_height_){}
+    , decltype(_impl_.screen_width_dp_){}
+    , decltype(_impl_.screen_height_dp_){}
+    , decltype(_impl_.smallest_screen_width_dp_){}
+    , decltype(_impl_.screen_layout_size_){}
+    , decltype(_impl_.screen_layout_long_){}
+    , decltype(_impl_.screen_round_){}
+    , decltype(_impl_.wide_color_gamut_){}
+    , decltype(_impl_.hdr_){}
+    , decltype(_impl_.orientation_){}
+    , decltype(_impl_.ui_mode_type_){}
+    , decltype(_impl_.ui_mode_night_){}
+    , decltype(_impl_.density_){}
+    , decltype(_impl_.touchscreen_){}
+    , decltype(_impl_.keys_hidden_){}
+    , decltype(_impl_.keyboard_){}
+    , decltype(_impl_.nav_hidden_){}
+    , decltype(_impl_.navigation_){}
+    , decltype(_impl_.sdk_version_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.locale_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.locale_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_locale().empty()) {
+    _this->_impl_.locale_.Set(from._internal_locale(), 
+      _this->GetArenaForAllocation());
+  }
+  _impl_.product_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.product_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_product().empty()) {
+    _this->_impl_.product_.Set(from._internal_product(), 
+      _this->GetArenaForAllocation());
+  }
+  ::memcpy(&_impl_.mcc_, &from._impl_.mcc_,
+    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sdk_version_) -
+    reinterpret_cast<char*>(&_impl_.mcc_)) + sizeof(_impl_.sdk_version_));
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Configuration)
+}
+
+inline void Configuration::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.locale_){}
+    , decltype(_impl_.product_){}
+    , decltype(_impl_.mcc_){0u}
+    , decltype(_impl_.mnc_){0u}
+    , decltype(_impl_.layout_direction_){0}
+    , decltype(_impl_.screen_width_){0u}
+    , decltype(_impl_.screen_height_){0u}
+    , decltype(_impl_.screen_width_dp_){0u}
+    , decltype(_impl_.screen_height_dp_){0u}
+    , decltype(_impl_.smallest_screen_width_dp_){0u}
+    , decltype(_impl_.screen_layout_size_){0}
+    , decltype(_impl_.screen_layout_long_){0}
+    , decltype(_impl_.screen_round_){0}
+    , decltype(_impl_.wide_color_gamut_){0}
+    , decltype(_impl_.hdr_){0}
+    , decltype(_impl_.orientation_){0}
+    , decltype(_impl_.ui_mode_type_){0}
+    , decltype(_impl_.ui_mode_night_){0}
+    , decltype(_impl_.density_){0u}
+    , decltype(_impl_.touchscreen_){0}
+    , decltype(_impl_.keys_hidden_){0}
+    , decltype(_impl_.keyboard_){0}
+    , decltype(_impl_.nav_hidden_){0}
+    , decltype(_impl_.navigation_){0}
+    , decltype(_impl_.sdk_version_){0u}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.locale_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.locale_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.product_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.product_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+Configuration::~Configuration() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Configuration)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Configuration::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.locale_.Destroy();
+  _impl_.product_.Destroy();
+}
+
+void Configuration::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Configuration::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Configuration)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.locale_.ClearToEmpty();
+  _impl_.product_.ClearToEmpty();
+  ::memset(&_impl_.mcc_, 0, static_cast<size_t>(
+      reinterpret_cast<char*>(&_impl_.sdk_version_) -
+      reinterpret_cast<char*>(&_impl_.mcc_)) + sizeof(_impl_.sdk_version_));
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Configuration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // uint32 mcc = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
+          _impl_.mcc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 mnc = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
+          _impl_.mnc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string locale = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          auto str = _internal_mutable_locale();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.Configuration.locale"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Configuration.LayoutDirection layout_direction = 4;
+      case 4:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
+          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+          _internal_set_layout_direction(static_cast<::aapt::pb::Configuration_LayoutDirection>(val));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 screen_width = 5;
+      case 5:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
+          _impl_.screen_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 screen_height = 6;
+      case 6:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
+          _impl_.screen_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 screen_width_dp = 7;
+      case 7:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
+          _impl_.screen_width_dp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 screen_height_dp = 8;
+      case 8:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
+          _impl_.screen_height_dp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 smallest_screen_width_dp = 9;
+      case 9:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
+          _impl_.smallest_screen_width_dp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Configuration.ScreenLayoutSize screen_layout_size = 10;
+      case 10:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
+          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+          _internal_set_screen_layout_size(static_cast<::aapt::pb::Configuration_ScreenLayoutSize>(val));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Configuration.ScreenLayoutLong screen_layout_long = 11;
+      case 11:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
+          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+          _internal_set_screen_layout_long(static_cast<::aapt::pb::Configuration_ScreenLayoutLong>(val));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Configuration.ScreenRound screen_round = 12;
+      case 12:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
+          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+          _internal_set_screen_round(static_cast<::aapt::pb::Configuration_ScreenRound>(val));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Configuration.WideColorGamut wide_color_gamut = 13;
+      case 13:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
+          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+          _internal_set_wide_color_gamut(static_cast<::aapt::pb::Configuration_WideColorGamut>(val));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Configuration.Hdr hdr = 14;
+      case 14:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
+          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+          _internal_set_hdr(static_cast<::aapt::pb::Configuration_Hdr>(val));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Configuration.Orientation orientation = 15;
+      case 15:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
+          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+          _internal_set_orientation(static_cast<::aapt::pb::Configuration_Orientation>(val));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Configuration.UiModeType ui_mode_type = 16;
+      case 16:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
+          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+          _internal_set_ui_mode_type(static_cast<::aapt::pb::Configuration_UiModeType>(val));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Configuration.UiModeNight ui_mode_night = 17;
+      case 17:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 136)) {
+          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+          _internal_set_ui_mode_night(static_cast<::aapt::pb::Configuration_UiModeNight>(val));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 density = 18;
+      case 18:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 144)) {
+          _impl_.density_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Configuration.Touchscreen touchscreen = 19;
+      case 19:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 152)) {
+          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+          _internal_set_touchscreen(static_cast<::aapt::pb::Configuration_Touchscreen>(val));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Configuration.KeysHidden keys_hidden = 20;
+      case 20:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 160)) {
+          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+          _internal_set_keys_hidden(static_cast<::aapt::pb::Configuration_KeysHidden>(val));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Configuration.Keyboard keyboard = 21;
+      case 21:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 168)) {
+          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+          _internal_set_keyboard(static_cast<::aapt::pb::Configuration_Keyboard>(val));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Configuration.NavHidden nav_hidden = 22;
+      case 22:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 176)) {
+          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+          _internal_set_nav_hidden(static_cast<::aapt::pb::Configuration_NavHidden>(val));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Configuration.Navigation navigation = 23;
+      case 23:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 184)) {
+          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+          _internal_set_navigation(static_cast<::aapt::pb::Configuration_Navigation>(val));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 sdk_version = 24;
+      case 24:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 192)) {
+          _impl_.sdk_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string product = 25;
+      case 25:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 202)) {
+          auto str = _internal_mutable_product();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.Configuration.product"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Configuration::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Configuration)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // uint32 mcc = 1;
+  if (this->_internal_mcc() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_mcc(), target);
+  }
+
+  // uint32 mnc = 2;
+  if (this->_internal_mnc() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_mnc(), target);
+  }
+
+  // string locale = 3;
+  if (!this->_internal_locale().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_locale().data(), static_cast<int>(this->_internal_locale().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.Configuration.locale");
+    target = stream->WriteStringMaybeAliased(
+        3, this->_internal_locale(), target);
+  }
+
+  // .aapt.pb.Configuration.LayoutDirection layout_direction = 4;
+  if (this->_internal_layout_direction() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteEnumToArray(
+      4, this->_internal_layout_direction(), target);
+  }
+
+  // uint32 screen_width = 5;
+  if (this->_internal_screen_width() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_screen_width(), target);
+  }
+
+  // uint32 screen_height = 6;
+  if (this->_internal_screen_height() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_screen_height(), target);
+  }
+
+  // uint32 screen_width_dp = 7;
+  if (this->_internal_screen_width_dp() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_screen_width_dp(), target);
+  }
+
+  // uint32 screen_height_dp = 8;
+  if (this->_internal_screen_height_dp() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_screen_height_dp(), target);
+  }
+
+  // uint32 smallest_screen_width_dp = 9;
+  if (this->_internal_smallest_screen_width_dp() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_smallest_screen_width_dp(), target);
+  }
+
+  // .aapt.pb.Configuration.ScreenLayoutSize screen_layout_size = 10;
+  if (this->_internal_screen_layout_size() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteEnumToArray(
+      10, this->_internal_screen_layout_size(), target);
+  }
+
+  // .aapt.pb.Configuration.ScreenLayoutLong screen_layout_long = 11;
+  if (this->_internal_screen_layout_long() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteEnumToArray(
+      11, this->_internal_screen_layout_long(), target);
+  }
+
+  // .aapt.pb.Configuration.ScreenRound screen_round = 12;
+  if (this->_internal_screen_round() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteEnumToArray(
+      12, this->_internal_screen_round(), target);
+  }
+
+  // .aapt.pb.Configuration.WideColorGamut wide_color_gamut = 13;
+  if (this->_internal_wide_color_gamut() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteEnumToArray(
+      13, this->_internal_wide_color_gamut(), target);
+  }
+
+  // .aapt.pb.Configuration.Hdr hdr = 14;
+  if (this->_internal_hdr() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteEnumToArray(
+      14, this->_internal_hdr(), target);
+  }
+
+  // .aapt.pb.Configuration.Orientation orientation = 15;
+  if (this->_internal_orientation() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteEnumToArray(
+      15, this->_internal_orientation(), target);
+  }
+
+  // .aapt.pb.Configuration.UiModeType ui_mode_type = 16;
+  if (this->_internal_ui_mode_type() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteEnumToArray(
+      16, this->_internal_ui_mode_type(), target);
+  }
+
+  // .aapt.pb.Configuration.UiModeNight ui_mode_night = 17;
+  if (this->_internal_ui_mode_night() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteEnumToArray(
+      17, this->_internal_ui_mode_night(), target);
+  }
+
+  // uint32 density = 18;
+  if (this->_internal_density() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_density(), target);
+  }
+
+  // .aapt.pb.Configuration.Touchscreen touchscreen = 19;
+  if (this->_internal_touchscreen() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteEnumToArray(
+      19, this->_internal_touchscreen(), target);
+  }
+
+  // .aapt.pb.Configuration.KeysHidden keys_hidden = 20;
+  if (this->_internal_keys_hidden() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteEnumToArray(
+      20, this->_internal_keys_hidden(), target);
+  }
+
+  // .aapt.pb.Configuration.Keyboard keyboard = 21;
+  if (this->_internal_keyboard() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteEnumToArray(
+      21, this->_internal_keyboard(), target);
+  }
+
+  // .aapt.pb.Configuration.NavHidden nav_hidden = 22;
+  if (this->_internal_nav_hidden() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteEnumToArray(
+      22, this->_internal_nav_hidden(), target);
+  }
+
+  // .aapt.pb.Configuration.Navigation navigation = 23;
+  if (this->_internal_navigation() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteEnumToArray(
+      23, this->_internal_navigation(), target);
+  }
+
+  // uint32 sdk_version = 24;
+  if (this->_internal_sdk_version() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(24, this->_internal_sdk_version(), target);
+  }
+
+  // string product = 25;
+  if (!this->_internal_product().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_product().data(), static_cast<int>(this->_internal_product().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.Configuration.product");
+    target = stream->WriteStringMaybeAliased(
+        25, this->_internal_product(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Configuration)
+  return target;
+}
+
+size_t Configuration::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Configuration)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string locale = 3;
+  if (!this->_internal_locale().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_locale());
+  }
+
+  // string product = 25;
+  if (!this->_internal_product().empty()) {
+    total_size += 2 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_product());
+  }
+
+  // uint32 mcc = 1;
+  if (this->_internal_mcc() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mcc());
+  }
+
+  // uint32 mnc = 2;
+  if (this->_internal_mnc() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mnc());
+  }
+
+  // .aapt.pb.Configuration.LayoutDirection layout_direction = 4;
+  if (this->_internal_layout_direction() != 0) {
+    total_size += 1 +
+      ::_pbi::WireFormatLite::EnumSize(this->_internal_layout_direction());
+  }
+
+  // uint32 screen_width = 5;
+  if (this->_internal_screen_width() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_screen_width());
+  }
+
+  // uint32 screen_height = 6;
+  if (this->_internal_screen_height() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_screen_height());
+  }
+
+  // uint32 screen_width_dp = 7;
+  if (this->_internal_screen_width_dp() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_screen_width_dp());
+  }
+
+  // uint32 screen_height_dp = 8;
+  if (this->_internal_screen_height_dp() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_screen_height_dp());
+  }
+
+  // uint32 smallest_screen_width_dp = 9;
+  if (this->_internal_smallest_screen_width_dp() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_smallest_screen_width_dp());
+  }
+
+  // .aapt.pb.Configuration.ScreenLayoutSize screen_layout_size = 10;
+  if (this->_internal_screen_layout_size() != 0) {
+    total_size += 1 +
+      ::_pbi::WireFormatLite::EnumSize(this->_internal_screen_layout_size());
+  }
+
+  // .aapt.pb.Configuration.ScreenLayoutLong screen_layout_long = 11;
+  if (this->_internal_screen_layout_long() != 0) {
+    total_size += 1 +
+      ::_pbi::WireFormatLite::EnumSize(this->_internal_screen_layout_long());
+  }
+
+  // .aapt.pb.Configuration.ScreenRound screen_round = 12;
+  if (this->_internal_screen_round() != 0) {
+    total_size += 1 +
+      ::_pbi::WireFormatLite::EnumSize(this->_internal_screen_round());
+  }
+
+  // .aapt.pb.Configuration.WideColorGamut wide_color_gamut = 13;
+  if (this->_internal_wide_color_gamut() != 0) {
+    total_size += 1 +
+      ::_pbi::WireFormatLite::EnumSize(this->_internal_wide_color_gamut());
+  }
+
+  // .aapt.pb.Configuration.Hdr hdr = 14;
+  if (this->_internal_hdr() != 0) {
+    total_size += 1 +
+      ::_pbi::WireFormatLite::EnumSize(this->_internal_hdr());
+  }
+
+  // .aapt.pb.Configuration.Orientation orientation = 15;
+  if (this->_internal_orientation() != 0) {
+    total_size += 1 +
+      ::_pbi::WireFormatLite::EnumSize(this->_internal_orientation());
+  }
+
+  // .aapt.pb.Configuration.UiModeType ui_mode_type = 16;
+  if (this->_internal_ui_mode_type() != 0) {
+    total_size += 2 +
+      ::_pbi::WireFormatLite::EnumSize(this->_internal_ui_mode_type());
+  }
+
+  // .aapt.pb.Configuration.UiModeNight ui_mode_night = 17;
+  if (this->_internal_ui_mode_night() != 0) {
+    total_size += 2 +
+      ::_pbi::WireFormatLite::EnumSize(this->_internal_ui_mode_night());
+  }
+
+  // uint32 density = 18;
+  if (this->_internal_density() != 0) {
+    total_size += 2 +
+      ::_pbi::WireFormatLite::UInt32Size(
+        this->_internal_density());
+  }
+
+  // .aapt.pb.Configuration.Touchscreen touchscreen = 19;
+  if (this->_internal_touchscreen() != 0) {
+    total_size += 2 +
+      ::_pbi::WireFormatLite::EnumSize(this->_internal_touchscreen());
+  }
+
+  // .aapt.pb.Configuration.KeysHidden keys_hidden = 20;
+  if (this->_internal_keys_hidden() != 0) {
+    total_size += 2 +
+      ::_pbi::WireFormatLite::EnumSize(this->_internal_keys_hidden());
+  }
+
+  // .aapt.pb.Configuration.Keyboard keyboard = 21;
+  if (this->_internal_keyboard() != 0) {
+    total_size += 2 +
+      ::_pbi::WireFormatLite::EnumSize(this->_internal_keyboard());
+  }
+
+  // .aapt.pb.Configuration.NavHidden nav_hidden = 22;
+  if (this->_internal_nav_hidden() != 0) {
+    total_size += 2 +
+      ::_pbi::WireFormatLite::EnumSize(this->_internal_nav_hidden());
+  }
+
+  // .aapt.pb.Configuration.Navigation navigation = 23;
+  if (this->_internal_navigation() != 0) {
+    total_size += 2 +
+      ::_pbi::WireFormatLite::EnumSize(this->_internal_navigation());
+  }
+
+  // uint32 sdk_version = 24;
+  if (this->_internal_sdk_version() != 0) {
+    total_size += 2 +
+      ::_pbi::WireFormatLite::UInt32Size(
+        this->_internal_sdk_version());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Configuration::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Configuration::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Configuration::GetClassData() const { return &_class_data_; }
+
+
+void Configuration::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Configuration*>(&to_msg);
+  auto& from = static_cast<const Configuration&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Configuration)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_locale().empty()) {
+    _this->_internal_set_locale(from._internal_locale());
+  }
+  if (!from._internal_product().empty()) {
+    _this->_internal_set_product(from._internal_product());
+  }
+  if (from._internal_mcc() != 0) {
+    _this->_internal_set_mcc(from._internal_mcc());
+  }
+  if (from._internal_mnc() != 0) {
+    _this->_internal_set_mnc(from._internal_mnc());
+  }
+  if (from._internal_layout_direction() != 0) {
+    _this->_internal_set_layout_direction(from._internal_layout_direction());
+  }
+  if (from._internal_screen_width() != 0) {
+    _this->_internal_set_screen_width(from._internal_screen_width());
+  }
+  if (from._internal_screen_height() != 0) {
+    _this->_internal_set_screen_height(from._internal_screen_height());
+  }
+  if (from._internal_screen_width_dp() != 0) {
+    _this->_internal_set_screen_width_dp(from._internal_screen_width_dp());
+  }
+  if (from._internal_screen_height_dp() != 0) {
+    _this->_internal_set_screen_height_dp(from._internal_screen_height_dp());
+  }
+  if (from._internal_smallest_screen_width_dp() != 0) {
+    _this->_internal_set_smallest_screen_width_dp(from._internal_smallest_screen_width_dp());
+  }
+  if (from._internal_screen_layout_size() != 0) {
+    _this->_internal_set_screen_layout_size(from._internal_screen_layout_size());
+  }
+  if (from._internal_screen_layout_long() != 0) {
+    _this->_internal_set_screen_layout_long(from._internal_screen_layout_long());
+  }
+  if (from._internal_screen_round() != 0) {
+    _this->_internal_set_screen_round(from._internal_screen_round());
+  }
+  if (from._internal_wide_color_gamut() != 0) {
+    _this->_internal_set_wide_color_gamut(from._internal_wide_color_gamut());
+  }
+  if (from._internal_hdr() != 0) {
+    _this->_internal_set_hdr(from._internal_hdr());
+  }
+  if (from._internal_orientation() != 0) {
+    _this->_internal_set_orientation(from._internal_orientation());
+  }
+  if (from._internal_ui_mode_type() != 0) {
+    _this->_internal_set_ui_mode_type(from._internal_ui_mode_type());
+  }
+  if (from._internal_ui_mode_night() != 0) {
+    _this->_internal_set_ui_mode_night(from._internal_ui_mode_night());
+  }
+  if (from._internal_density() != 0) {
+    _this->_internal_set_density(from._internal_density());
+  }
+  if (from._internal_touchscreen() != 0) {
+    _this->_internal_set_touchscreen(from._internal_touchscreen());
+  }
+  if (from._internal_keys_hidden() != 0) {
+    _this->_internal_set_keys_hidden(from._internal_keys_hidden());
+  }
+  if (from._internal_keyboard() != 0) {
+    _this->_internal_set_keyboard(from._internal_keyboard());
+  }
+  if (from._internal_nav_hidden() != 0) {
+    _this->_internal_set_nav_hidden(from._internal_nav_hidden());
+  }
+  if (from._internal_navigation() != 0) {
+    _this->_internal_set_navigation(from._internal_navigation());
+  }
+  if (from._internal_sdk_version() != 0) {
+    _this->_internal_set_sdk_version(from._internal_sdk_version());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Configuration::CopyFrom(const Configuration& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Configuration)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Configuration::IsInitialized() const {
+  return true;
+}
+
+void Configuration::InternalSwap(Configuration* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.locale_, lhs_arena,
+      &other->_impl_.locale_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.product_, lhs_arena,
+      &other->_impl_.product_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(Configuration, _impl_.sdk_version_)
+      + sizeof(Configuration::_impl_.sdk_version_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(Configuration, _impl_.mcc_)>(
+          reinterpret_cast<char*>(&_impl_.mcc_),
+          reinterpret_cast<char*>(&other->_impl_.mcc_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Configuration::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Configuration_2eproto_getter, &descriptor_table_Configuration_2eproto_once,
+      file_level_metadata_Configuration_2eproto[0]);
+}
+
+// @@protoc_insertion_point(namespace_scope)
+}  // namespace pb
+}  // namespace aapt
+PROTOBUF_NAMESPACE_OPEN
+template<> PROTOBUF_NOINLINE ::aapt::pb::Configuration*
+Arena::CreateMaybeMessage< ::aapt::pb::Configuration >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Configuration >(arena);
+}
+PROTOBUF_NAMESPACE_CLOSE
+
+// @@protoc_insertion_point(global_scope)
+#include <google/protobuf/port_undef.inc>
diff --git a/tools/aapt2/Configuration.pb.h b/tools/aapt2/Configuration.pb.h
new file mode 100644
index 00000000..c8ca3826
--- /dev/null
+++ b/tools/aapt2/Configuration.pb.h
@@ -0,0 +1,1987 @@
+// Generated by the protocol buffer compiler.  DO NOT EDIT!
+// source: Configuration.proto
+
+#ifndef GOOGLE_PROTOBUF_INCLUDED_Configuration_2eproto
+#define GOOGLE_PROTOBUF_INCLUDED_Configuration_2eproto
+
+#include <cstdint>
+#include <limits>
+#include <string>
+
+#include <google/protobuf/port_def.inc>
+#if PROTOBUF_VERSION < 3021000
+#error This file was generated by a newer version of protoc which is
+#error incompatible with your Protocol Buffer headers. Please update
+#error your headers.
+#endif
+#if 3021007 < PROTOBUF_MIN_PROTOC_VERSION
+#error This file was generated by an older version of protoc which is
+#error incompatible with your Protocol Buffer headers. Please
+#error regenerate this file with a newer version of protoc.
+#endif
+
+#include <google/protobuf/port_undef.inc>
+#include <google/protobuf/io/coded_stream.h>
+#include <google/protobuf/arena.h>
+#include <google/protobuf/arenastring.h>
+#include <google/protobuf/generated_message_util.h>
+#include <google/protobuf/metadata_lite.h>
+#include <google/protobuf/generated_message_reflection.h>
+#include <google/protobuf/message.h>
+#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
+#include <google/protobuf/extension_set.h>  // IWYU pragma: export
+#include <google/protobuf/generated_enum_reflection.h>
+#include <google/protobuf/unknown_field_set.h>
+// @@protoc_insertion_point(includes)
+#include <google/protobuf/port_def.inc>
+#define PROTOBUF_INTERNAL_EXPORT_Configuration_2eproto
+PROTOBUF_NAMESPACE_OPEN
+namespace internal {
+class AnyMetadata;
+}  // namespace internal
+PROTOBUF_NAMESPACE_CLOSE
+
+// Internal implementation detail -- do not use these members.
+struct TableStruct_Configuration_2eproto {
+  static const ::uint32_t offsets[];
+};
+extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Configuration_2eproto;
+namespace aapt {
+namespace pb {
+class Configuration;
+struct ConfigurationDefaultTypeInternal;
+extern ConfigurationDefaultTypeInternal _Configuration_default_instance_;
+}  // namespace pb
+}  // namespace aapt
+PROTOBUF_NAMESPACE_OPEN
+template<> ::aapt::pb::Configuration* Arena::CreateMaybeMessage<::aapt::pb::Configuration>(Arena*);
+PROTOBUF_NAMESPACE_CLOSE
+namespace aapt {
+namespace pb {
+
+enum Configuration_LayoutDirection : int {
+  Configuration_LayoutDirection_LAYOUT_DIRECTION_UNSET = 0,
+  Configuration_LayoutDirection_LAYOUT_DIRECTION_LTR = 1,
+  Configuration_LayoutDirection_LAYOUT_DIRECTION_RTL = 2,
+  Configuration_LayoutDirection_Configuration_LayoutDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
+  Configuration_LayoutDirection_Configuration_LayoutDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
+};
+bool Configuration_LayoutDirection_IsValid(int value);
+constexpr Configuration_LayoutDirection Configuration_LayoutDirection_LayoutDirection_MIN = Configuration_LayoutDirection_LAYOUT_DIRECTION_UNSET;
+constexpr Configuration_LayoutDirection Configuration_LayoutDirection_LayoutDirection_MAX = Configuration_LayoutDirection_LAYOUT_DIRECTION_RTL;
+constexpr int Configuration_LayoutDirection_LayoutDirection_ARRAYSIZE = Configuration_LayoutDirection_LayoutDirection_MAX + 1;
+
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_LayoutDirection_descriptor();
+template<typename T>
+inline const std::string& Configuration_LayoutDirection_Name(T enum_t_value) {
+  static_assert(::std::is_same<T, Configuration_LayoutDirection>::value ||
+    ::std::is_integral<T>::value,
+    "Incorrect type passed to function Configuration_LayoutDirection_Name.");
+  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
+    Configuration_LayoutDirection_descriptor(), enum_t_value);
+}
+inline bool Configuration_LayoutDirection_Parse(
+    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_LayoutDirection* value) {
+  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_LayoutDirection>(
+    Configuration_LayoutDirection_descriptor(), name, value);
+}
+enum Configuration_ScreenLayoutSize : int {
+  Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_UNSET = 0,
+  Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_SMALL = 1,
+  Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_NORMAL = 2,
+  Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_LARGE = 3,
+  Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_XLARGE = 4,
+  Configuration_ScreenLayoutSize_Configuration_ScreenLayoutSize_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
+  Configuration_ScreenLayoutSize_Configuration_ScreenLayoutSize_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
+};
+bool Configuration_ScreenLayoutSize_IsValid(int value);
+constexpr Configuration_ScreenLayoutSize Configuration_ScreenLayoutSize_ScreenLayoutSize_MIN = Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_UNSET;
+constexpr Configuration_ScreenLayoutSize Configuration_ScreenLayoutSize_ScreenLayoutSize_MAX = Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_XLARGE;
+constexpr int Configuration_ScreenLayoutSize_ScreenLayoutSize_ARRAYSIZE = Configuration_ScreenLayoutSize_ScreenLayoutSize_MAX + 1;
+
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_ScreenLayoutSize_descriptor();
+template<typename T>
+inline const std::string& Configuration_ScreenLayoutSize_Name(T enum_t_value) {
+  static_assert(::std::is_same<T, Configuration_ScreenLayoutSize>::value ||
+    ::std::is_integral<T>::value,
+    "Incorrect type passed to function Configuration_ScreenLayoutSize_Name.");
+  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
+    Configuration_ScreenLayoutSize_descriptor(), enum_t_value);
+}
+inline bool Configuration_ScreenLayoutSize_Parse(
+    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_ScreenLayoutSize* value) {
+  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_ScreenLayoutSize>(
+    Configuration_ScreenLayoutSize_descriptor(), name, value);
+}
+enum Configuration_ScreenLayoutLong : int {
+  Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_UNSET = 0,
+  Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_LONG = 1,
+  Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_NOTLONG = 2,
+  Configuration_ScreenLayoutLong_Configuration_ScreenLayoutLong_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
+  Configuration_ScreenLayoutLong_Configuration_ScreenLayoutLong_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
+};
+bool Configuration_ScreenLayoutLong_IsValid(int value);
+constexpr Configuration_ScreenLayoutLong Configuration_ScreenLayoutLong_ScreenLayoutLong_MIN = Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_UNSET;
+constexpr Configuration_ScreenLayoutLong Configuration_ScreenLayoutLong_ScreenLayoutLong_MAX = Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_NOTLONG;
+constexpr int Configuration_ScreenLayoutLong_ScreenLayoutLong_ARRAYSIZE = Configuration_ScreenLayoutLong_ScreenLayoutLong_MAX + 1;
+
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_ScreenLayoutLong_descriptor();
+template<typename T>
+inline const std::string& Configuration_ScreenLayoutLong_Name(T enum_t_value) {
+  static_assert(::std::is_same<T, Configuration_ScreenLayoutLong>::value ||
+    ::std::is_integral<T>::value,
+    "Incorrect type passed to function Configuration_ScreenLayoutLong_Name.");
+  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
+    Configuration_ScreenLayoutLong_descriptor(), enum_t_value);
+}
+inline bool Configuration_ScreenLayoutLong_Parse(
+    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_ScreenLayoutLong* value) {
+  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_ScreenLayoutLong>(
+    Configuration_ScreenLayoutLong_descriptor(), name, value);
+}
+enum Configuration_ScreenRound : int {
+  Configuration_ScreenRound_SCREEN_ROUND_UNSET = 0,
+  Configuration_ScreenRound_SCREEN_ROUND_ROUND = 1,
+  Configuration_ScreenRound_SCREEN_ROUND_NOTROUND = 2,
+  Configuration_ScreenRound_Configuration_ScreenRound_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
+  Configuration_ScreenRound_Configuration_ScreenRound_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
+};
+bool Configuration_ScreenRound_IsValid(int value);
+constexpr Configuration_ScreenRound Configuration_ScreenRound_ScreenRound_MIN = Configuration_ScreenRound_SCREEN_ROUND_UNSET;
+constexpr Configuration_ScreenRound Configuration_ScreenRound_ScreenRound_MAX = Configuration_ScreenRound_SCREEN_ROUND_NOTROUND;
+constexpr int Configuration_ScreenRound_ScreenRound_ARRAYSIZE = Configuration_ScreenRound_ScreenRound_MAX + 1;
+
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_ScreenRound_descriptor();
+template<typename T>
+inline const std::string& Configuration_ScreenRound_Name(T enum_t_value) {
+  static_assert(::std::is_same<T, Configuration_ScreenRound>::value ||
+    ::std::is_integral<T>::value,
+    "Incorrect type passed to function Configuration_ScreenRound_Name.");
+  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
+    Configuration_ScreenRound_descriptor(), enum_t_value);
+}
+inline bool Configuration_ScreenRound_Parse(
+    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_ScreenRound* value) {
+  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_ScreenRound>(
+    Configuration_ScreenRound_descriptor(), name, value);
+}
+enum Configuration_WideColorGamut : int {
+  Configuration_WideColorGamut_WIDE_COLOR_GAMUT_UNSET = 0,
+  Configuration_WideColorGamut_WIDE_COLOR_GAMUT_WIDECG = 1,
+  Configuration_WideColorGamut_WIDE_COLOR_GAMUT_NOWIDECG = 2,
+  Configuration_WideColorGamut_Configuration_WideColorGamut_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
+  Configuration_WideColorGamut_Configuration_WideColorGamut_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
+};
+bool Configuration_WideColorGamut_IsValid(int value);
+constexpr Configuration_WideColorGamut Configuration_WideColorGamut_WideColorGamut_MIN = Configuration_WideColorGamut_WIDE_COLOR_GAMUT_UNSET;
+constexpr Configuration_WideColorGamut Configuration_WideColorGamut_WideColorGamut_MAX = Configuration_WideColorGamut_WIDE_COLOR_GAMUT_NOWIDECG;
+constexpr int Configuration_WideColorGamut_WideColorGamut_ARRAYSIZE = Configuration_WideColorGamut_WideColorGamut_MAX + 1;
+
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_WideColorGamut_descriptor();
+template<typename T>
+inline const std::string& Configuration_WideColorGamut_Name(T enum_t_value) {
+  static_assert(::std::is_same<T, Configuration_WideColorGamut>::value ||
+    ::std::is_integral<T>::value,
+    "Incorrect type passed to function Configuration_WideColorGamut_Name.");
+  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
+    Configuration_WideColorGamut_descriptor(), enum_t_value);
+}
+inline bool Configuration_WideColorGamut_Parse(
+    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_WideColorGamut* value) {
+  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_WideColorGamut>(
+    Configuration_WideColorGamut_descriptor(), name, value);
+}
+enum Configuration_Hdr : int {
+  Configuration_Hdr_HDR_UNSET = 0,
+  Configuration_Hdr_HDR_HIGHDR = 1,
+  Configuration_Hdr_HDR_LOWDR = 2,
+  Configuration_Hdr_Configuration_Hdr_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
+  Configuration_Hdr_Configuration_Hdr_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
+};
+bool Configuration_Hdr_IsValid(int value);
+constexpr Configuration_Hdr Configuration_Hdr_Hdr_MIN = Configuration_Hdr_HDR_UNSET;
+constexpr Configuration_Hdr Configuration_Hdr_Hdr_MAX = Configuration_Hdr_HDR_LOWDR;
+constexpr int Configuration_Hdr_Hdr_ARRAYSIZE = Configuration_Hdr_Hdr_MAX + 1;
+
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_Hdr_descriptor();
+template<typename T>
+inline const std::string& Configuration_Hdr_Name(T enum_t_value) {
+  static_assert(::std::is_same<T, Configuration_Hdr>::value ||
+    ::std::is_integral<T>::value,
+    "Incorrect type passed to function Configuration_Hdr_Name.");
+  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
+    Configuration_Hdr_descriptor(), enum_t_value);
+}
+inline bool Configuration_Hdr_Parse(
+    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_Hdr* value) {
+  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_Hdr>(
+    Configuration_Hdr_descriptor(), name, value);
+}
+enum Configuration_Orientation : int {
+  Configuration_Orientation_ORIENTATION_UNSET = 0,
+  Configuration_Orientation_ORIENTATION_PORT = 1,
+  Configuration_Orientation_ORIENTATION_LAND = 2,
+  Configuration_Orientation_ORIENTATION_SQUARE = 3,
+  Configuration_Orientation_Configuration_Orientation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
+  Configuration_Orientation_Configuration_Orientation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
+};
+bool Configuration_Orientation_IsValid(int value);
+constexpr Configuration_Orientation Configuration_Orientation_Orientation_MIN = Configuration_Orientation_ORIENTATION_UNSET;
+constexpr Configuration_Orientation Configuration_Orientation_Orientation_MAX = Configuration_Orientation_ORIENTATION_SQUARE;
+constexpr int Configuration_Orientation_Orientation_ARRAYSIZE = Configuration_Orientation_Orientation_MAX + 1;
+
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_Orientation_descriptor();
+template<typename T>
+inline const std::string& Configuration_Orientation_Name(T enum_t_value) {
+  static_assert(::std::is_same<T, Configuration_Orientation>::value ||
+    ::std::is_integral<T>::value,
+    "Incorrect type passed to function Configuration_Orientation_Name.");
+  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
+    Configuration_Orientation_descriptor(), enum_t_value);
+}
+inline bool Configuration_Orientation_Parse(
+    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_Orientation* value) {
+  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_Orientation>(
+    Configuration_Orientation_descriptor(), name, value);
+}
+enum Configuration_UiModeType : int {
+  Configuration_UiModeType_UI_MODE_TYPE_UNSET = 0,
+  Configuration_UiModeType_UI_MODE_TYPE_NORMAL = 1,
+  Configuration_UiModeType_UI_MODE_TYPE_DESK = 2,
+  Configuration_UiModeType_UI_MODE_TYPE_CAR = 3,
+  Configuration_UiModeType_UI_MODE_TYPE_TELEVISION = 4,
+  Configuration_UiModeType_UI_MODE_TYPE_APPLIANCE = 5,
+  Configuration_UiModeType_UI_MODE_TYPE_WATCH = 6,
+  Configuration_UiModeType_UI_MODE_TYPE_VRHEADSET = 7,
+  Configuration_UiModeType_Configuration_UiModeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
+  Configuration_UiModeType_Configuration_UiModeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
+};
+bool Configuration_UiModeType_IsValid(int value);
+constexpr Configuration_UiModeType Configuration_UiModeType_UiModeType_MIN = Configuration_UiModeType_UI_MODE_TYPE_UNSET;
+constexpr Configuration_UiModeType Configuration_UiModeType_UiModeType_MAX = Configuration_UiModeType_UI_MODE_TYPE_VRHEADSET;
+constexpr int Configuration_UiModeType_UiModeType_ARRAYSIZE = Configuration_UiModeType_UiModeType_MAX + 1;
+
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_UiModeType_descriptor();
+template<typename T>
+inline const std::string& Configuration_UiModeType_Name(T enum_t_value) {
+  static_assert(::std::is_same<T, Configuration_UiModeType>::value ||
+    ::std::is_integral<T>::value,
+    "Incorrect type passed to function Configuration_UiModeType_Name.");
+  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
+    Configuration_UiModeType_descriptor(), enum_t_value);
+}
+inline bool Configuration_UiModeType_Parse(
+    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_UiModeType* value) {
+  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_UiModeType>(
+    Configuration_UiModeType_descriptor(), name, value);
+}
+enum Configuration_UiModeNight : int {
+  Configuration_UiModeNight_UI_MODE_NIGHT_UNSET = 0,
+  Configuration_UiModeNight_UI_MODE_NIGHT_NIGHT = 1,
+  Configuration_UiModeNight_UI_MODE_NIGHT_NOTNIGHT = 2,
+  Configuration_UiModeNight_Configuration_UiModeNight_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
+  Configuration_UiModeNight_Configuration_UiModeNight_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
+};
+bool Configuration_UiModeNight_IsValid(int value);
+constexpr Configuration_UiModeNight Configuration_UiModeNight_UiModeNight_MIN = Configuration_UiModeNight_UI_MODE_NIGHT_UNSET;
+constexpr Configuration_UiModeNight Configuration_UiModeNight_UiModeNight_MAX = Configuration_UiModeNight_UI_MODE_NIGHT_NOTNIGHT;
+constexpr int Configuration_UiModeNight_UiModeNight_ARRAYSIZE = Configuration_UiModeNight_UiModeNight_MAX + 1;
+
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_UiModeNight_descriptor();
+template<typename T>
+inline const std::string& Configuration_UiModeNight_Name(T enum_t_value) {
+  static_assert(::std::is_same<T, Configuration_UiModeNight>::value ||
+    ::std::is_integral<T>::value,
+    "Incorrect type passed to function Configuration_UiModeNight_Name.");
+  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
+    Configuration_UiModeNight_descriptor(), enum_t_value);
+}
+inline bool Configuration_UiModeNight_Parse(
+    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_UiModeNight* value) {
+  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_UiModeNight>(
+    Configuration_UiModeNight_descriptor(), name, value);
+}
+enum Configuration_Touchscreen : int {
+  Configuration_Touchscreen_TOUCHSCREEN_UNSET = 0,
+  Configuration_Touchscreen_TOUCHSCREEN_NOTOUCH = 1,
+  Configuration_Touchscreen_TOUCHSCREEN_STYLUS = 2,
+  Configuration_Touchscreen_TOUCHSCREEN_FINGER = 3,
+  Configuration_Touchscreen_Configuration_Touchscreen_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
+  Configuration_Touchscreen_Configuration_Touchscreen_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
+};
+bool Configuration_Touchscreen_IsValid(int value);
+constexpr Configuration_Touchscreen Configuration_Touchscreen_Touchscreen_MIN = Configuration_Touchscreen_TOUCHSCREEN_UNSET;
+constexpr Configuration_Touchscreen Configuration_Touchscreen_Touchscreen_MAX = Configuration_Touchscreen_TOUCHSCREEN_FINGER;
+constexpr int Configuration_Touchscreen_Touchscreen_ARRAYSIZE = Configuration_Touchscreen_Touchscreen_MAX + 1;
+
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_Touchscreen_descriptor();
+template<typename T>
+inline const std::string& Configuration_Touchscreen_Name(T enum_t_value) {
+  static_assert(::std::is_same<T, Configuration_Touchscreen>::value ||
+    ::std::is_integral<T>::value,
+    "Incorrect type passed to function Configuration_Touchscreen_Name.");
+  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
+    Configuration_Touchscreen_descriptor(), enum_t_value);
+}
+inline bool Configuration_Touchscreen_Parse(
+    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_Touchscreen* value) {
+  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_Touchscreen>(
+    Configuration_Touchscreen_descriptor(), name, value);
+}
+enum Configuration_KeysHidden : int {
+  Configuration_KeysHidden_KEYS_HIDDEN_UNSET = 0,
+  Configuration_KeysHidden_KEYS_HIDDEN_KEYSEXPOSED = 1,
+  Configuration_KeysHidden_KEYS_HIDDEN_KEYSHIDDEN = 2,
+  Configuration_KeysHidden_KEYS_HIDDEN_KEYSSOFT = 3,
+  Configuration_KeysHidden_Configuration_KeysHidden_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
+  Configuration_KeysHidden_Configuration_KeysHidden_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
+};
+bool Configuration_KeysHidden_IsValid(int value);
+constexpr Configuration_KeysHidden Configuration_KeysHidden_KeysHidden_MIN = Configuration_KeysHidden_KEYS_HIDDEN_UNSET;
+constexpr Configuration_KeysHidden Configuration_KeysHidden_KeysHidden_MAX = Configuration_KeysHidden_KEYS_HIDDEN_KEYSSOFT;
+constexpr int Configuration_KeysHidden_KeysHidden_ARRAYSIZE = Configuration_KeysHidden_KeysHidden_MAX + 1;
+
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_KeysHidden_descriptor();
+template<typename T>
+inline const std::string& Configuration_KeysHidden_Name(T enum_t_value) {
+  static_assert(::std::is_same<T, Configuration_KeysHidden>::value ||
+    ::std::is_integral<T>::value,
+    "Incorrect type passed to function Configuration_KeysHidden_Name.");
+  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
+    Configuration_KeysHidden_descriptor(), enum_t_value);
+}
+inline bool Configuration_KeysHidden_Parse(
+    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_KeysHidden* value) {
+  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_KeysHidden>(
+    Configuration_KeysHidden_descriptor(), name, value);
+}
+enum Configuration_Keyboard : int {
+  Configuration_Keyboard_KEYBOARD_UNSET = 0,
+  Configuration_Keyboard_KEYBOARD_NOKEYS = 1,
+  Configuration_Keyboard_KEYBOARD_QWERTY = 2,
+  Configuration_Keyboard_KEYBOARD_TWELVEKEY = 3,
+  Configuration_Keyboard_Configuration_Keyboard_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
+  Configuration_Keyboard_Configuration_Keyboard_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
+};
+bool Configuration_Keyboard_IsValid(int value);
+constexpr Configuration_Keyboard Configuration_Keyboard_Keyboard_MIN = Configuration_Keyboard_KEYBOARD_UNSET;
+constexpr Configuration_Keyboard Configuration_Keyboard_Keyboard_MAX = Configuration_Keyboard_KEYBOARD_TWELVEKEY;
+constexpr int Configuration_Keyboard_Keyboard_ARRAYSIZE = Configuration_Keyboard_Keyboard_MAX + 1;
+
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_Keyboard_descriptor();
+template<typename T>
+inline const std::string& Configuration_Keyboard_Name(T enum_t_value) {
+  static_assert(::std::is_same<T, Configuration_Keyboard>::value ||
+    ::std::is_integral<T>::value,
+    "Incorrect type passed to function Configuration_Keyboard_Name.");
+  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
+    Configuration_Keyboard_descriptor(), enum_t_value);
+}
+inline bool Configuration_Keyboard_Parse(
+    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_Keyboard* value) {
+  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_Keyboard>(
+    Configuration_Keyboard_descriptor(), name, value);
+}
+enum Configuration_NavHidden : int {
+  Configuration_NavHidden_NAV_HIDDEN_UNSET = 0,
+  Configuration_NavHidden_NAV_HIDDEN_NAVEXPOSED = 1,
+  Configuration_NavHidden_NAV_HIDDEN_NAVHIDDEN = 2,
+  Configuration_NavHidden_Configuration_NavHidden_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
+  Configuration_NavHidden_Configuration_NavHidden_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
+};
+bool Configuration_NavHidden_IsValid(int value);
+constexpr Configuration_NavHidden Configuration_NavHidden_NavHidden_MIN = Configuration_NavHidden_NAV_HIDDEN_UNSET;
+constexpr Configuration_NavHidden Configuration_NavHidden_NavHidden_MAX = Configuration_NavHidden_NAV_HIDDEN_NAVHIDDEN;
+constexpr int Configuration_NavHidden_NavHidden_ARRAYSIZE = Configuration_NavHidden_NavHidden_MAX + 1;
+
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_NavHidden_descriptor();
+template<typename T>
+inline const std::string& Configuration_NavHidden_Name(T enum_t_value) {
+  static_assert(::std::is_same<T, Configuration_NavHidden>::value ||
+    ::std::is_integral<T>::value,
+    "Incorrect type passed to function Configuration_NavHidden_Name.");
+  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
+    Configuration_NavHidden_descriptor(), enum_t_value);
+}
+inline bool Configuration_NavHidden_Parse(
+    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_NavHidden* value) {
+  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_NavHidden>(
+    Configuration_NavHidden_descriptor(), name, value);
+}
+enum Configuration_Navigation : int {
+  Configuration_Navigation_NAVIGATION_UNSET = 0,
+  Configuration_Navigation_NAVIGATION_NONAV = 1,
+  Configuration_Navigation_NAVIGATION_DPAD = 2,
+  Configuration_Navigation_NAVIGATION_TRACKBALL = 3,
+  Configuration_Navigation_NAVIGATION_WHEEL = 4,
+  Configuration_Navigation_Configuration_Navigation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
+  Configuration_Navigation_Configuration_Navigation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
+};
+bool Configuration_Navigation_IsValid(int value);
+constexpr Configuration_Navigation Configuration_Navigation_Navigation_MIN = Configuration_Navigation_NAVIGATION_UNSET;
+constexpr Configuration_Navigation Configuration_Navigation_Navigation_MAX = Configuration_Navigation_NAVIGATION_WHEEL;
+constexpr int Configuration_Navigation_Navigation_ARRAYSIZE = Configuration_Navigation_Navigation_MAX + 1;
+
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Configuration_Navigation_descriptor();
+template<typename T>
+inline const std::string& Configuration_Navigation_Name(T enum_t_value) {
+  static_assert(::std::is_same<T, Configuration_Navigation>::value ||
+    ::std::is_integral<T>::value,
+    "Incorrect type passed to function Configuration_Navigation_Name.");
+  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
+    Configuration_Navigation_descriptor(), enum_t_value);
+}
+inline bool Configuration_Navigation_Parse(
+    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Configuration_Navigation* value) {
+  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Configuration_Navigation>(
+    Configuration_Navigation_descriptor(), name, value);
+}
+// ===================================================================
+
+class Configuration final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Configuration) */ {
+ public:
+  inline Configuration() : Configuration(nullptr) {}
+  ~Configuration() override;
+  explicit PROTOBUF_CONSTEXPR Configuration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Configuration(const Configuration& from);
+  Configuration(Configuration&& from) noexcept
+    : Configuration() {
+    *this = ::std::move(from);
+  }
+
+  inline Configuration& operator=(const Configuration& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Configuration& operator=(Configuration&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Configuration& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Configuration* internal_default_instance() {
+    return reinterpret_cast<const Configuration*>(
+               &_Configuration_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    0;
+
+  friend void swap(Configuration& a, Configuration& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Configuration* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Configuration* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Configuration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Configuration>(arena);
+  }
+  Configuration* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Configuration& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Configuration& from) {
+    Configuration::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Configuration* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Configuration";
+  }
+  protected:
+  explicit Configuration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  typedef Configuration_LayoutDirection LayoutDirection;
+  static constexpr LayoutDirection LAYOUT_DIRECTION_UNSET =
+    Configuration_LayoutDirection_LAYOUT_DIRECTION_UNSET;
+  static constexpr LayoutDirection LAYOUT_DIRECTION_LTR =
+    Configuration_LayoutDirection_LAYOUT_DIRECTION_LTR;
+  static constexpr LayoutDirection LAYOUT_DIRECTION_RTL =
+    Configuration_LayoutDirection_LAYOUT_DIRECTION_RTL;
+  static inline bool LayoutDirection_IsValid(int value) {
+    return Configuration_LayoutDirection_IsValid(value);
+  }
+  static constexpr LayoutDirection LayoutDirection_MIN =
+    Configuration_LayoutDirection_LayoutDirection_MIN;
+  static constexpr LayoutDirection LayoutDirection_MAX =
+    Configuration_LayoutDirection_LayoutDirection_MAX;
+  static constexpr int LayoutDirection_ARRAYSIZE =
+    Configuration_LayoutDirection_LayoutDirection_ARRAYSIZE;
+  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
+  LayoutDirection_descriptor() {
+    return Configuration_LayoutDirection_descriptor();
+  }
+  template<typename T>
+  static inline const std::string& LayoutDirection_Name(T enum_t_value) {
+    static_assert(::std::is_same<T, LayoutDirection>::value ||
+      ::std::is_integral<T>::value,
+      "Incorrect type passed to function LayoutDirection_Name.");
+    return Configuration_LayoutDirection_Name(enum_t_value);
+  }
+  static inline bool LayoutDirection_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
+      LayoutDirection* value) {
+    return Configuration_LayoutDirection_Parse(name, value);
+  }
+
+  typedef Configuration_ScreenLayoutSize ScreenLayoutSize;
+  static constexpr ScreenLayoutSize SCREEN_LAYOUT_SIZE_UNSET =
+    Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_UNSET;
+  static constexpr ScreenLayoutSize SCREEN_LAYOUT_SIZE_SMALL =
+    Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_SMALL;
+  static constexpr ScreenLayoutSize SCREEN_LAYOUT_SIZE_NORMAL =
+    Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_NORMAL;
+  static constexpr ScreenLayoutSize SCREEN_LAYOUT_SIZE_LARGE =
+    Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_LARGE;
+  static constexpr ScreenLayoutSize SCREEN_LAYOUT_SIZE_XLARGE =
+    Configuration_ScreenLayoutSize_SCREEN_LAYOUT_SIZE_XLARGE;
+  static inline bool ScreenLayoutSize_IsValid(int value) {
+    return Configuration_ScreenLayoutSize_IsValid(value);
+  }
+  static constexpr ScreenLayoutSize ScreenLayoutSize_MIN =
+    Configuration_ScreenLayoutSize_ScreenLayoutSize_MIN;
+  static constexpr ScreenLayoutSize ScreenLayoutSize_MAX =
+    Configuration_ScreenLayoutSize_ScreenLayoutSize_MAX;
+  static constexpr int ScreenLayoutSize_ARRAYSIZE =
+    Configuration_ScreenLayoutSize_ScreenLayoutSize_ARRAYSIZE;
+  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
+  ScreenLayoutSize_descriptor() {
+    return Configuration_ScreenLayoutSize_descriptor();
+  }
+  template<typename T>
+  static inline const std::string& ScreenLayoutSize_Name(T enum_t_value) {
+    static_assert(::std::is_same<T, ScreenLayoutSize>::value ||
+      ::std::is_integral<T>::value,
+      "Incorrect type passed to function ScreenLayoutSize_Name.");
+    return Configuration_ScreenLayoutSize_Name(enum_t_value);
+  }
+  static inline bool ScreenLayoutSize_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
+      ScreenLayoutSize* value) {
+    return Configuration_ScreenLayoutSize_Parse(name, value);
+  }
+
+  typedef Configuration_ScreenLayoutLong ScreenLayoutLong;
+  static constexpr ScreenLayoutLong SCREEN_LAYOUT_LONG_UNSET =
+    Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_UNSET;
+  static constexpr ScreenLayoutLong SCREEN_LAYOUT_LONG_LONG =
+    Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_LONG;
+  static constexpr ScreenLayoutLong SCREEN_LAYOUT_LONG_NOTLONG =
+    Configuration_ScreenLayoutLong_SCREEN_LAYOUT_LONG_NOTLONG;
+  static inline bool ScreenLayoutLong_IsValid(int value) {
+    return Configuration_ScreenLayoutLong_IsValid(value);
+  }
+  static constexpr ScreenLayoutLong ScreenLayoutLong_MIN =
+    Configuration_ScreenLayoutLong_ScreenLayoutLong_MIN;
+  static constexpr ScreenLayoutLong ScreenLayoutLong_MAX =
+    Configuration_ScreenLayoutLong_ScreenLayoutLong_MAX;
+  static constexpr int ScreenLayoutLong_ARRAYSIZE =
+    Configuration_ScreenLayoutLong_ScreenLayoutLong_ARRAYSIZE;
+  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
+  ScreenLayoutLong_descriptor() {
+    return Configuration_ScreenLayoutLong_descriptor();
+  }
+  template<typename T>
+  static inline const std::string& ScreenLayoutLong_Name(T enum_t_value) {
+    static_assert(::std::is_same<T, ScreenLayoutLong>::value ||
+      ::std::is_integral<T>::value,
+      "Incorrect type passed to function ScreenLayoutLong_Name.");
+    return Configuration_ScreenLayoutLong_Name(enum_t_value);
+  }
+  static inline bool ScreenLayoutLong_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
+      ScreenLayoutLong* value) {
+    return Configuration_ScreenLayoutLong_Parse(name, value);
+  }
+
+  typedef Configuration_ScreenRound ScreenRound;
+  static constexpr ScreenRound SCREEN_ROUND_UNSET =
+    Configuration_ScreenRound_SCREEN_ROUND_UNSET;
+  static constexpr ScreenRound SCREEN_ROUND_ROUND =
+    Configuration_ScreenRound_SCREEN_ROUND_ROUND;
+  static constexpr ScreenRound SCREEN_ROUND_NOTROUND =
+    Configuration_ScreenRound_SCREEN_ROUND_NOTROUND;
+  static inline bool ScreenRound_IsValid(int value) {
+    return Configuration_ScreenRound_IsValid(value);
+  }
+  static constexpr ScreenRound ScreenRound_MIN =
+    Configuration_ScreenRound_ScreenRound_MIN;
+  static constexpr ScreenRound ScreenRound_MAX =
+    Configuration_ScreenRound_ScreenRound_MAX;
+  static constexpr int ScreenRound_ARRAYSIZE =
+    Configuration_ScreenRound_ScreenRound_ARRAYSIZE;
+  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
+  ScreenRound_descriptor() {
+    return Configuration_ScreenRound_descriptor();
+  }
+  template<typename T>
+  static inline const std::string& ScreenRound_Name(T enum_t_value) {
+    static_assert(::std::is_same<T, ScreenRound>::value ||
+      ::std::is_integral<T>::value,
+      "Incorrect type passed to function ScreenRound_Name.");
+    return Configuration_ScreenRound_Name(enum_t_value);
+  }
+  static inline bool ScreenRound_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
+      ScreenRound* value) {
+    return Configuration_ScreenRound_Parse(name, value);
+  }
+
+  typedef Configuration_WideColorGamut WideColorGamut;
+  static constexpr WideColorGamut WIDE_COLOR_GAMUT_UNSET =
+    Configuration_WideColorGamut_WIDE_COLOR_GAMUT_UNSET;
+  static constexpr WideColorGamut WIDE_COLOR_GAMUT_WIDECG =
+    Configuration_WideColorGamut_WIDE_COLOR_GAMUT_WIDECG;
+  static constexpr WideColorGamut WIDE_COLOR_GAMUT_NOWIDECG =
+    Configuration_WideColorGamut_WIDE_COLOR_GAMUT_NOWIDECG;
+  static inline bool WideColorGamut_IsValid(int value) {
+    return Configuration_WideColorGamut_IsValid(value);
+  }
+  static constexpr WideColorGamut WideColorGamut_MIN =
+    Configuration_WideColorGamut_WideColorGamut_MIN;
+  static constexpr WideColorGamut WideColorGamut_MAX =
+    Configuration_WideColorGamut_WideColorGamut_MAX;
+  static constexpr int WideColorGamut_ARRAYSIZE =
+    Configuration_WideColorGamut_WideColorGamut_ARRAYSIZE;
+  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
+  WideColorGamut_descriptor() {
+    return Configuration_WideColorGamut_descriptor();
+  }
+  template<typename T>
+  static inline const std::string& WideColorGamut_Name(T enum_t_value) {
+    static_assert(::std::is_same<T, WideColorGamut>::value ||
+      ::std::is_integral<T>::value,
+      "Incorrect type passed to function WideColorGamut_Name.");
+    return Configuration_WideColorGamut_Name(enum_t_value);
+  }
+  static inline bool WideColorGamut_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
+      WideColorGamut* value) {
+    return Configuration_WideColorGamut_Parse(name, value);
+  }
+
+  typedef Configuration_Hdr Hdr;
+  static constexpr Hdr HDR_UNSET =
+    Configuration_Hdr_HDR_UNSET;
+  static constexpr Hdr HDR_HIGHDR =
+    Configuration_Hdr_HDR_HIGHDR;
+  static constexpr Hdr HDR_LOWDR =
+    Configuration_Hdr_HDR_LOWDR;
+  static inline bool Hdr_IsValid(int value) {
+    return Configuration_Hdr_IsValid(value);
+  }
+  static constexpr Hdr Hdr_MIN =
+    Configuration_Hdr_Hdr_MIN;
+  static constexpr Hdr Hdr_MAX =
+    Configuration_Hdr_Hdr_MAX;
+  static constexpr int Hdr_ARRAYSIZE =
+    Configuration_Hdr_Hdr_ARRAYSIZE;
+  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
+  Hdr_descriptor() {
+    return Configuration_Hdr_descriptor();
+  }
+  template<typename T>
+  static inline const std::string& Hdr_Name(T enum_t_value) {
+    static_assert(::std::is_same<T, Hdr>::value ||
+      ::std::is_integral<T>::value,
+      "Incorrect type passed to function Hdr_Name.");
+    return Configuration_Hdr_Name(enum_t_value);
+  }
+  static inline bool Hdr_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
+      Hdr* value) {
+    return Configuration_Hdr_Parse(name, value);
+  }
+
+  typedef Configuration_Orientation Orientation;
+  static constexpr Orientation ORIENTATION_UNSET =
+    Configuration_Orientation_ORIENTATION_UNSET;
+  static constexpr Orientation ORIENTATION_PORT =
+    Configuration_Orientation_ORIENTATION_PORT;
+  static constexpr Orientation ORIENTATION_LAND =
+    Configuration_Orientation_ORIENTATION_LAND;
+  static constexpr Orientation ORIENTATION_SQUARE =
+    Configuration_Orientation_ORIENTATION_SQUARE;
+  static inline bool Orientation_IsValid(int value) {
+    return Configuration_Orientation_IsValid(value);
+  }
+  static constexpr Orientation Orientation_MIN =
+    Configuration_Orientation_Orientation_MIN;
+  static constexpr Orientation Orientation_MAX =
+    Configuration_Orientation_Orientation_MAX;
+  static constexpr int Orientation_ARRAYSIZE =
+    Configuration_Orientation_Orientation_ARRAYSIZE;
+  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
+  Orientation_descriptor() {
+    return Configuration_Orientation_descriptor();
+  }
+  template<typename T>
+  static inline const std::string& Orientation_Name(T enum_t_value) {
+    static_assert(::std::is_same<T, Orientation>::value ||
+      ::std::is_integral<T>::value,
+      "Incorrect type passed to function Orientation_Name.");
+    return Configuration_Orientation_Name(enum_t_value);
+  }
+  static inline bool Orientation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
+      Orientation* value) {
+    return Configuration_Orientation_Parse(name, value);
+  }
+
+  typedef Configuration_UiModeType UiModeType;
+  static constexpr UiModeType UI_MODE_TYPE_UNSET =
+    Configuration_UiModeType_UI_MODE_TYPE_UNSET;
+  static constexpr UiModeType UI_MODE_TYPE_NORMAL =
+    Configuration_UiModeType_UI_MODE_TYPE_NORMAL;
+  static constexpr UiModeType UI_MODE_TYPE_DESK =
+    Configuration_UiModeType_UI_MODE_TYPE_DESK;
+  static constexpr UiModeType UI_MODE_TYPE_CAR =
+    Configuration_UiModeType_UI_MODE_TYPE_CAR;
+  static constexpr UiModeType UI_MODE_TYPE_TELEVISION =
+    Configuration_UiModeType_UI_MODE_TYPE_TELEVISION;
+  static constexpr UiModeType UI_MODE_TYPE_APPLIANCE =
+    Configuration_UiModeType_UI_MODE_TYPE_APPLIANCE;
+  static constexpr UiModeType UI_MODE_TYPE_WATCH =
+    Configuration_UiModeType_UI_MODE_TYPE_WATCH;
+  static constexpr UiModeType UI_MODE_TYPE_VRHEADSET =
+    Configuration_UiModeType_UI_MODE_TYPE_VRHEADSET;
+  static inline bool UiModeType_IsValid(int value) {
+    return Configuration_UiModeType_IsValid(value);
+  }
+  static constexpr UiModeType UiModeType_MIN =
+    Configuration_UiModeType_UiModeType_MIN;
+  static constexpr UiModeType UiModeType_MAX =
+    Configuration_UiModeType_UiModeType_MAX;
+  static constexpr int UiModeType_ARRAYSIZE =
+    Configuration_UiModeType_UiModeType_ARRAYSIZE;
+  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
+  UiModeType_descriptor() {
+    return Configuration_UiModeType_descriptor();
+  }
+  template<typename T>
+  static inline const std::string& UiModeType_Name(T enum_t_value) {
+    static_assert(::std::is_same<T, UiModeType>::value ||
+      ::std::is_integral<T>::value,
+      "Incorrect type passed to function UiModeType_Name.");
+    return Configuration_UiModeType_Name(enum_t_value);
+  }
+  static inline bool UiModeType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
+      UiModeType* value) {
+    return Configuration_UiModeType_Parse(name, value);
+  }
+
+  typedef Configuration_UiModeNight UiModeNight;
+  static constexpr UiModeNight UI_MODE_NIGHT_UNSET =
+    Configuration_UiModeNight_UI_MODE_NIGHT_UNSET;
+  static constexpr UiModeNight UI_MODE_NIGHT_NIGHT =
+    Configuration_UiModeNight_UI_MODE_NIGHT_NIGHT;
+  static constexpr UiModeNight UI_MODE_NIGHT_NOTNIGHT =
+    Configuration_UiModeNight_UI_MODE_NIGHT_NOTNIGHT;
+  static inline bool UiModeNight_IsValid(int value) {
+    return Configuration_UiModeNight_IsValid(value);
+  }
+  static constexpr UiModeNight UiModeNight_MIN =
+    Configuration_UiModeNight_UiModeNight_MIN;
+  static constexpr UiModeNight UiModeNight_MAX =
+    Configuration_UiModeNight_UiModeNight_MAX;
+  static constexpr int UiModeNight_ARRAYSIZE =
+    Configuration_UiModeNight_UiModeNight_ARRAYSIZE;
+  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
+  UiModeNight_descriptor() {
+    return Configuration_UiModeNight_descriptor();
+  }
+  template<typename T>
+  static inline const std::string& UiModeNight_Name(T enum_t_value) {
+    static_assert(::std::is_same<T, UiModeNight>::value ||
+      ::std::is_integral<T>::value,
+      "Incorrect type passed to function UiModeNight_Name.");
+    return Configuration_UiModeNight_Name(enum_t_value);
+  }
+  static inline bool UiModeNight_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
+      UiModeNight* value) {
+    return Configuration_UiModeNight_Parse(name, value);
+  }
+
+  typedef Configuration_Touchscreen Touchscreen;
+  static constexpr Touchscreen TOUCHSCREEN_UNSET =
+    Configuration_Touchscreen_TOUCHSCREEN_UNSET;
+  static constexpr Touchscreen TOUCHSCREEN_NOTOUCH =
+    Configuration_Touchscreen_TOUCHSCREEN_NOTOUCH;
+  static constexpr Touchscreen TOUCHSCREEN_STYLUS =
+    Configuration_Touchscreen_TOUCHSCREEN_STYLUS;
+  static constexpr Touchscreen TOUCHSCREEN_FINGER =
+    Configuration_Touchscreen_TOUCHSCREEN_FINGER;
+  static inline bool Touchscreen_IsValid(int value) {
+    return Configuration_Touchscreen_IsValid(value);
+  }
+  static constexpr Touchscreen Touchscreen_MIN =
+    Configuration_Touchscreen_Touchscreen_MIN;
+  static constexpr Touchscreen Touchscreen_MAX =
+    Configuration_Touchscreen_Touchscreen_MAX;
+  static constexpr int Touchscreen_ARRAYSIZE =
+    Configuration_Touchscreen_Touchscreen_ARRAYSIZE;
+  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
+  Touchscreen_descriptor() {
+    return Configuration_Touchscreen_descriptor();
+  }
+  template<typename T>
+  static inline const std::string& Touchscreen_Name(T enum_t_value) {
+    static_assert(::std::is_same<T, Touchscreen>::value ||
+      ::std::is_integral<T>::value,
+      "Incorrect type passed to function Touchscreen_Name.");
+    return Configuration_Touchscreen_Name(enum_t_value);
+  }
+  static inline bool Touchscreen_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
+      Touchscreen* value) {
+    return Configuration_Touchscreen_Parse(name, value);
+  }
+
+  typedef Configuration_KeysHidden KeysHidden;
+  static constexpr KeysHidden KEYS_HIDDEN_UNSET =
+    Configuration_KeysHidden_KEYS_HIDDEN_UNSET;
+  static constexpr KeysHidden KEYS_HIDDEN_KEYSEXPOSED =
+    Configuration_KeysHidden_KEYS_HIDDEN_KEYSEXPOSED;
+  static constexpr KeysHidden KEYS_HIDDEN_KEYSHIDDEN =
+    Configuration_KeysHidden_KEYS_HIDDEN_KEYSHIDDEN;
+  static constexpr KeysHidden KEYS_HIDDEN_KEYSSOFT =
+    Configuration_KeysHidden_KEYS_HIDDEN_KEYSSOFT;
+  static inline bool KeysHidden_IsValid(int value) {
+    return Configuration_KeysHidden_IsValid(value);
+  }
+  static constexpr KeysHidden KeysHidden_MIN =
+    Configuration_KeysHidden_KeysHidden_MIN;
+  static constexpr KeysHidden KeysHidden_MAX =
+    Configuration_KeysHidden_KeysHidden_MAX;
+  static constexpr int KeysHidden_ARRAYSIZE =
+    Configuration_KeysHidden_KeysHidden_ARRAYSIZE;
+  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
+  KeysHidden_descriptor() {
+    return Configuration_KeysHidden_descriptor();
+  }
+  template<typename T>
+  static inline const std::string& KeysHidden_Name(T enum_t_value) {
+    static_assert(::std::is_same<T, KeysHidden>::value ||
+      ::std::is_integral<T>::value,
+      "Incorrect type passed to function KeysHidden_Name.");
+    return Configuration_KeysHidden_Name(enum_t_value);
+  }
+  static inline bool KeysHidden_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
+      KeysHidden* value) {
+    return Configuration_KeysHidden_Parse(name, value);
+  }
+
+  typedef Configuration_Keyboard Keyboard;
+  static constexpr Keyboard KEYBOARD_UNSET =
+    Configuration_Keyboard_KEYBOARD_UNSET;
+  static constexpr Keyboard KEYBOARD_NOKEYS =
+    Configuration_Keyboard_KEYBOARD_NOKEYS;
+  static constexpr Keyboard KEYBOARD_QWERTY =
+    Configuration_Keyboard_KEYBOARD_QWERTY;
+  static constexpr Keyboard KEYBOARD_TWELVEKEY =
+    Configuration_Keyboard_KEYBOARD_TWELVEKEY;
+  static inline bool Keyboard_IsValid(int value) {
+    return Configuration_Keyboard_IsValid(value);
+  }
+  static constexpr Keyboard Keyboard_MIN =
+    Configuration_Keyboard_Keyboard_MIN;
+  static constexpr Keyboard Keyboard_MAX =
+    Configuration_Keyboard_Keyboard_MAX;
+  static constexpr int Keyboard_ARRAYSIZE =
+    Configuration_Keyboard_Keyboard_ARRAYSIZE;
+  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
+  Keyboard_descriptor() {
+    return Configuration_Keyboard_descriptor();
+  }
+  template<typename T>
+  static inline const std::string& Keyboard_Name(T enum_t_value) {
+    static_assert(::std::is_same<T, Keyboard>::value ||
+      ::std::is_integral<T>::value,
+      "Incorrect type passed to function Keyboard_Name.");
+    return Configuration_Keyboard_Name(enum_t_value);
+  }
+  static inline bool Keyboard_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
+      Keyboard* value) {
+    return Configuration_Keyboard_Parse(name, value);
+  }
+
+  typedef Configuration_NavHidden NavHidden;
+  static constexpr NavHidden NAV_HIDDEN_UNSET =
+    Configuration_NavHidden_NAV_HIDDEN_UNSET;
+  static constexpr NavHidden NAV_HIDDEN_NAVEXPOSED =
+    Configuration_NavHidden_NAV_HIDDEN_NAVEXPOSED;
+  static constexpr NavHidden NAV_HIDDEN_NAVHIDDEN =
+    Configuration_NavHidden_NAV_HIDDEN_NAVHIDDEN;
+  static inline bool NavHidden_IsValid(int value) {
+    return Configuration_NavHidden_IsValid(value);
+  }
+  static constexpr NavHidden NavHidden_MIN =
+    Configuration_NavHidden_NavHidden_MIN;
+  static constexpr NavHidden NavHidden_MAX =
+    Configuration_NavHidden_NavHidden_MAX;
+  static constexpr int NavHidden_ARRAYSIZE =
+    Configuration_NavHidden_NavHidden_ARRAYSIZE;
+  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
+  NavHidden_descriptor() {
+    return Configuration_NavHidden_descriptor();
+  }
+  template<typename T>
+  static inline const std::string& NavHidden_Name(T enum_t_value) {
+    static_assert(::std::is_same<T, NavHidden>::value ||
+      ::std::is_integral<T>::value,
+      "Incorrect type passed to function NavHidden_Name.");
+    return Configuration_NavHidden_Name(enum_t_value);
+  }
+  static inline bool NavHidden_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
+      NavHidden* value) {
+    return Configuration_NavHidden_Parse(name, value);
+  }
+
+  typedef Configuration_Navigation Navigation;
+  static constexpr Navigation NAVIGATION_UNSET =
+    Configuration_Navigation_NAVIGATION_UNSET;
+  static constexpr Navigation NAVIGATION_NONAV =
+    Configuration_Navigation_NAVIGATION_NONAV;
+  static constexpr Navigation NAVIGATION_DPAD =
+    Configuration_Navigation_NAVIGATION_DPAD;
+  static constexpr Navigation NAVIGATION_TRACKBALL =
+    Configuration_Navigation_NAVIGATION_TRACKBALL;
+  static constexpr Navigation NAVIGATION_WHEEL =
+    Configuration_Navigation_NAVIGATION_WHEEL;
+  static inline bool Navigation_IsValid(int value) {
+    return Configuration_Navigation_IsValid(value);
+  }
+  static constexpr Navigation Navigation_MIN =
+    Configuration_Navigation_Navigation_MIN;
+  static constexpr Navigation Navigation_MAX =
+    Configuration_Navigation_Navigation_MAX;
+  static constexpr int Navigation_ARRAYSIZE =
+    Configuration_Navigation_Navigation_ARRAYSIZE;
+  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
+  Navigation_descriptor() {
+    return Configuration_Navigation_descriptor();
+  }
+  template<typename T>
+  static inline const std::string& Navigation_Name(T enum_t_value) {
+    static_assert(::std::is_same<T, Navigation>::value ||
+      ::std::is_integral<T>::value,
+      "Incorrect type passed to function Navigation_Name.");
+    return Configuration_Navigation_Name(enum_t_value);
+  }
+  static inline bool Navigation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
+      Navigation* value) {
+    return Configuration_Navigation_Parse(name, value);
+  }
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kLocaleFieldNumber = 3,
+    kProductFieldNumber = 25,
+    kMccFieldNumber = 1,
+    kMncFieldNumber = 2,
+    kLayoutDirectionFieldNumber = 4,
+    kScreenWidthFieldNumber = 5,
+    kScreenHeightFieldNumber = 6,
+    kScreenWidthDpFieldNumber = 7,
+    kScreenHeightDpFieldNumber = 8,
+    kSmallestScreenWidthDpFieldNumber = 9,
+    kScreenLayoutSizeFieldNumber = 10,
+    kScreenLayoutLongFieldNumber = 11,
+    kScreenRoundFieldNumber = 12,
+    kWideColorGamutFieldNumber = 13,
+    kHdrFieldNumber = 14,
+    kOrientationFieldNumber = 15,
+    kUiModeTypeFieldNumber = 16,
+    kUiModeNightFieldNumber = 17,
+    kDensityFieldNumber = 18,
+    kTouchscreenFieldNumber = 19,
+    kKeysHiddenFieldNumber = 20,
+    kKeyboardFieldNumber = 21,
+    kNavHiddenFieldNumber = 22,
+    kNavigationFieldNumber = 23,
+    kSdkVersionFieldNumber = 24,
+  };
+  // string locale = 3;
+  void clear_locale();
+  const std::string& locale() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_locale(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_locale();
+  PROTOBUF_NODISCARD std::string* release_locale();
+  void set_allocated_locale(std::string* locale);
+  private:
+  const std::string& _internal_locale() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale(const std::string& value);
+  std::string* _internal_mutable_locale();
+  public:
+
+  // string product = 25;
+  void clear_product();
+  const std::string& product() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_product(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_product();
+  PROTOBUF_NODISCARD std::string* release_product();
+  void set_allocated_product(std::string* product);
+  private:
+  const std::string& _internal_product() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product(const std::string& value);
+  std::string* _internal_mutable_product();
+  public:
+
+  // uint32 mcc = 1;
+  void clear_mcc();
+  ::uint32_t mcc() const;
+  void set_mcc(::uint32_t value);
+  private:
+  ::uint32_t _internal_mcc() const;
+  void _internal_set_mcc(::uint32_t value);
+  public:
+
+  // uint32 mnc = 2;
+  void clear_mnc();
+  ::uint32_t mnc() const;
+  void set_mnc(::uint32_t value);
+  private:
+  ::uint32_t _internal_mnc() const;
+  void _internal_set_mnc(::uint32_t value);
+  public:
+
+  // .aapt.pb.Configuration.LayoutDirection layout_direction = 4;
+  void clear_layout_direction();
+  ::aapt::pb::Configuration_LayoutDirection layout_direction() const;
+  void set_layout_direction(::aapt::pb::Configuration_LayoutDirection value);
+  private:
+  ::aapt::pb::Configuration_LayoutDirection _internal_layout_direction() const;
+  void _internal_set_layout_direction(::aapt::pb::Configuration_LayoutDirection value);
+  public:
+
+  // uint32 screen_width = 5;
+  void clear_screen_width();
+  ::uint32_t screen_width() const;
+  void set_screen_width(::uint32_t value);
+  private:
+  ::uint32_t _internal_screen_width() const;
+  void _internal_set_screen_width(::uint32_t value);
+  public:
+
+  // uint32 screen_height = 6;
+  void clear_screen_height();
+  ::uint32_t screen_height() const;
+  void set_screen_height(::uint32_t value);
+  private:
+  ::uint32_t _internal_screen_height() const;
+  void _internal_set_screen_height(::uint32_t value);
+  public:
+
+  // uint32 screen_width_dp = 7;
+  void clear_screen_width_dp();
+  ::uint32_t screen_width_dp() const;
+  void set_screen_width_dp(::uint32_t value);
+  private:
+  ::uint32_t _internal_screen_width_dp() const;
+  void _internal_set_screen_width_dp(::uint32_t value);
+  public:
+
+  // uint32 screen_height_dp = 8;
+  void clear_screen_height_dp();
+  ::uint32_t screen_height_dp() const;
+  void set_screen_height_dp(::uint32_t value);
+  private:
+  ::uint32_t _internal_screen_height_dp() const;
+  void _internal_set_screen_height_dp(::uint32_t value);
+  public:
+
+  // uint32 smallest_screen_width_dp = 9;
+  void clear_smallest_screen_width_dp();
+  ::uint32_t smallest_screen_width_dp() const;
+  void set_smallest_screen_width_dp(::uint32_t value);
+  private:
+  ::uint32_t _internal_smallest_screen_width_dp() const;
+  void _internal_set_smallest_screen_width_dp(::uint32_t value);
+  public:
+
+  // .aapt.pb.Configuration.ScreenLayoutSize screen_layout_size = 10;
+  void clear_screen_layout_size();
+  ::aapt::pb::Configuration_ScreenLayoutSize screen_layout_size() const;
+  void set_screen_layout_size(::aapt::pb::Configuration_ScreenLayoutSize value);
+  private:
+  ::aapt::pb::Configuration_ScreenLayoutSize _internal_screen_layout_size() const;
+  void _internal_set_screen_layout_size(::aapt::pb::Configuration_ScreenLayoutSize value);
+  public:
+
+  // .aapt.pb.Configuration.ScreenLayoutLong screen_layout_long = 11;
+  void clear_screen_layout_long();
+  ::aapt::pb::Configuration_ScreenLayoutLong screen_layout_long() const;
+  void set_screen_layout_long(::aapt::pb::Configuration_ScreenLayoutLong value);
+  private:
+  ::aapt::pb::Configuration_ScreenLayoutLong _internal_screen_layout_long() const;
+  void _internal_set_screen_layout_long(::aapt::pb::Configuration_ScreenLayoutLong value);
+  public:
+
+  // .aapt.pb.Configuration.ScreenRound screen_round = 12;
+  void clear_screen_round();
+  ::aapt::pb::Configuration_ScreenRound screen_round() const;
+  void set_screen_round(::aapt::pb::Configuration_ScreenRound value);
+  private:
+  ::aapt::pb::Configuration_ScreenRound _internal_screen_round() const;
+  void _internal_set_screen_round(::aapt::pb::Configuration_ScreenRound value);
+  public:
+
+  // .aapt.pb.Configuration.WideColorGamut wide_color_gamut = 13;
+  void clear_wide_color_gamut();
+  ::aapt::pb::Configuration_WideColorGamut wide_color_gamut() const;
+  void set_wide_color_gamut(::aapt::pb::Configuration_WideColorGamut value);
+  private:
+  ::aapt::pb::Configuration_WideColorGamut _internal_wide_color_gamut() const;
+  void _internal_set_wide_color_gamut(::aapt::pb::Configuration_WideColorGamut value);
+  public:
+
+  // .aapt.pb.Configuration.Hdr hdr = 14;
+  void clear_hdr();
+  ::aapt::pb::Configuration_Hdr hdr() const;
+  void set_hdr(::aapt::pb::Configuration_Hdr value);
+  private:
+  ::aapt::pb::Configuration_Hdr _internal_hdr() const;
+  void _internal_set_hdr(::aapt::pb::Configuration_Hdr value);
+  public:
+
+  // .aapt.pb.Configuration.Orientation orientation = 15;
+  void clear_orientation();
+  ::aapt::pb::Configuration_Orientation orientation() const;
+  void set_orientation(::aapt::pb::Configuration_Orientation value);
+  private:
+  ::aapt::pb::Configuration_Orientation _internal_orientation() const;
+  void _internal_set_orientation(::aapt::pb::Configuration_Orientation value);
+  public:
+
+  // .aapt.pb.Configuration.UiModeType ui_mode_type = 16;
+  void clear_ui_mode_type();
+  ::aapt::pb::Configuration_UiModeType ui_mode_type() const;
+  void set_ui_mode_type(::aapt::pb::Configuration_UiModeType value);
+  private:
+  ::aapt::pb::Configuration_UiModeType _internal_ui_mode_type() const;
+  void _internal_set_ui_mode_type(::aapt::pb::Configuration_UiModeType value);
+  public:
+
+  // .aapt.pb.Configuration.UiModeNight ui_mode_night = 17;
+  void clear_ui_mode_night();
+  ::aapt::pb::Configuration_UiModeNight ui_mode_night() const;
+  void set_ui_mode_night(::aapt::pb::Configuration_UiModeNight value);
+  private:
+  ::aapt::pb::Configuration_UiModeNight _internal_ui_mode_night() const;
+  void _internal_set_ui_mode_night(::aapt::pb::Configuration_UiModeNight value);
+  public:
+
+  // uint32 density = 18;
+  void clear_density();
+  ::uint32_t density() const;
+  void set_density(::uint32_t value);
+  private:
+  ::uint32_t _internal_density() const;
+  void _internal_set_density(::uint32_t value);
+  public:
+
+  // .aapt.pb.Configuration.Touchscreen touchscreen = 19;
+  void clear_touchscreen();
+  ::aapt::pb::Configuration_Touchscreen touchscreen() const;
+  void set_touchscreen(::aapt::pb::Configuration_Touchscreen value);
+  private:
+  ::aapt::pb::Configuration_Touchscreen _internal_touchscreen() const;
+  void _internal_set_touchscreen(::aapt::pb::Configuration_Touchscreen value);
+  public:
+
+  // .aapt.pb.Configuration.KeysHidden keys_hidden = 20;
+  void clear_keys_hidden();
+  ::aapt::pb::Configuration_KeysHidden keys_hidden() const;
+  void set_keys_hidden(::aapt::pb::Configuration_KeysHidden value);
+  private:
+  ::aapt::pb::Configuration_KeysHidden _internal_keys_hidden() const;
+  void _internal_set_keys_hidden(::aapt::pb::Configuration_KeysHidden value);
+  public:
+
+  // .aapt.pb.Configuration.Keyboard keyboard = 21;
+  void clear_keyboard();
+  ::aapt::pb::Configuration_Keyboard keyboard() const;
+  void set_keyboard(::aapt::pb::Configuration_Keyboard value);
+  private:
+  ::aapt::pb::Configuration_Keyboard _internal_keyboard() const;
+  void _internal_set_keyboard(::aapt::pb::Configuration_Keyboard value);
+  public:
+
+  // .aapt.pb.Configuration.NavHidden nav_hidden = 22;
+  void clear_nav_hidden();
+  ::aapt::pb::Configuration_NavHidden nav_hidden() const;
+  void set_nav_hidden(::aapt::pb::Configuration_NavHidden value);
+  private:
+  ::aapt::pb::Configuration_NavHidden _internal_nav_hidden() const;
+  void _internal_set_nav_hidden(::aapt::pb::Configuration_NavHidden value);
+  public:
+
+  // .aapt.pb.Configuration.Navigation navigation = 23;
+  void clear_navigation();
+  ::aapt::pb::Configuration_Navigation navigation() const;
+  void set_navigation(::aapt::pb::Configuration_Navigation value);
+  private:
+  ::aapt::pb::Configuration_Navigation _internal_navigation() const;
+  void _internal_set_navigation(::aapt::pb::Configuration_Navigation value);
+  public:
+
+  // uint32 sdk_version = 24;
+  void clear_sdk_version();
+  ::uint32_t sdk_version() const;
+  void set_sdk_version(::uint32_t value);
+  private:
+  ::uint32_t _internal_sdk_version() const;
+  void _internal_set_sdk_version(::uint32_t value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Configuration)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locale_;
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_;
+    ::uint32_t mcc_;
+    ::uint32_t mnc_;
+    int layout_direction_;
+    ::uint32_t screen_width_;
+    ::uint32_t screen_height_;
+    ::uint32_t screen_width_dp_;
+    ::uint32_t screen_height_dp_;
+    ::uint32_t smallest_screen_width_dp_;
+    int screen_layout_size_;
+    int screen_layout_long_;
+    int screen_round_;
+    int wide_color_gamut_;
+    int hdr_;
+    int orientation_;
+    int ui_mode_type_;
+    int ui_mode_night_;
+    ::uint32_t density_;
+    int touchscreen_;
+    int keys_hidden_;
+    int keyboard_;
+    int nav_hidden_;
+    int navigation_;
+    ::uint32_t sdk_version_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Configuration_2eproto;
+};
+// ===================================================================
+
+
+// ===================================================================
+
+#ifdef __GNUC__
+  #pragma GCC diagnostic push
+  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
+#endif  // __GNUC__
+// Configuration
+
+// uint32 mcc = 1;
+inline void Configuration::clear_mcc() {
+  _impl_.mcc_ = 0u;
+}
+inline ::uint32_t Configuration::_internal_mcc() const {
+  return _impl_.mcc_;
+}
+inline ::uint32_t Configuration::mcc() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.mcc)
+  return _internal_mcc();
+}
+inline void Configuration::_internal_set_mcc(::uint32_t value) {
+  
+  _impl_.mcc_ = value;
+}
+inline void Configuration::set_mcc(::uint32_t value) {
+  _internal_set_mcc(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.mcc)
+}
+
+// uint32 mnc = 2;
+inline void Configuration::clear_mnc() {
+  _impl_.mnc_ = 0u;
+}
+inline ::uint32_t Configuration::_internal_mnc() const {
+  return _impl_.mnc_;
+}
+inline ::uint32_t Configuration::mnc() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.mnc)
+  return _internal_mnc();
+}
+inline void Configuration::_internal_set_mnc(::uint32_t value) {
+  
+  _impl_.mnc_ = value;
+}
+inline void Configuration::set_mnc(::uint32_t value) {
+  _internal_set_mnc(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.mnc)
+}
+
+// string locale = 3;
+inline void Configuration::clear_locale() {
+  _impl_.locale_.ClearToEmpty();
+}
+inline const std::string& Configuration::locale() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.locale)
+  return _internal_locale();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void Configuration::set_locale(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.locale_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.locale)
+}
+inline std::string* Configuration::mutable_locale() {
+  std::string* _s = _internal_mutable_locale();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Configuration.locale)
+  return _s;
+}
+inline const std::string& Configuration::_internal_locale() const {
+  return _impl_.locale_.Get();
+}
+inline void Configuration::_internal_set_locale(const std::string& value) {
+  
+  _impl_.locale_.Set(value, GetArenaForAllocation());
+}
+inline std::string* Configuration::_internal_mutable_locale() {
+  
+  return _impl_.locale_.Mutable(GetArenaForAllocation());
+}
+inline std::string* Configuration::release_locale() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Configuration.locale)
+  return _impl_.locale_.Release();
+}
+inline void Configuration::set_allocated_locale(std::string* locale) {
+  _impl_.locale_.SetAllocated(locale, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.locale_.IsDefault()) {
+    _impl_.locale_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Configuration.locale)
+}
+
+// .aapt.pb.Configuration.LayoutDirection layout_direction = 4;
+inline void Configuration::clear_layout_direction() {
+  _impl_.layout_direction_ = 0;
+}
+inline ::aapt::pb::Configuration_LayoutDirection Configuration::_internal_layout_direction() const {
+  return static_cast< ::aapt::pb::Configuration_LayoutDirection >(_impl_.layout_direction_);
+}
+inline ::aapt::pb::Configuration_LayoutDirection Configuration::layout_direction() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.layout_direction)
+  return _internal_layout_direction();
+}
+inline void Configuration::_internal_set_layout_direction(::aapt::pb::Configuration_LayoutDirection value) {
+  
+  _impl_.layout_direction_ = value;
+}
+inline void Configuration::set_layout_direction(::aapt::pb::Configuration_LayoutDirection value) {
+  _internal_set_layout_direction(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.layout_direction)
+}
+
+// uint32 screen_width = 5;
+inline void Configuration::clear_screen_width() {
+  _impl_.screen_width_ = 0u;
+}
+inline ::uint32_t Configuration::_internal_screen_width() const {
+  return _impl_.screen_width_;
+}
+inline ::uint32_t Configuration::screen_width() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_width)
+  return _internal_screen_width();
+}
+inline void Configuration::_internal_set_screen_width(::uint32_t value) {
+  
+  _impl_.screen_width_ = value;
+}
+inline void Configuration::set_screen_width(::uint32_t value) {
+  _internal_set_screen_width(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_width)
+}
+
+// uint32 screen_height = 6;
+inline void Configuration::clear_screen_height() {
+  _impl_.screen_height_ = 0u;
+}
+inline ::uint32_t Configuration::_internal_screen_height() const {
+  return _impl_.screen_height_;
+}
+inline ::uint32_t Configuration::screen_height() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_height)
+  return _internal_screen_height();
+}
+inline void Configuration::_internal_set_screen_height(::uint32_t value) {
+  
+  _impl_.screen_height_ = value;
+}
+inline void Configuration::set_screen_height(::uint32_t value) {
+  _internal_set_screen_height(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_height)
+}
+
+// uint32 screen_width_dp = 7;
+inline void Configuration::clear_screen_width_dp() {
+  _impl_.screen_width_dp_ = 0u;
+}
+inline ::uint32_t Configuration::_internal_screen_width_dp() const {
+  return _impl_.screen_width_dp_;
+}
+inline ::uint32_t Configuration::screen_width_dp() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_width_dp)
+  return _internal_screen_width_dp();
+}
+inline void Configuration::_internal_set_screen_width_dp(::uint32_t value) {
+  
+  _impl_.screen_width_dp_ = value;
+}
+inline void Configuration::set_screen_width_dp(::uint32_t value) {
+  _internal_set_screen_width_dp(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_width_dp)
+}
+
+// uint32 screen_height_dp = 8;
+inline void Configuration::clear_screen_height_dp() {
+  _impl_.screen_height_dp_ = 0u;
+}
+inline ::uint32_t Configuration::_internal_screen_height_dp() const {
+  return _impl_.screen_height_dp_;
+}
+inline ::uint32_t Configuration::screen_height_dp() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_height_dp)
+  return _internal_screen_height_dp();
+}
+inline void Configuration::_internal_set_screen_height_dp(::uint32_t value) {
+  
+  _impl_.screen_height_dp_ = value;
+}
+inline void Configuration::set_screen_height_dp(::uint32_t value) {
+  _internal_set_screen_height_dp(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_height_dp)
+}
+
+// uint32 smallest_screen_width_dp = 9;
+inline void Configuration::clear_smallest_screen_width_dp() {
+  _impl_.smallest_screen_width_dp_ = 0u;
+}
+inline ::uint32_t Configuration::_internal_smallest_screen_width_dp() const {
+  return _impl_.smallest_screen_width_dp_;
+}
+inline ::uint32_t Configuration::smallest_screen_width_dp() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.smallest_screen_width_dp)
+  return _internal_smallest_screen_width_dp();
+}
+inline void Configuration::_internal_set_smallest_screen_width_dp(::uint32_t value) {
+  
+  _impl_.smallest_screen_width_dp_ = value;
+}
+inline void Configuration::set_smallest_screen_width_dp(::uint32_t value) {
+  _internal_set_smallest_screen_width_dp(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.smallest_screen_width_dp)
+}
+
+// .aapt.pb.Configuration.ScreenLayoutSize screen_layout_size = 10;
+inline void Configuration::clear_screen_layout_size() {
+  _impl_.screen_layout_size_ = 0;
+}
+inline ::aapt::pb::Configuration_ScreenLayoutSize Configuration::_internal_screen_layout_size() const {
+  return static_cast< ::aapt::pb::Configuration_ScreenLayoutSize >(_impl_.screen_layout_size_);
+}
+inline ::aapt::pb::Configuration_ScreenLayoutSize Configuration::screen_layout_size() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_layout_size)
+  return _internal_screen_layout_size();
+}
+inline void Configuration::_internal_set_screen_layout_size(::aapt::pb::Configuration_ScreenLayoutSize value) {
+  
+  _impl_.screen_layout_size_ = value;
+}
+inline void Configuration::set_screen_layout_size(::aapt::pb::Configuration_ScreenLayoutSize value) {
+  _internal_set_screen_layout_size(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_layout_size)
+}
+
+// .aapt.pb.Configuration.ScreenLayoutLong screen_layout_long = 11;
+inline void Configuration::clear_screen_layout_long() {
+  _impl_.screen_layout_long_ = 0;
+}
+inline ::aapt::pb::Configuration_ScreenLayoutLong Configuration::_internal_screen_layout_long() const {
+  return static_cast< ::aapt::pb::Configuration_ScreenLayoutLong >(_impl_.screen_layout_long_);
+}
+inline ::aapt::pb::Configuration_ScreenLayoutLong Configuration::screen_layout_long() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_layout_long)
+  return _internal_screen_layout_long();
+}
+inline void Configuration::_internal_set_screen_layout_long(::aapt::pb::Configuration_ScreenLayoutLong value) {
+  
+  _impl_.screen_layout_long_ = value;
+}
+inline void Configuration::set_screen_layout_long(::aapt::pb::Configuration_ScreenLayoutLong value) {
+  _internal_set_screen_layout_long(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_layout_long)
+}
+
+// .aapt.pb.Configuration.ScreenRound screen_round = 12;
+inline void Configuration::clear_screen_round() {
+  _impl_.screen_round_ = 0;
+}
+inline ::aapt::pb::Configuration_ScreenRound Configuration::_internal_screen_round() const {
+  return static_cast< ::aapt::pb::Configuration_ScreenRound >(_impl_.screen_round_);
+}
+inline ::aapt::pb::Configuration_ScreenRound Configuration::screen_round() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.screen_round)
+  return _internal_screen_round();
+}
+inline void Configuration::_internal_set_screen_round(::aapt::pb::Configuration_ScreenRound value) {
+  
+  _impl_.screen_round_ = value;
+}
+inline void Configuration::set_screen_round(::aapt::pb::Configuration_ScreenRound value) {
+  _internal_set_screen_round(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.screen_round)
+}
+
+// .aapt.pb.Configuration.WideColorGamut wide_color_gamut = 13;
+inline void Configuration::clear_wide_color_gamut() {
+  _impl_.wide_color_gamut_ = 0;
+}
+inline ::aapt::pb::Configuration_WideColorGamut Configuration::_internal_wide_color_gamut() const {
+  return static_cast< ::aapt::pb::Configuration_WideColorGamut >(_impl_.wide_color_gamut_);
+}
+inline ::aapt::pb::Configuration_WideColorGamut Configuration::wide_color_gamut() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.wide_color_gamut)
+  return _internal_wide_color_gamut();
+}
+inline void Configuration::_internal_set_wide_color_gamut(::aapt::pb::Configuration_WideColorGamut value) {
+  
+  _impl_.wide_color_gamut_ = value;
+}
+inline void Configuration::set_wide_color_gamut(::aapt::pb::Configuration_WideColorGamut value) {
+  _internal_set_wide_color_gamut(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.wide_color_gamut)
+}
+
+// .aapt.pb.Configuration.Hdr hdr = 14;
+inline void Configuration::clear_hdr() {
+  _impl_.hdr_ = 0;
+}
+inline ::aapt::pb::Configuration_Hdr Configuration::_internal_hdr() const {
+  return static_cast< ::aapt::pb::Configuration_Hdr >(_impl_.hdr_);
+}
+inline ::aapt::pb::Configuration_Hdr Configuration::hdr() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.hdr)
+  return _internal_hdr();
+}
+inline void Configuration::_internal_set_hdr(::aapt::pb::Configuration_Hdr value) {
+  
+  _impl_.hdr_ = value;
+}
+inline void Configuration::set_hdr(::aapt::pb::Configuration_Hdr value) {
+  _internal_set_hdr(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.hdr)
+}
+
+// .aapt.pb.Configuration.Orientation orientation = 15;
+inline void Configuration::clear_orientation() {
+  _impl_.orientation_ = 0;
+}
+inline ::aapt::pb::Configuration_Orientation Configuration::_internal_orientation() const {
+  return static_cast< ::aapt::pb::Configuration_Orientation >(_impl_.orientation_);
+}
+inline ::aapt::pb::Configuration_Orientation Configuration::orientation() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.orientation)
+  return _internal_orientation();
+}
+inline void Configuration::_internal_set_orientation(::aapt::pb::Configuration_Orientation value) {
+  
+  _impl_.orientation_ = value;
+}
+inline void Configuration::set_orientation(::aapt::pb::Configuration_Orientation value) {
+  _internal_set_orientation(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.orientation)
+}
+
+// .aapt.pb.Configuration.UiModeType ui_mode_type = 16;
+inline void Configuration::clear_ui_mode_type() {
+  _impl_.ui_mode_type_ = 0;
+}
+inline ::aapt::pb::Configuration_UiModeType Configuration::_internal_ui_mode_type() const {
+  return static_cast< ::aapt::pb::Configuration_UiModeType >(_impl_.ui_mode_type_);
+}
+inline ::aapt::pb::Configuration_UiModeType Configuration::ui_mode_type() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.ui_mode_type)
+  return _internal_ui_mode_type();
+}
+inline void Configuration::_internal_set_ui_mode_type(::aapt::pb::Configuration_UiModeType value) {
+  
+  _impl_.ui_mode_type_ = value;
+}
+inline void Configuration::set_ui_mode_type(::aapt::pb::Configuration_UiModeType value) {
+  _internal_set_ui_mode_type(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.ui_mode_type)
+}
+
+// .aapt.pb.Configuration.UiModeNight ui_mode_night = 17;
+inline void Configuration::clear_ui_mode_night() {
+  _impl_.ui_mode_night_ = 0;
+}
+inline ::aapt::pb::Configuration_UiModeNight Configuration::_internal_ui_mode_night() const {
+  return static_cast< ::aapt::pb::Configuration_UiModeNight >(_impl_.ui_mode_night_);
+}
+inline ::aapt::pb::Configuration_UiModeNight Configuration::ui_mode_night() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.ui_mode_night)
+  return _internal_ui_mode_night();
+}
+inline void Configuration::_internal_set_ui_mode_night(::aapt::pb::Configuration_UiModeNight value) {
+  
+  _impl_.ui_mode_night_ = value;
+}
+inline void Configuration::set_ui_mode_night(::aapt::pb::Configuration_UiModeNight value) {
+  _internal_set_ui_mode_night(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.ui_mode_night)
+}
+
+// uint32 density = 18;
+inline void Configuration::clear_density() {
+  _impl_.density_ = 0u;
+}
+inline ::uint32_t Configuration::_internal_density() const {
+  return _impl_.density_;
+}
+inline ::uint32_t Configuration::density() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.density)
+  return _internal_density();
+}
+inline void Configuration::_internal_set_density(::uint32_t value) {
+  
+  _impl_.density_ = value;
+}
+inline void Configuration::set_density(::uint32_t value) {
+  _internal_set_density(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.density)
+}
+
+// .aapt.pb.Configuration.Touchscreen touchscreen = 19;
+inline void Configuration::clear_touchscreen() {
+  _impl_.touchscreen_ = 0;
+}
+inline ::aapt::pb::Configuration_Touchscreen Configuration::_internal_touchscreen() const {
+  return static_cast< ::aapt::pb::Configuration_Touchscreen >(_impl_.touchscreen_);
+}
+inline ::aapt::pb::Configuration_Touchscreen Configuration::touchscreen() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.touchscreen)
+  return _internal_touchscreen();
+}
+inline void Configuration::_internal_set_touchscreen(::aapt::pb::Configuration_Touchscreen value) {
+  
+  _impl_.touchscreen_ = value;
+}
+inline void Configuration::set_touchscreen(::aapt::pb::Configuration_Touchscreen value) {
+  _internal_set_touchscreen(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.touchscreen)
+}
+
+// .aapt.pb.Configuration.KeysHidden keys_hidden = 20;
+inline void Configuration::clear_keys_hidden() {
+  _impl_.keys_hidden_ = 0;
+}
+inline ::aapt::pb::Configuration_KeysHidden Configuration::_internal_keys_hidden() const {
+  return static_cast< ::aapt::pb::Configuration_KeysHidden >(_impl_.keys_hidden_);
+}
+inline ::aapt::pb::Configuration_KeysHidden Configuration::keys_hidden() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.keys_hidden)
+  return _internal_keys_hidden();
+}
+inline void Configuration::_internal_set_keys_hidden(::aapt::pb::Configuration_KeysHidden value) {
+  
+  _impl_.keys_hidden_ = value;
+}
+inline void Configuration::set_keys_hidden(::aapt::pb::Configuration_KeysHidden value) {
+  _internal_set_keys_hidden(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.keys_hidden)
+}
+
+// .aapt.pb.Configuration.Keyboard keyboard = 21;
+inline void Configuration::clear_keyboard() {
+  _impl_.keyboard_ = 0;
+}
+inline ::aapt::pb::Configuration_Keyboard Configuration::_internal_keyboard() const {
+  return static_cast< ::aapt::pb::Configuration_Keyboard >(_impl_.keyboard_);
+}
+inline ::aapt::pb::Configuration_Keyboard Configuration::keyboard() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.keyboard)
+  return _internal_keyboard();
+}
+inline void Configuration::_internal_set_keyboard(::aapt::pb::Configuration_Keyboard value) {
+  
+  _impl_.keyboard_ = value;
+}
+inline void Configuration::set_keyboard(::aapt::pb::Configuration_Keyboard value) {
+  _internal_set_keyboard(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.keyboard)
+}
+
+// .aapt.pb.Configuration.NavHidden nav_hidden = 22;
+inline void Configuration::clear_nav_hidden() {
+  _impl_.nav_hidden_ = 0;
+}
+inline ::aapt::pb::Configuration_NavHidden Configuration::_internal_nav_hidden() const {
+  return static_cast< ::aapt::pb::Configuration_NavHidden >(_impl_.nav_hidden_);
+}
+inline ::aapt::pb::Configuration_NavHidden Configuration::nav_hidden() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.nav_hidden)
+  return _internal_nav_hidden();
+}
+inline void Configuration::_internal_set_nav_hidden(::aapt::pb::Configuration_NavHidden value) {
+  
+  _impl_.nav_hidden_ = value;
+}
+inline void Configuration::set_nav_hidden(::aapt::pb::Configuration_NavHidden value) {
+  _internal_set_nav_hidden(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.nav_hidden)
+}
+
+// .aapt.pb.Configuration.Navigation navigation = 23;
+inline void Configuration::clear_navigation() {
+  _impl_.navigation_ = 0;
+}
+inline ::aapt::pb::Configuration_Navigation Configuration::_internal_navigation() const {
+  return static_cast< ::aapt::pb::Configuration_Navigation >(_impl_.navigation_);
+}
+inline ::aapt::pb::Configuration_Navigation Configuration::navigation() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.navigation)
+  return _internal_navigation();
+}
+inline void Configuration::_internal_set_navigation(::aapt::pb::Configuration_Navigation value) {
+  
+  _impl_.navigation_ = value;
+}
+inline void Configuration::set_navigation(::aapt::pb::Configuration_Navigation value) {
+  _internal_set_navigation(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.navigation)
+}
+
+// uint32 sdk_version = 24;
+inline void Configuration::clear_sdk_version() {
+  _impl_.sdk_version_ = 0u;
+}
+inline ::uint32_t Configuration::_internal_sdk_version() const {
+  return _impl_.sdk_version_;
+}
+inline ::uint32_t Configuration::sdk_version() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.sdk_version)
+  return _internal_sdk_version();
+}
+inline void Configuration::_internal_set_sdk_version(::uint32_t value) {
+  
+  _impl_.sdk_version_ = value;
+}
+inline void Configuration::set_sdk_version(::uint32_t value) {
+  _internal_set_sdk_version(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.sdk_version)
+}
+
+// string product = 25;
+inline void Configuration::clear_product() {
+  _impl_.product_.ClearToEmpty();
+}
+inline const std::string& Configuration::product() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Configuration.product)
+  return _internal_product();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void Configuration::set_product(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.product_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.Configuration.product)
+}
+inline std::string* Configuration::mutable_product() {
+  std::string* _s = _internal_mutable_product();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Configuration.product)
+  return _s;
+}
+inline const std::string& Configuration::_internal_product() const {
+  return _impl_.product_.Get();
+}
+inline void Configuration::_internal_set_product(const std::string& value) {
+  
+  _impl_.product_.Set(value, GetArenaForAllocation());
+}
+inline std::string* Configuration::_internal_mutable_product() {
+  
+  return _impl_.product_.Mutable(GetArenaForAllocation());
+}
+inline std::string* Configuration::release_product() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Configuration.product)
+  return _impl_.product_.Release();
+}
+inline void Configuration::set_allocated_product(std::string* product) {
+  _impl_.product_.SetAllocated(product, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.product_.IsDefault()) {
+    _impl_.product_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Configuration.product)
+}
+
+#ifdef __GNUC__
+  #pragma GCC diagnostic pop
+#endif  // __GNUC__
+
+// @@protoc_insertion_point(namespace_scope)
+
+}  // namespace pb
+}  // namespace aapt
+
+PROTOBUF_NAMESPACE_OPEN
+
+template <> struct is_proto_enum< ::aapt::pb::Configuration_LayoutDirection> : ::std::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_LayoutDirection>() {
+  return ::aapt::pb::Configuration_LayoutDirection_descriptor();
+}
+template <> struct is_proto_enum< ::aapt::pb::Configuration_ScreenLayoutSize> : ::std::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_ScreenLayoutSize>() {
+  return ::aapt::pb::Configuration_ScreenLayoutSize_descriptor();
+}
+template <> struct is_proto_enum< ::aapt::pb::Configuration_ScreenLayoutLong> : ::std::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_ScreenLayoutLong>() {
+  return ::aapt::pb::Configuration_ScreenLayoutLong_descriptor();
+}
+template <> struct is_proto_enum< ::aapt::pb::Configuration_ScreenRound> : ::std::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_ScreenRound>() {
+  return ::aapt::pb::Configuration_ScreenRound_descriptor();
+}
+template <> struct is_proto_enum< ::aapt::pb::Configuration_WideColorGamut> : ::std::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_WideColorGamut>() {
+  return ::aapt::pb::Configuration_WideColorGamut_descriptor();
+}
+template <> struct is_proto_enum< ::aapt::pb::Configuration_Hdr> : ::std::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_Hdr>() {
+  return ::aapt::pb::Configuration_Hdr_descriptor();
+}
+template <> struct is_proto_enum< ::aapt::pb::Configuration_Orientation> : ::std::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_Orientation>() {
+  return ::aapt::pb::Configuration_Orientation_descriptor();
+}
+template <> struct is_proto_enum< ::aapt::pb::Configuration_UiModeType> : ::std::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_UiModeType>() {
+  return ::aapt::pb::Configuration_UiModeType_descriptor();
+}
+template <> struct is_proto_enum< ::aapt::pb::Configuration_UiModeNight> : ::std::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_UiModeNight>() {
+  return ::aapt::pb::Configuration_UiModeNight_descriptor();
+}
+template <> struct is_proto_enum< ::aapt::pb::Configuration_Touchscreen> : ::std::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_Touchscreen>() {
+  return ::aapt::pb::Configuration_Touchscreen_descriptor();
+}
+template <> struct is_proto_enum< ::aapt::pb::Configuration_KeysHidden> : ::std::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_KeysHidden>() {
+  return ::aapt::pb::Configuration_KeysHidden_descriptor();
+}
+template <> struct is_proto_enum< ::aapt::pb::Configuration_Keyboard> : ::std::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_Keyboard>() {
+  return ::aapt::pb::Configuration_Keyboard_descriptor();
+}
+template <> struct is_proto_enum< ::aapt::pb::Configuration_NavHidden> : ::std::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_NavHidden>() {
+  return ::aapt::pb::Configuration_NavHidden_descriptor();
+}
+template <> struct is_proto_enum< ::aapt::pb::Configuration_Navigation> : ::std::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Configuration_Navigation>() {
+  return ::aapt::pb::Configuration_Navigation_descriptor();
+}
+
+PROTOBUF_NAMESPACE_CLOSE
+
+// @@protoc_insertion_point(global_scope)
+
+#include <google/protobuf/port_undef.inc>
+#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Configuration_2eproto
diff --git a/tools/aapt2/Resources.pb.cc b/tools/aapt2/Resources.pb.cc
new file mode 100644
index 00000000..d747c67a
--- /dev/null
+++ b/tools/aapt2/Resources.pb.cc
@@ -0,0 +1,15857 @@
+// Generated by the protocol buffer compiler.  DO NOT EDIT!
+// source: Resources.proto
+
+#include "Resources.pb.h"
+
+#include <algorithm>
+#include <cstdint>
+
+#include <google/protobuf/io/coded_stream.h>
+#include <google/protobuf/extension_set.h>
+#include <google/protobuf/wire_format_lite.h>
+#include <google/protobuf/descriptor.h>
+#include <google/protobuf/generated_message_reflection.h>
+#include <google/protobuf/reflection_ops.h>
+#include <google/protobuf/wire_format.h>
+// @@protoc_insertion_point(includes)
+#include <google/protobuf/port_def.inc>
+
+PROTOBUF_PRAGMA_INIT_SEG
+
+namespace _pb = ::PROTOBUF_NAMESPACE_ID;
+namespace _pbi = _pb::internal;
+
+namespace aapt {
+namespace pb {
+PROTOBUF_CONSTEXPR StringPool::StringPool(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct StringPoolDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR StringPoolDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~StringPoolDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    StringPool _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StringPoolDefaultTypeInternal _StringPool_default_instance_;
+PROTOBUF_CONSTEXPR SourcePosition::SourcePosition(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.line_number_)*/0u
+  , /*decltype(_impl_.column_number_)*/0u
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct SourcePositionDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR SourcePositionDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~SourcePositionDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    SourcePosition _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SourcePositionDefaultTypeInternal _SourcePosition_default_instance_;
+PROTOBUF_CONSTEXPR Source::Source(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.position_)*/nullptr
+  , /*decltype(_impl_.path_idx_)*/0u
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct SourceDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR SourceDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~SourceDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Source _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SourceDefaultTypeInternal _Source_default_instance_;
+PROTOBUF_CONSTEXPR ToolFingerprint::ToolFingerprint(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.tool_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct ToolFingerprintDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR ToolFingerprintDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~ToolFingerprintDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    ToolFingerprint _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ToolFingerprintDefaultTypeInternal _ToolFingerprint_default_instance_;
+PROTOBUF_CONSTEXPR ResourceTable::ResourceTable(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.package_)*/{}
+  , /*decltype(_impl_.overlayable_)*/{}
+  , /*decltype(_impl_.tool_fingerprint_)*/{}
+  , /*decltype(_impl_.source_pool_)*/nullptr
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct ResourceTableDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR ResourceTableDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~ResourceTableDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    ResourceTable _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResourceTableDefaultTypeInternal _ResourceTable_default_instance_;
+PROTOBUF_CONSTEXPR PackageId::PackageId(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.id_)*/0u
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct PackageIdDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR PackageIdDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~PackageIdDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    PackageId _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PackageIdDefaultTypeInternal _PackageId_default_instance_;
+PROTOBUF_CONSTEXPR Package::Package(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.type_)*/{}
+  , /*decltype(_impl_.package_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.package_id_)*/nullptr
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct PackageDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR PackageDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~PackageDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Package _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PackageDefaultTypeInternal _Package_default_instance_;
+PROTOBUF_CONSTEXPR TypeId::TypeId(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.id_)*/0u
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct TypeIdDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR TypeIdDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~TypeIdDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    TypeId _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TypeIdDefaultTypeInternal _TypeId_default_instance_;
+PROTOBUF_CONSTEXPR Type::Type(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.entry_)*/{}
+  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.type_id_)*/nullptr
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct TypeDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR TypeDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~TypeDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Type _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TypeDefaultTypeInternal _Type_default_instance_;
+PROTOBUF_CONSTEXPR Visibility::Visibility(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.source_)*/nullptr
+  , /*decltype(_impl_.level_)*/0
+  , /*decltype(_impl_.staged_api_)*/false
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct VisibilityDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR VisibilityDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~VisibilityDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Visibility _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VisibilityDefaultTypeInternal _Visibility_default_instance_;
+PROTOBUF_CONSTEXPR AllowNew::AllowNew(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.source_)*/nullptr
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct AllowNewDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR AllowNewDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~AllowNewDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    AllowNew _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllowNewDefaultTypeInternal _AllowNew_default_instance_;
+PROTOBUF_CONSTEXPR Overlayable::Overlayable(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.actor_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.source_)*/nullptr
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct OverlayableDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR OverlayableDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~OverlayableDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Overlayable _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OverlayableDefaultTypeInternal _Overlayable_default_instance_;
+PROTOBUF_CONSTEXPR OverlayableItem::OverlayableItem(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.policy_)*/{}
+  , /*decltype(_impl_._policy_cached_byte_size_)*/{0}
+  , /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.source_)*/nullptr
+  , /*decltype(_impl_.overlayable_idx_)*/0u
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct OverlayableItemDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR OverlayableItemDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~OverlayableItemDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    OverlayableItem _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OverlayableItemDefaultTypeInternal _OverlayableItem_default_instance_;
+PROTOBUF_CONSTEXPR StagedId::StagedId(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.source_)*/nullptr
+  , /*decltype(_impl_.staged_id_)*/0u
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct StagedIdDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR StagedIdDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~StagedIdDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    StagedId _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StagedIdDefaultTypeInternal _StagedId_default_instance_;
+PROTOBUF_CONSTEXPR EntryId::EntryId(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.id_)*/0u
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct EntryIdDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR EntryIdDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~EntryIdDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    EntryId _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EntryIdDefaultTypeInternal _EntryId_default_instance_;
+PROTOBUF_CONSTEXPR Entry::Entry(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.config_value_)*/{}
+  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.entry_id_)*/nullptr
+  , /*decltype(_impl_.visibility_)*/nullptr
+  , /*decltype(_impl_.allow_new_)*/nullptr
+  , /*decltype(_impl_.overlayable_item_)*/nullptr
+  , /*decltype(_impl_.staged_id_)*/nullptr
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct EntryDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR EntryDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~EntryDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Entry _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EntryDefaultTypeInternal _Entry_default_instance_;
+PROTOBUF_CONSTEXPR ConfigValue::ConfigValue(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.config_)*/nullptr
+  , /*decltype(_impl_.value_)*/nullptr
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct ConfigValueDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR ConfigValueDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~ConfigValueDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    ConfigValue _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigValueDefaultTypeInternal _ConfigValue_default_instance_;
+PROTOBUF_CONSTEXPR Value::Value(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.source_)*/nullptr
+  , /*decltype(_impl_.weak_)*/false
+  , /*decltype(_impl_.value_)*/{}
+  , /*decltype(_impl_._cached_size_)*/{}
+  , /*decltype(_impl_._oneof_case_)*/{}} {}
+struct ValueDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR ValueDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~ValueDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Value _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ValueDefaultTypeInternal _Value_default_instance_;
+PROTOBUF_CONSTEXPR Item::Item(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.value_)*/{}
+  , /*decltype(_impl_._cached_size_)*/{}
+  , /*decltype(_impl_._oneof_case_)*/{}} {}
+struct ItemDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR ItemDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~ItemDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Item _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ItemDefaultTypeInternal _Item_default_instance_;
+PROTOBUF_CONSTEXPR CompoundValue::CompoundValue(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.value_)*/{}
+  , /*decltype(_impl_._cached_size_)*/{}
+  , /*decltype(_impl_._oneof_case_)*/{}} {}
+struct CompoundValueDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR CompoundValueDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~CompoundValueDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    CompoundValue _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompoundValueDefaultTypeInternal _CompoundValue_default_instance_;
+PROTOBUF_CONSTEXPR Boolean::Boolean(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.value_)*/false
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct BooleanDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR BooleanDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~BooleanDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Boolean _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BooleanDefaultTypeInternal _Boolean_default_instance_;
+PROTOBUF_CONSTEXPR Reference::Reference(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.is_dynamic_)*/nullptr
+  , /*decltype(_impl_.type_)*/0
+  , /*decltype(_impl_.id_)*/0u
+  , /*decltype(_impl_.private__)*/false
+  , /*decltype(_impl_.allow_raw_)*/false
+  , /*decltype(_impl_.type_flags_)*/0u
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct ReferenceDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR ReferenceDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~ReferenceDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Reference _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReferenceDefaultTypeInternal _Reference_default_instance_;
+PROTOBUF_CONSTEXPR Id::Id(
+    ::_pbi::ConstantInitialized) {}
+struct IdDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR IdDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~IdDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Id _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IdDefaultTypeInternal _Id_default_instance_;
+PROTOBUF_CONSTEXPR String::String(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct StringDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR StringDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~StringDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    String _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StringDefaultTypeInternal _String_default_instance_;
+PROTOBUF_CONSTEXPR RawString::RawString(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct RawStringDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR RawStringDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~RawStringDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    RawString _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RawStringDefaultTypeInternal _RawString_default_instance_;
+PROTOBUF_CONSTEXPR StyledString_Span::StyledString_Span(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.first_char_)*/0u
+  , /*decltype(_impl_.last_char_)*/0u
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct StyledString_SpanDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR StyledString_SpanDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~StyledString_SpanDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    StyledString_Span _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyledString_SpanDefaultTypeInternal _StyledString_Span_default_instance_;
+PROTOBUF_CONSTEXPR StyledString::StyledString(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.span_)*/{}
+  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct StyledStringDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR StyledStringDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~StyledStringDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    StyledString _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyledStringDefaultTypeInternal _StyledString_default_instance_;
+PROTOBUF_CONSTEXPR FileReference::FileReference(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.type_)*/0
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct FileReferenceDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR FileReferenceDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~FileReferenceDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    FileReference _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileReferenceDefaultTypeInternal _FileReference_default_instance_;
+PROTOBUF_CONSTEXPR Primitive_NullType::Primitive_NullType(
+    ::_pbi::ConstantInitialized) {}
+struct Primitive_NullTypeDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR Primitive_NullTypeDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~Primitive_NullTypeDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Primitive_NullType _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Primitive_NullTypeDefaultTypeInternal _Primitive_NullType_default_instance_;
+PROTOBUF_CONSTEXPR Primitive_EmptyType::Primitive_EmptyType(
+    ::_pbi::ConstantInitialized) {}
+struct Primitive_EmptyTypeDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR Primitive_EmptyTypeDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~Primitive_EmptyTypeDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Primitive_EmptyType _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Primitive_EmptyTypeDefaultTypeInternal _Primitive_EmptyType_default_instance_;
+PROTOBUF_CONSTEXPR Primitive::Primitive(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.oneof_value_)*/{}
+  , /*decltype(_impl_._cached_size_)*/{}
+  , /*decltype(_impl_._oneof_case_)*/{}} {}
+struct PrimitiveDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR PrimitiveDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~PrimitiveDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Primitive _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PrimitiveDefaultTypeInternal _Primitive_default_instance_;
+PROTOBUF_CONSTEXPR Attribute_Symbol::Attribute_Symbol(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.source_)*/nullptr
+  , /*decltype(_impl_.name_)*/nullptr
+  , /*decltype(_impl_.value_)*/0u
+  , /*decltype(_impl_.type_)*/0u
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct Attribute_SymbolDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR Attribute_SymbolDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~Attribute_SymbolDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Attribute_Symbol _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Attribute_SymbolDefaultTypeInternal _Attribute_Symbol_default_instance_;
+PROTOBUF_CONSTEXPR Attribute::Attribute(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.symbol_)*/{}
+  , /*decltype(_impl_.format_flags_)*/0u
+  , /*decltype(_impl_.min_int_)*/0
+  , /*decltype(_impl_.max_int_)*/0
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct AttributeDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR AttributeDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~AttributeDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Attribute _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AttributeDefaultTypeInternal _Attribute_default_instance_;
+PROTOBUF_CONSTEXPR Style_Entry::Style_Entry(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.source_)*/nullptr
+  , /*decltype(_impl_.key_)*/nullptr
+  , /*decltype(_impl_.item_)*/nullptr
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct Style_EntryDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR Style_EntryDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~Style_EntryDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Style_Entry _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Style_EntryDefaultTypeInternal _Style_Entry_default_instance_;
+PROTOBUF_CONSTEXPR Style::Style(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.entry_)*/{}
+  , /*decltype(_impl_.parent_)*/nullptr
+  , /*decltype(_impl_.parent_source_)*/nullptr
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct StyleDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR StyleDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~StyleDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Style _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleDefaultTypeInternal _Style_default_instance_;
+PROTOBUF_CONSTEXPR Styleable_Entry::Styleable_Entry(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.source_)*/nullptr
+  , /*decltype(_impl_.attr_)*/nullptr
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct Styleable_EntryDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR Styleable_EntryDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~Styleable_EntryDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Styleable_Entry _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Styleable_EntryDefaultTypeInternal _Styleable_Entry_default_instance_;
+PROTOBUF_CONSTEXPR Styleable::Styleable(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.entry_)*/{}
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct StyleableDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR StyleableDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~StyleableDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Styleable _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleableDefaultTypeInternal _Styleable_default_instance_;
+PROTOBUF_CONSTEXPR Array_Element::Array_Element(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.source_)*/nullptr
+  , /*decltype(_impl_.item_)*/nullptr
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct Array_ElementDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR Array_ElementDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~Array_ElementDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Array_Element _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Array_ElementDefaultTypeInternal _Array_Element_default_instance_;
+PROTOBUF_CONSTEXPR Array::Array(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.element_)*/{}
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct ArrayDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR ArrayDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~ArrayDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Array _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArrayDefaultTypeInternal _Array_default_instance_;
+PROTOBUF_CONSTEXPR Plural_Entry::Plural_Entry(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.source_)*/nullptr
+  , /*decltype(_impl_.item_)*/nullptr
+  , /*decltype(_impl_.arity_)*/0
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct Plural_EntryDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR Plural_EntryDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~Plural_EntryDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Plural_Entry _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Plural_EntryDefaultTypeInternal _Plural_Entry_default_instance_;
+PROTOBUF_CONSTEXPR Plural::Plural(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.entry_)*/{}
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct PluralDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR PluralDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~PluralDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    Plural _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PluralDefaultTypeInternal _Plural_default_instance_;
+PROTOBUF_CONSTEXPR XmlNode::XmlNode(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.source_)*/nullptr
+  , /*decltype(_impl_.node_)*/{}
+  , /*decltype(_impl_._cached_size_)*/{}
+  , /*decltype(_impl_._oneof_case_)*/{}} {}
+struct XmlNodeDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR XmlNodeDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~XmlNodeDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    XmlNode _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 XmlNodeDefaultTypeInternal _XmlNode_default_instance_;
+PROTOBUF_CONSTEXPR XmlElement::XmlElement(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.namespace_declaration_)*/{}
+  , /*decltype(_impl_.attribute_)*/{}
+  , /*decltype(_impl_.child_)*/{}
+  , /*decltype(_impl_.namespace_uri_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct XmlElementDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR XmlElementDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~XmlElementDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    XmlElement _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 XmlElementDefaultTypeInternal _XmlElement_default_instance_;
+PROTOBUF_CONSTEXPR XmlNamespace::XmlNamespace(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.prefix_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.uri_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.source_)*/nullptr
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct XmlNamespaceDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR XmlNamespaceDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~XmlNamespaceDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    XmlNamespace _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 XmlNamespaceDefaultTypeInternal _XmlNamespace_default_instance_;
+PROTOBUF_CONSTEXPR XmlAttribute::XmlAttribute(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.namespace_uri_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.source_)*/nullptr
+  , /*decltype(_impl_.compiled_item_)*/nullptr
+  , /*decltype(_impl_.resource_id_)*/0u
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct XmlAttributeDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR XmlAttributeDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~XmlAttributeDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    XmlAttribute _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 XmlAttributeDefaultTypeInternal _XmlAttribute_default_instance_;
+PROTOBUF_CONSTEXPR MacroBody::MacroBody(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.untranslatable_sections_)*/{}
+  , /*decltype(_impl_.namespace_stack_)*/{}
+  , /*decltype(_impl_.raw_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.style_string_)*/nullptr
+  , /*decltype(_impl_.source_)*/nullptr
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct MacroBodyDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR MacroBodyDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~MacroBodyDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    MacroBody _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MacroBodyDefaultTypeInternal _MacroBody_default_instance_;
+PROTOBUF_CONSTEXPR NamespaceAlias::NamespaceAlias(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.prefix_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.package_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.is_private_)*/false
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct NamespaceAliasDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR NamespaceAliasDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~NamespaceAliasDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    NamespaceAlias _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamespaceAliasDefaultTypeInternal _NamespaceAlias_default_instance_;
+PROTOBUF_CONSTEXPR StyleString_Span::StyleString_Span(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.start_index_)*/0u
+  , /*decltype(_impl_.end_index_)*/0u
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct StyleString_SpanDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR StyleString_SpanDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~StyleString_SpanDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    StyleString_Span _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleString_SpanDefaultTypeInternal _StyleString_Span_default_instance_;
+PROTOBUF_CONSTEXPR StyleString::StyleString(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.spans_)*/{}
+  , /*decltype(_impl_.str_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct StyleStringDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR StyleStringDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~StyleStringDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    StyleString _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleStringDefaultTypeInternal _StyleString_default_instance_;
+PROTOBUF_CONSTEXPR UntranslatableSection::UntranslatableSection(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.start_index_)*/::uint64_t{0u}
+  , /*decltype(_impl_.end_index_)*/::uint64_t{0u}
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct UntranslatableSectionDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR UntranslatableSectionDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~UntranslatableSectionDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    UntranslatableSection _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UntranslatableSectionDefaultTypeInternal _UntranslatableSection_default_instance_;
+}  // namespace pb
+}  // namespace aapt
+static ::_pb::Metadata file_level_metadata_Resources_2eproto[50];
+static const ::_pb::EnumDescriptor* file_level_enum_descriptors_Resources_2eproto[6];
+static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_Resources_2eproto = nullptr;
+
+const ::uint32_t TableStruct_Resources_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::StringPool, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::StringPool, _impl_.data_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::SourcePosition, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::SourcePosition, _impl_.line_number_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::SourcePosition, _impl_.column_number_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Source, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Source, _impl_.path_idx_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Source, _impl_.position_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::ToolFingerprint, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::ToolFingerprint, _impl_.tool_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::ToolFingerprint, _impl_.version_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::ResourceTable, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::ResourceTable, _impl_.source_pool_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::ResourceTable, _impl_.package_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::ResourceTable, _impl_.overlayable_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::ResourceTable, _impl_.tool_fingerprint_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::PackageId, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::PackageId, _impl_.id_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Package, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Package, _impl_.package_id_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Package, _impl_.package_name_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Package, _impl_.type_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::TypeId, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::TypeId, _impl_.id_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Type, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Type, _impl_.type_id_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Type, _impl_.name_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Type, _impl_.entry_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Visibility, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Visibility, _impl_.level_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Visibility, _impl_.source_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Visibility, _impl_.comment_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Visibility, _impl_.staged_api_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::AllowNew, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::AllowNew, _impl_.source_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::AllowNew, _impl_.comment_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Overlayable, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Overlayable, _impl_.name_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Overlayable, _impl_.source_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Overlayable, _impl_.actor_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::OverlayableItem, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::OverlayableItem, _impl_.source_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::OverlayableItem, _impl_.comment_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::OverlayableItem, _impl_.policy_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::OverlayableItem, _impl_.overlayable_idx_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::StagedId, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::StagedId, _impl_.source_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::StagedId, _impl_.staged_id_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::EntryId, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::EntryId, _impl_.id_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Entry, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Entry, _impl_.entry_id_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Entry, _impl_.name_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Entry, _impl_.visibility_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Entry, _impl_.allow_new_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Entry, _impl_.overlayable_item_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Entry, _impl_.config_value_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Entry, _impl_.staged_id_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::ConfigValue, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::ConfigValue, _impl_.config_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::ConfigValue, _impl_.value_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Value, _internal_metadata_),
+  ~0u,  // no _extensions_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Value, _impl_._oneof_case_[0]),
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Value, _impl_.source_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Value, _impl_.comment_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Value, _impl_.weak_),
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Value, _impl_.value_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Item, _internal_metadata_),
+  ~0u,  // no _extensions_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Item, _impl_._oneof_case_[0]),
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Item, _impl_.value_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::CompoundValue, _internal_metadata_),
+  ~0u,  // no _extensions_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::CompoundValue, _impl_._oneof_case_[0]),
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::CompoundValue, _impl_.value_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Boolean, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Boolean, _impl_.value_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Reference, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Reference, _impl_.type_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Reference, _impl_.id_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Reference, _impl_.name_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Reference, _impl_.private__),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Reference, _impl_.is_dynamic_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Reference, _impl_.type_flags_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Reference, _impl_.allow_raw_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Id, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::String, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::String, _impl_.value_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::RawString, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::RawString, _impl_.value_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::StyledString_Span, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::StyledString_Span, _impl_.tag_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::StyledString_Span, _impl_.first_char_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::StyledString_Span, _impl_.last_char_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::StyledString, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::StyledString, _impl_.value_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::StyledString, _impl_.span_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::FileReference, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::FileReference, _impl_.path_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::FileReference, _impl_.type_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Primitive_NullType, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Primitive_EmptyType, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Primitive, _internal_metadata_),
+  ~0u,  // no _extensions_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Primitive, _impl_._oneof_case_[0]),
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Primitive, _impl_.oneof_value_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Attribute_Symbol, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Attribute_Symbol, _impl_.source_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Attribute_Symbol, _impl_.comment_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Attribute_Symbol, _impl_.name_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Attribute_Symbol, _impl_.value_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Attribute_Symbol, _impl_.type_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Attribute, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Attribute, _impl_.format_flags_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Attribute, _impl_.min_int_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Attribute, _impl_.max_int_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Attribute, _impl_.symbol_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Style_Entry, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Style_Entry, _impl_.source_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Style_Entry, _impl_.comment_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Style_Entry, _impl_.key_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Style_Entry, _impl_.item_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Style, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Style, _impl_.parent_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Style, _impl_.parent_source_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Style, _impl_.entry_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Styleable_Entry, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Styleable_Entry, _impl_.source_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Styleable_Entry, _impl_.comment_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Styleable_Entry, _impl_.attr_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Styleable, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Styleable, _impl_.entry_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Array_Element, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Array_Element, _impl_.source_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Array_Element, _impl_.comment_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Array_Element, _impl_.item_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Array, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Array, _impl_.element_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Plural_Entry, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Plural_Entry, _impl_.source_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Plural_Entry, _impl_.comment_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Plural_Entry, _impl_.arity_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Plural_Entry, _impl_.item_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Plural, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::Plural, _impl_.entry_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlNode, _internal_metadata_),
+  ~0u,  // no _extensions_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlNode, _impl_._oneof_case_[0]),
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  ::_pbi::kInvalidFieldOffsetTag,
+  ::_pbi::kInvalidFieldOffsetTag,
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlNode, _impl_.source_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlNode, _impl_.node_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlElement, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlElement, _impl_.namespace_declaration_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlElement, _impl_.namespace_uri_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlElement, _impl_.name_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlElement, _impl_.attribute_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlElement, _impl_.child_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlNamespace, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlNamespace, _impl_.prefix_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlNamespace, _impl_.uri_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlNamespace, _impl_.source_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlAttribute, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlAttribute, _impl_.namespace_uri_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlAttribute, _impl_.name_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlAttribute, _impl_.value_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlAttribute, _impl_.source_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlAttribute, _impl_.resource_id_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::XmlAttribute, _impl_.compiled_item_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::MacroBody, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::MacroBody, _impl_.raw_string_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::MacroBody, _impl_.style_string_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::MacroBody, _impl_.untranslatable_sections_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::MacroBody, _impl_.namespace_stack_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::MacroBody, _impl_.source_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::NamespaceAlias, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::NamespaceAlias, _impl_.prefix_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::NamespaceAlias, _impl_.package_name_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::NamespaceAlias, _impl_.is_private_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::StyleString_Span, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::StyleString_Span, _impl_.name_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::StyleString_Span, _impl_.start_index_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::StyleString_Span, _impl_.end_index_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::StyleString, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::StyleString, _impl_.str_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::StyleString, _impl_.spans_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::UntranslatableSection, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::UntranslatableSection, _impl_.start_index_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::UntranslatableSection, _impl_.end_index_),
+};
+static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
+  { 0, -1, -1, sizeof(::aapt::pb::StringPool)},
+  { 7, -1, -1, sizeof(::aapt::pb::SourcePosition)},
+  { 15, -1, -1, sizeof(::aapt::pb::Source)},
+  { 23, -1, -1, sizeof(::aapt::pb::ToolFingerprint)},
+  { 31, -1, -1, sizeof(::aapt::pb::ResourceTable)},
+  { 41, -1, -1, sizeof(::aapt::pb::PackageId)},
+  { 48, -1, -1, sizeof(::aapt::pb::Package)},
+  { 57, -1, -1, sizeof(::aapt::pb::TypeId)},
+  { 64, -1, -1, sizeof(::aapt::pb::Type)},
+  { 73, -1, -1, sizeof(::aapt::pb::Visibility)},
+  { 83, -1, -1, sizeof(::aapt::pb::AllowNew)},
+  { 91, -1, -1, sizeof(::aapt::pb::Overlayable)},
+  { 100, -1, -1, sizeof(::aapt::pb::OverlayableItem)},
+  { 110, -1, -1, sizeof(::aapt::pb::StagedId)},
+  { 118, -1, -1, sizeof(::aapt::pb::EntryId)},
+  { 125, -1, -1, sizeof(::aapt::pb::Entry)},
+  { 138, -1, -1, sizeof(::aapt::pb::ConfigValue)},
+  { 146, -1, -1, sizeof(::aapt::pb::Value)},
+  { 158, -1, -1, sizeof(::aapt::pb::Item)},
+  { 172, -1, -1, sizeof(::aapt::pb::CompoundValue)},
+  { 185, -1, -1, sizeof(::aapt::pb::Boolean)},
+  { 192, -1, -1, sizeof(::aapt::pb::Reference)},
+  { 205, -1, -1, sizeof(::aapt::pb::Id)},
+  { 211, -1, -1, sizeof(::aapt::pb::String)},
+  { 218, -1, -1, sizeof(::aapt::pb::RawString)},
+  { 225, -1, -1, sizeof(::aapt::pb::StyledString_Span)},
+  { 234, -1, -1, sizeof(::aapt::pb::StyledString)},
+  { 242, -1, -1, sizeof(::aapt::pb::FileReference)},
+  { 250, -1, -1, sizeof(::aapt::pb::Primitive_NullType)},
+  { 256, -1, -1, sizeof(::aapt::pb::Primitive_EmptyType)},
+  { 262, -1, -1, sizeof(::aapt::pb::Primitive)},
+  { 283, -1, -1, sizeof(::aapt::pb::Attribute_Symbol)},
+  { 294, -1, -1, sizeof(::aapt::pb::Attribute)},
+  { 304, -1, -1, sizeof(::aapt::pb::Style_Entry)},
+  { 314, -1, -1, sizeof(::aapt::pb::Style)},
+  { 323, -1, -1, sizeof(::aapt::pb::Styleable_Entry)},
+  { 332, -1, -1, sizeof(::aapt::pb::Styleable)},
+  { 339, -1, -1, sizeof(::aapt::pb::Array_Element)},
+  { 348, -1, -1, sizeof(::aapt::pb::Array)},
+  { 355, -1, -1, sizeof(::aapt::pb::Plural_Entry)},
+  { 365, -1, -1, sizeof(::aapt::pb::Plural)},
+  { 372, -1, -1, sizeof(::aapt::pb::XmlNode)},
+  { 382, -1, -1, sizeof(::aapt::pb::XmlElement)},
+  { 393, -1, -1, sizeof(::aapt::pb::XmlNamespace)},
+  { 402, -1, -1, sizeof(::aapt::pb::XmlAttribute)},
+  { 414, -1, -1, sizeof(::aapt::pb::MacroBody)},
+  { 425, -1, -1, sizeof(::aapt::pb::NamespaceAlias)},
+  { 434, -1, -1, sizeof(::aapt::pb::StyleString_Span)},
+  { 443, -1, -1, sizeof(::aapt::pb::StyleString)},
+  { 451, -1, -1, sizeof(::aapt::pb::UntranslatableSection)},
+};
+
+static const ::_pb::Message* const file_default_instances[] = {
+  &::aapt::pb::_StringPool_default_instance_._instance,
+  &::aapt::pb::_SourcePosition_default_instance_._instance,
+  &::aapt::pb::_Source_default_instance_._instance,
+  &::aapt::pb::_ToolFingerprint_default_instance_._instance,
+  &::aapt::pb::_ResourceTable_default_instance_._instance,
+  &::aapt::pb::_PackageId_default_instance_._instance,
+  &::aapt::pb::_Package_default_instance_._instance,
+  &::aapt::pb::_TypeId_default_instance_._instance,
+  &::aapt::pb::_Type_default_instance_._instance,
+  &::aapt::pb::_Visibility_default_instance_._instance,
+  &::aapt::pb::_AllowNew_default_instance_._instance,
+  &::aapt::pb::_Overlayable_default_instance_._instance,
+  &::aapt::pb::_OverlayableItem_default_instance_._instance,
+  &::aapt::pb::_StagedId_default_instance_._instance,
+  &::aapt::pb::_EntryId_default_instance_._instance,
+  &::aapt::pb::_Entry_default_instance_._instance,
+  &::aapt::pb::_ConfigValue_default_instance_._instance,
+  &::aapt::pb::_Value_default_instance_._instance,
+  &::aapt::pb::_Item_default_instance_._instance,
+  &::aapt::pb::_CompoundValue_default_instance_._instance,
+  &::aapt::pb::_Boolean_default_instance_._instance,
+  &::aapt::pb::_Reference_default_instance_._instance,
+  &::aapt::pb::_Id_default_instance_._instance,
+  &::aapt::pb::_String_default_instance_._instance,
+  &::aapt::pb::_RawString_default_instance_._instance,
+  &::aapt::pb::_StyledString_Span_default_instance_._instance,
+  &::aapt::pb::_StyledString_default_instance_._instance,
+  &::aapt::pb::_FileReference_default_instance_._instance,
+  &::aapt::pb::_Primitive_NullType_default_instance_._instance,
+  &::aapt::pb::_Primitive_EmptyType_default_instance_._instance,
+  &::aapt::pb::_Primitive_default_instance_._instance,
+  &::aapt::pb::_Attribute_Symbol_default_instance_._instance,
+  &::aapt::pb::_Attribute_default_instance_._instance,
+  &::aapt::pb::_Style_Entry_default_instance_._instance,
+  &::aapt::pb::_Style_default_instance_._instance,
+  &::aapt::pb::_Styleable_Entry_default_instance_._instance,
+  &::aapt::pb::_Styleable_default_instance_._instance,
+  &::aapt::pb::_Array_Element_default_instance_._instance,
+  &::aapt::pb::_Array_default_instance_._instance,
+  &::aapt::pb::_Plural_Entry_default_instance_._instance,
+  &::aapt::pb::_Plural_default_instance_._instance,
+  &::aapt::pb::_XmlNode_default_instance_._instance,
+  &::aapt::pb::_XmlElement_default_instance_._instance,
+  &::aapt::pb::_XmlNamespace_default_instance_._instance,
+  &::aapt::pb::_XmlAttribute_default_instance_._instance,
+  &::aapt::pb::_MacroBody_default_instance_._instance,
+  &::aapt::pb::_NamespaceAlias_default_instance_._instance,
+  &::aapt::pb::_StyleString_Span_default_instance_._instance,
+  &::aapt::pb::_StyleString_default_instance_._instance,
+  &::aapt::pb::_UntranslatableSection_default_instance_._instance,
+};
+
+const char descriptor_table_protodef_Resources_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
+  "\n\017Resources.proto\022\007aapt.pb\032\023Configuratio"
+  "n.proto\"\032\n\nStringPool\022\014\n\004data\030\001 \001(\014\"<\n\016S"
+  "ourcePosition\022\023\n\013line_number\030\001 \001(\r\022\025\n\rco"
+  "lumn_number\030\002 \001(\r\"E\n\006Source\022\020\n\010path_idx\030"
+  "\001 \001(\r\022)\n\010position\030\002 \001(\0132\027.aapt.pb.Source"
+  "Position\"0\n\017ToolFingerprint\022\014\n\004tool\030\001 \001("
+  "\t\022\017\n\007version\030\002 \001(\t\"\273\001\n\rResourceTable\022(\n\013"
+  "source_pool\030\001 \001(\0132\023.aapt.pb.StringPool\022!"
+  "\n\007package\030\002 \003(\0132\020.aapt.pb.Package\022)\n\013ove"
+  "rlayable\030\003 \003(\0132\024.aapt.pb.Overlayable\0222\n\020"
+  "tool_fingerprint\030\004 \003(\0132\030.aapt.pb.ToolFin"
+  "gerprint\"\027\n\tPackageId\022\n\n\002id\030\001 \001(\r\"d\n\007Pac"
+  "kage\022&\n\npackage_id\030\001 \001(\0132\022.aapt.pb.Packa"
+  "geId\022\024\n\014package_name\030\002 \001(\t\022\033\n\004type\030\003 \003(\013"
+  "2\r.aapt.pb.Type\"\024\n\006TypeId\022\n\n\002id\030\001 \001(\r\"U\n"
+  "\004Type\022 \n\007type_id\030\001 \001(\0132\017.aapt.pb.TypeId\022"
+  "\014\n\004name\030\002 \001(\t\022\035\n\005entry\030\003 \003(\0132\016.aapt.pb.E"
+  "ntry\"\253\001\n\nVisibility\022(\n\005level\030\001 \001(\0162\031.aap"
+  "t.pb.Visibility.Level\022\037\n\006source\030\002 \001(\0132\017."
+  "aapt.pb.Source\022\017\n\007comment\030\003 \001(\t\022\022\n\nstage"
+  "d_api\030\004 \001(\010\"-\n\005Level\022\013\n\007UNKNOWN\020\000\022\013\n\007PRI"
+  "VATE\020\001\022\n\n\006PUBLIC\020\002\"<\n\010AllowNew\022\037\n\006source"
+  "\030\001 \001(\0132\017.aapt.pb.Source\022\017\n\007comment\030\002 \001(\t"
+  "\"K\n\013Overlayable\022\014\n\004name\030\001 \001(\t\022\037\n\006source\030"
+  "\002 \001(\0132\017.aapt.pb.Source\022\r\n\005actor\030\003 \001(\t\"\225\002"
+  "\n\017OverlayableItem\022\037\n\006source\030\001 \001(\0132\017.aapt"
+  ".pb.Source\022\017\n\007comment\030\002 \001(\t\022/\n\006policy\030\003 "
+  "\003(\0162\037.aapt.pb.OverlayableItem.Policy\022\027\n\017"
+  "overlayable_idx\030\004 \001(\r\"\205\001\n\006Policy\022\010\n\004NONE"
+  "\020\000\022\n\n\006PUBLIC\020\001\022\n\n\006SYSTEM\020\002\022\n\n\006VENDOR\020\003\022\013"
+  "\n\007PRODUCT\020\004\022\r\n\tSIGNATURE\020\005\022\007\n\003ODM\020\006\022\007\n\003O"
+  "EM\020\007\022\t\n\005ACTOR\020\010\022\024\n\020CONFIG_SIGNATURE\020\t\">\n"
+  "\010StagedId\022\037\n\006source\030\001 \001(\0132\017.aapt.pb.Sour"
+  "ce\022\021\n\tstaged_id\030\002 \001(\r\"\025\n\007EntryId\022\n\n\002id\030\001"
+  " \001(\r\"\216\002\n\005Entry\022\"\n\010entry_id\030\001 \001(\0132\020.aapt."
+  "pb.EntryId\022\014\n\004name\030\002 \001(\t\022\'\n\nvisibility\030\003"
+  " \001(\0132\023.aapt.pb.Visibility\022$\n\tallow_new\030\004"
+  " \001(\0132\021.aapt.pb.AllowNew\0222\n\020overlayable_i"
+  "tem\030\005 \001(\0132\030.aapt.pb.OverlayableItem\022*\n\014c"
+  "onfig_value\030\006 \003(\0132\024.aapt.pb.ConfigValue\022"
+  "$\n\tstaged_id\030\007 \001(\0132\021.aapt.pb.StagedId\"T\n"
+  "\013ConfigValue\022&\n\006config\030\001 \001(\0132\026.aapt.pb.C"
+  "onfiguration\022\035\n\005value\030\002 \001(\0132\016.aapt.pb.Va"
+  "lue\"\241\001\n\005Value\022\037\n\006source\030\001 \001(\0132\017.aapt.pb."
+  "Source\022\017\n\007comment\030\002 \001(\t\022\014\n\004weak\030\003 \001(\010\022\035\n"
+  "\004item\030\004 \001(\0132\r.aapt.pb.ItemH\000\0220\n\016compound"
+  "_value\030\005 \001(\0132\026.aapt.pb.CompoundValueH\000B\007"
+  "\n\005value\"\215\002\n\004Item\022!\n\003ref\030\001 \001(\0132\022.aapt.pb."
+  "ReferenceH\000\022\036\n\003str\030\002 \001(\0132\017.aapt.pb.Strin"
+  "gH\000\022%\n\007raw_str\030\003 \001(\0132\022.aapt.pb.RawString"
+  "H\000\022+\n\nstyled_str\030\004 \001(\0132\025.aapt.pb.StyledS"
+  "tringH\000\022&\n\004file\030\005 \001(\0132\026.aapt.pb.FileRefe"
+  "renceH\000\022\031\n\002id\030\006 \001(\0132\013.aapt.pb.IdH\000\022\"\n\004pr"
+  "im\030\007 \001(\0132\022.aapt.pb.PrimitiveH\000B\007\n\005value\""
+  "\357\001\n\rCompoundValue\022\"\n\004attr\030\001 \001(\0132\022.aapt.p"
+  "b.AttributeH\000\022\037\n\005style\030\002 \001(\0132\016.aapt.pb.S"
+  "tyleH\000\022\'\n\tstyleable\030\003 \001(\0132\022.aapt.pb.Styl"
+  "eableH\000\022\037\n\005array\030\004 \001(\0132\016.aapt.pb.ArrayH\000"
+  "\022!\n\006plural\030\005 \001(\0132\017.aapt.pb.PluralH\000\022#\n\005m"
+  "acro\030\006 \001(\0132\022.aapt.pb.MacroBodyH\000B\007\n\005valu"
+  "e\"\030\n\007Boolean\022\r\n\005value\030\001 \001(\010\"\320\001\n\tReferenc"
+  "e\022%\n\004type\030\001 \001(\0162\027.aapt.pb.Reference.Type"
+  "\022\n\n\002id\030\002 \001(\r\022\014\n\004name\030\003 \001(\t\022\017\n\007private\030\004 "
+  "\001(\010\022$\n\nis_dynamic\030\005 \001(\0132\020.aapt.pb.Boolea"
+  "n\022\022\n\ntype_flags\030\006 \001(\r\022\021\n\tallow_raw\030\007 \001(\010"
+  "\"$\n\004Type\022\r\n\tREFERENCE\020\000\022\r\n\tATTRIBUTE\020\001\"\004"
+  "\n\002Id\"\027\n\006String\022\r\n\005value\030\001 \001(\t\"\032\n\tRawStri"
+  "ng\022\r\n\005value\030\001 \001(\t\"\203\001\n\014StyledString\022\r\n\005va"
+  "lue\030\001 \001(\t\022(\n\004span\030\002 \003(\0132\032.aapt.pb.Styled"
+  "String.Span\032:\n\004Span\022\013\n\003tag\030\001 \001(\t\022\022\n\nfirs"
+  "t_char\030\002 \001(\r\022\021\n\tlast_char\030\003 \001(\r\"\205\001\n\rFile"
+  "Reference\022\014\n\004path\030\001 \001(\t\022)\n\004type\030\002 \001(\0162\033."
+  "aapt.pb.FileReference.Type\";\n\004Type\022\013\n\007UN"
+  "KNOWN\020\000\022\007\n\003PNG\020\001\022\016\n\nBINARY_XML\020\002\022\r\n\tPROT"
+  "O_XML\020\003\"\203\004\n\tPrimitive\0221\n\nnull_value\030\001 \001("
+  "\0132\033.aapt.pb.Primitive.NullTypeH\000\0223\n\013empt"
+  "y_value\030\002 \001(\0132\034.aapt.pb.Primitive.EmptyT"
+  "ypeH\000\022\025\n\013float_value\030\003 \001(\002H\000\022\031\n\017dimensio"
+  "n_value\030\r \001(\rH\000\022\030\n\016fraction_value\030\016 \001(\rH"
+  "\000\022\033\n\021int_decimal_value\030\006 \001(\005H\000\022\037\n\025int_he"
+  "xadecimal_value\030\007 \001(\rH\000\022\027\n\rboolean_value"
+  "\030\010 \001(\010H\000\022\033\n\021color_argb8_value\030\t \001(\rH\000\022\032\n"
+  "\020color_rgb8_value\030\n \001(\rH\000\022\033\n\021color_argb4"
+  "_value\030\013 \001(\rH\000\022\032\n\020color_rgb4_value\030\014 \001(\r"
+  "H\000\022(\n\032dimension_value_deprecated\030\004 \001(\002B\002"
+  "\030\001H\000\022\'\n\031fraction_value_deprecated\030\005 \001(\002B"
+  "\002\030\001H\000\032\n\n\010NullType\032\013\n\tEmptyTypeB\r\n\013oneof_"
+  "value\"\220\003\n\tAttribute\022\024\n\014format_flags\030\001 \001("
+  "\r\022\017\n\007min_int\030\002 \001(\005\022\017\n\007max_int\030\003 \001(\005\022)\n\006s"
+  "ymbol\030\004 \003(\0132\031.aapt.pb.Attribute.Symbol\032y"
+  "\n\006Symbol\022\037\n\006source\030\001 \001(\0132\017.aapt.pb.Sourc"
+  "e\022\017\n\007comment\030\002 \001(\t\022 \n\004name\030\003 \001(\0132\022.aapt."
+  "pb.Reference\022\r\n\005value\030\004 \001(\r\022\014\n\004type\030\005 \001("
+  "\r\"\244\001\n\013FormatFlags\022\010\n\004NONE\020\000\022\t\n\003ANY\020\377\377\003\022\r"
+  "\n\tREFERENCE\020\001\022\n\n\006STRING\020\002\022\013\n\007INTEGER\020\004\022\013"
+  "\n\007BOOLEAN\020\010\022\t\n\005COLOR\020\020\022\t\n\005FLOAT\020 \022\r\n\tDIM"
+  "ENSION\020@\022\r\n\010FRACTION\020\200\001\022\n\n\004ENUM\020\200\200\004\022\013\n\005F"
+  "LAGS\020\200\200\010\"\361\001\n\005Style\022\"\n\006parent\030\001 \001(\0132\022.aap"
+  "t.pb.Reference\022&\n\rparent_source\030\002 \001(\0132\017."
+  "aapt.pb.Source\022#\n\005entry\030\003 \003(\0132\024.aapt.pb."
+  "Style.Entry\032w\n\005Entry\022\037\n\006source\030\001 \001(\0132\017.a"
+  "apt.pb.Source\022\017\n\007comment\030\002 \001(\t\022\037\n\003key\030\003 "
+  "\001(\0132\022.aapt.pb.Reference\022\033\n\004item\030\004 \001(\0132\r."
+  "aapt.pb.Item\"\221\001\n\tStyleable\022\'\n\005entry\030\001 \003("
+  "\0132\030.aapt.pb.Styleable.Entry\032[\n\005Entry\022\037\n\006"
+  "source\030\001 \001(\0132\017.aapt.pb.Source\022\017\n\007comment"
+  "\030\002 \001(\t\022 \n\004attr\030\003 \001(\0132\022.aapt.pb.Reference"
+  "\"\212\001\n\005Array\022\'\n\007element\030\001 \003(\0132\026.aapt.pb.Ar"
+  "ray.Element\032X\n\007Element\022\037\n\006source\030\001 \001(\0132\017"
+  ".aapt.pb.Source\022\017\n\007comment\030\002 \001(\t\022\033\n\004item"
+  "\030\003 \001(\0132\r.aapt.pb.Item\"\357\001\n\006Plural\022$\n\005entr"
+  "y\030\001 \003(\0132\025.aapt.pb.Plural.Entry\032|\n\005Entry\022"
+  "\037\n\006source\030\001 \001(\0132\017.aapt.pb.Source\022\017\n\007comm"
+  "ent\030\002 \001(\t\022$\n\005arity\030\003 \001(\0162\025.aapt.pb.Plura"
+  "l.Arity\022\033\n\004item\030\004 \001(\0132\r.aapt.pb.Item\"A\n\005"
+  "Arity\022\010\n\004ZERO\020\000\022\007\n\003ONE\020\001\022\007\n\003TWO\020\002\022\007\n\003FEW"
+  "\020\003\022\010\n\004MANY\020\004\022\t\n\005OTHER\020\005\"r\n\007XmlNode\022&\n\007el"
+  "ement\030\001 \001(\0132\023.aapt.pb.XmlElementH\000\022\016\n\004te"
+  "xt\030\002 \001(\tH\000\022\'\n\006source\030\003 \001(\0132\027.aapt.pb.Sou"
+  "rcePositionB\006\n\004node\"\262\001\n\nXmlElement\0224\n\025na"
+  "mespace_declaration\030\001 \003(\0132\025.aapt.pb.XmlN"
+  "amespace\022\025\n\rnamespace_uri\030\002 \001(\t\022\014\n\004name\030"
+  "\003 \001(\t\022(\n\tattribute\030\004 \003(\0132\025.aapt.pb.XmlAt"
+  "tribute\022\037\n\005child\030\005 \003(\0132\020.aapt.pb.XmlNode"
+  "\"T\n\014XmlNamespace\022\016\n\006prefix\030\001 \001(\t\022\013\n\003uri\030"
+  "\002 \001(\t\022\'\n\006source\030\003 \001(\0132\027.aapt.pb.SourcePo"
+  "sition\"\246\001\n\014XmlAttribute\022\025\n\rnamespace_uri"
+  "\030\001 \001(\t\022\014\n\004name\030\002 \001(\t\022\r\n\005value\030\003 \001(\t\022\'\n\006s"
+  "ource\030\004 \001(\0132\027.aapt.pb.SourcePosition\022\023\n\013"
+  "resource_id\030\005 \001(\r\022$\n\rcompiled_item\030\006 \001(\013"
+  "2\r.aapt.pb.Item\"\347\001\n\tMacroBody\022\022\n\nraw_str"
+  "ing\030\001 \001(\t\022*\n\014style_string\030\002 \001(\0132\024.aapt.p"
+  "b.StyleString\022\?\n\027untranslatable_sections"
+  "\030\003 \003(\0132\036.aapt.pb.UntranslatableSection\0220"
+  "\n\017namespace_stack\030\004 \003(\0132\027.aapt.pb.Namesp"
+  "aceAlias\022\'\n\006source\030\005 \001(\0132\027.aapt.pb.Sourc"
+  "ePosition\"J\n\016NamespaceAlias\022\016\n\006prefix\030\001 "
+  "\001(\t\022\024\n\014package_name\030\002 \001(\t\022\022\n\nis_private\030"
+  "\003 \001(\010\"\202\001\n\013StyleString\022\013\n\003str\030\001 \001(\t\022(\n\005sp"
+  "ans\030\002 \003(\0132\031.aapt.pb.StyleString.Span\032<\n\004"
+  "Span\022\014\n\004name\030\001 \001(\t\022\023\n\013start_index\030\002 \001(\r\022"
+  "\021\n\tend_index\030\003 \001(\r\"\?\n\025UntranslatableSect"
+  "ion\022\023\n\013start_index\030\001 \001(\004\022\021\n\tend_index\030\002 "
+  "\001(\004B\022\n\020com.android.aaptb\006proto3"
+  ;
+static const ::_pbi::DescriptorTable* const descriptor_table_Resources_2eproto_deps[1] = {
+  &::descriptor_table_Configuration_2eproto,
+};
+static ::_pbi::once_flag descriptor_table_Resources_2eproto_once;
+const ::_pbi::DescriptorTable descriptor_table_Resources_2eproto = {
+    false, false, 5751, descriptor_table_protodef_Resources_2eproto,
+    "Resources.proto",
+    &descriptor_table_Resources_2eproto_once, descriptor_table_Resources_2eproto_deps, 1, 50,
+    schemas, file_default_instances, TableStruct_Resources_2eproto::offsets,
+    file_level_metadata_Resources_2eproto, file_level_enum_descriptors_Resources_2eproto,
+    file_level_service_descriptors_Resources_2eproto,
+};
+PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_Resources_2eproto_getter() {
+  return &descriptor_table_Resources_2eproto;
+}
+
+// Force running AddDescriptors() at dynamic initialization time.
+PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_Resources_2eproto(&descriptor_table_Resources_2eproto);
+namespace aapt {
+namespace pb {
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Visibility_Level_descriptor() {
+  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Resources_2eproto);
+  return file_level_enum_descriptors_Resources_2eproto[0];
+}
+bool Visibility_Level_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+    case 2:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+constexpr Visibility_Level Visibility::UNKNOWN;
+constexpr Visibility_Level Visibility::PRIVATE;
+constexpr Visibility_Level Visibility::PUBLIC;
+constexpr Visibility_Level Visibility::Level_MIN;
+constexpr Visibility_Level Visibility::Level_MAX;
+constexpr int Visibility::Level_ARRAYSIZE;
+#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OverlayableItem_Policy_descriptor() {
+  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Resources_2eproto);
+  return file_level_enum_descriptors_Resources_2eproto[1];
+}
+bool OverlayableItem_Policy_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+    case 5:
+    case 6:
+    case 7:
+    case 8:
+    case 9:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+constexpr OverlayableItem_Policy OverlayableItem::NONE;
+constexpr OverlayableItem_Policy OverlayableItem::PUBLIC;
+constexpr OverlayableItem_Policy OverlayableItem::SYSTEM;
+constexpr OverlayableItem_Policy OverlayableItem::VENDOR;
+constexpr OverlayableItem_Policy OverlayableItem::PRODUCT;
+constexpr OverlayableItem_Policy OverlayableItem::SIGNATURE;
+constexpr OverlayableItem_Policy OverlayableItem::ODM;
+constexpr OverlayableItem_Policy OverlayableItem::OEM;
+constexpr OverlayableItem_Policy OverlayableItem::ACTOR;
+constexpr OverlayableItem_Policy OverlayableItem::CONFIG_SIGNATURE;
+constexpr OverlayableItem_Policy OverlayableItem::Policy_MIN;
+constexpr OverlayableItem_Policy OverlayableItem::Policy_MAX;
+constexpr int OverlayableItem::Policy_ARRAYSIZE;
+#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Reference_Type_descriptor() {
+  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Resources_2eproto);
+  return file_level_enum_descriptors_Resources_2eproto[2];
+}
+bool Reference_Type_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+constexpr Reference_Type Reference::REFERENCE;
+constexpr Reference_Type Reference::ATTRIBUTE;
+constexpr Reference_Type Reference::Type_MIN;
+constexpr Reference_Type Reference::Type_MAX;
+constexpr int Reference::Type_ARRAYSIZE;
+#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FileReference_Type_descriptor() {
+  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Resources_2eproto);
+  return file_level_enum_descriptors_Resources_2eproto[3];
+}
+bool FileReference_Type_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+constexpr FileReference_Type FileReference::UNKNOWN;
+constexpr FileReference_Type FileReference::PNG;
+constexpr FileReference_Type FileReference::BINARY_XML;
+constexpr FileReference_Type FileReference::PROTO_XML;
+constexpr FileReference_Type FileReference::Type_MIN;
+constexpr FileReference_Type FileReference::Type_MAX;
+constexpr int FileReference::Type_ARRAYSIZE;
+#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Attribute_FormatFlags_descriptor() {
+  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Resources_2eproto);
+  return file_level_enum_descriptors_Resources_2eproto[4];
+}
+bool Attribute_FormatFlags_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+    case 2:
+    case 4:
+    case 8:
+    case 16:
+    case 32:
+    case 64:
+    case 128:
+    case 65535:
+    case 65536:
+    case 131072:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+constexpr Attribute_FormatFlags Attribute::NONE;
+constexpr Attribute_FormatFlags Attribute::ANY;
+constexpr Attribute_FormatFlags Attribute::REFERENCE;
+constexpr Attribute_FormatFlags Attribute::STRING;
+constexpr Attribute_FormatFlags Attribute::INTEGER;
+constexpr Attribute_FormatFlags Attribute::BOOLEAN;
+constexpr Attribute_FormatFlags Attribute::COLOR;
+constexpr Attribute_FormatFlags Attribute::FLOAT;
+constexpr Attribute_FormatFlags Attribute::DIMENSION;
+constexpr Attribute_FormatFlags Attribute::FRACTION;
+constexpr Attribute_FormatFlags Attribute::ENUM;
+constexpr Attribute_FormatFlags Attribute::FLAGS;
+constexpr Attribute_FormatFlags Attribute::FormatFlags_MIN;
+constexpr Attribute_FormatFlags Attribute::FormatFlags_MAX;
+constexpr int Attribute::FormatFlags_ARRAYSIZE;
+#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Plural_Arity_descriptor() {
+  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Resources_2eproto);
+  return file_level_enum_descriptors_Resources_2eproto[5];
+}
+bool Plural_Arity_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+    case 5:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+constexpr Plural_Arity Plural::ZERO;
+constexpr Plural_Arity Plural::ONE;
+constexpr Plural_Arity Plural::TWO;
+constexpr Plural_Arity Plural::FEW;
+constexpr Plural_Arity Plural::MANY;
+constexpr Plural_Arity Plural::OTHER;
+constexpr Plural_Arity Plural::Arity_MIN;
+constexpr Plural_Arity Plural::Arity_MAX;
+constexpr int Plural::Arity_ARRAYSIZE;
+#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
+
+// ===================================================================
+
+class StringPool::_Internal {
+ public:
+};
+
+StringPool::StringPool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.StringPool)
+}
+StringPool::StringPool(const StringPool& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  StringPool* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.data_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.data_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.data_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_data().empty()) {
+    _this->_impl_.data_.Set(from._internal_data(), 
+      _this->GetArenaForAllocation());
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.StringPool)
+}
+
+inline void StringPool::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.data_){}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.data_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.data_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+StringPool::~StringPool() {
+  // @@protoc_insertion_point(destructor:aapt.pb.StringPool)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void StringPool::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.data_.Destroy();
+}
+
+void StringPool::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void StringPool::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.StringPool)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.data_.ClearToEmpty();
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* StringPool::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // bytes data = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          auto str = _internal_mutable_data();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* StringPool::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.StringPool)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // bytes data = 1;
+  if (!this->_internal_data().empty()) {
+    target = stream->WriteBytesMaybeAliased(
+        1, this->_internal_data(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.StringPool)
+  return target;
+}
+
+size_t StringPool::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.StringPool)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // bytes data = 1;
+  if (!this->_internal_data().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
+        this->_internal_data());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StringPool::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    StringPool::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StringPool::GetClassData() const { return &_class_data_; }
+
+
+void StringPool::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<StringPool*>(&to_msg);
+  auto& from = static_cast<const StringPool&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.StringPool)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_data().empty()) {
+    _this->_internal_set_data(from._internal_data());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void StringPool::CopyFrom(const StringPool& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.StringPool)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StringPool::IsInitialized() const {
+  return true;
+}
+
+void StringPool::InternalSwap(StringPool* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.data_, lhs_arena,
+      &other->_impl_.data_, rhs_arena
+  );
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata StringPool::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[0]);
+}
+
+// ===================================================================
+
+class SourcePosition::_Internal {
+ public:
+};
+
+SourcePosition::SourcePosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.SourcePosition)
+}
+SourcePosition::SourcePosition(const SourcePosition& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  SourcePosition* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.line_number_){}
+    , decltype(_impl_.column_number_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  ::memcpy(&_impl_.line_number_, &from._impl_.line_number_,
+    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.column_number_) -
+    reinterpret_cast<char*>(&_impl_.line_number_)) + sizeof(_impl_.column_number_));
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.SourcePosition)
+}
+
+inline void SourcePosition::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.line_number_){0u}
+    , decltype(_impl_.column_number_){0u}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+}
+
+SourcePosition::~SourcePosition() {
+  // @@protoc_insertion_point(destructor:aapt.pb.SourcePosition)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void SourcePosition::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+}
+
+void SourcePosition::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void SourcePosition::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.SourcePosition)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  ::memset(&_impl_.line_number_, 0, static_cast<size_t>(
+      reinterpret_cast<char*>(&_impl_.column_number_) -
+      reinterpret_cast<char*>(&_impl_.line_number_)) + sizeof(_impl_.column_number_));
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* SourcePosition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // uint32 line_number = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
+          _impl_.line_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 column_number = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
+          _impl_.column_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* SourcePosition::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.SourcePosition)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // uint32 line_number = 1;
+  if (this->_internal_line_number() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_line_number(), target);
+  }
+
+  // uint32 column_number = 2;
+  if (this->_internal_column_number() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_column_number(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.SourcePosition)
+  return target;
+}
+
+size_t SourcePosition::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.SourcePosition)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // uint32 line_number = 1;
+  if (this->_internal_line_number() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_line_number());
+  }
+
+  // uint32 column_number = 2;
+  if (this->_internal_column_number() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_column_number());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SourcePosition::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    SourcePosition::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SourcePosition::GetClassData() const { return &_class_data_; }
+
+
+void SourcePosition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<SourcePosition*>(&to_msg);
+  auto& from = static_cast<const SourcePosition&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.SourcePosition)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (from._internal_line_number() != 0) {
+    _this->_internal_set_line_number(from._internal_line_number());
+  }
+  if (from._internal_column_number() != 0) {
+    _this->_internal_set_column_number(from._internal_column_number());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void SourcePosition::CopyFrom(const SourcePosition& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.SourcePosition)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool SourcePosition::IsInitialized() const {
+  return true;
+}
+
+void SourcePosition::InternalSwap(SourcePosition* other) {
+  using std::swap;
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(SourcePosition, _impl_.column_number_)
+      + sizeof(SourcePosition::_impl_.column_number_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(SourcePosition, _impl_.line_number_)>(
+          reinterpret_cast<char*>(&_impl_.line_number_),
+          reinterpret_cast<char*>(&other->_impl_.line_number_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata SourcePosition::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[1]);
+}
+
+// ===================================================================
+
+class Source::_Internal {
+ public:
+  static const ::aapt::pb::SourcePosition& position(const Source* msg);
+};
+
+const ::aapt::pb::SourcePosition&
+Source::_Internal::position(const Source* msg) {
+  return *msg->_impl_.position_;
+}
+Source::Source(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Source)
+}
+Source::Source(const Source& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Source* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.position_){nullptr}
+    , decltype(_impl_.path_idx_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  if (from._internal_has_position()) {
+    _this->_impl_.position_ = new ::aapt::pb::SourcePosition(*from._impl_.position_);
+  }
+  _this->_impl_.path_idx_ = from._impl_.path_idx_;
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Source)
+}
+
+inline void Source::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.position_){nullptr}
+    , decltype(_impl_.path_idx_){0u}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+}
+
+Source::~Source() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Source)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Source::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  if (this != internal_default_instance()) delete _impl_.position_;
+}
+
+void Source::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Source::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Source)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
+    delete _impl_.position_;
+  }
+  _impl_.position_ = nullptr;
+  _impl_.path_idx_ = 0u;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Source::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // uint32 path_idx = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
+          _impl_.path_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.SourcePosition position = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Source::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Source)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // uint32 path_idx = 1;
+  if (this->_internal_path_idx() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_path_idx(), target);
+  }
+
+  // .aapt.pb.SourcePosition position = 2;
+  if (this->_internal_has_position()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(2, _Internal::position(this),
+        _Internal::position(this).GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Source)
+  return target;
+}
+
+size_t Source::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Source)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // .aapt.pb.SourcePosition position = 2;
+  if (this->_internal_has_position()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.position_);
+  }
+
+  // uint32 path_idx = 1;
+  if (this->_internal_path_idx() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_path_idx());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Source::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Source::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Source::GetClassData() const { return &_class_data_; }
+
+
+void Source::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Source*>(&to_msg);
+  auto& from = static_cast<const Source&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Source)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (from._internal_has_position()) {
+    _this->_internal_mutable_position()->::aapt::pb::SourcePosition::MergeFrom(
+        from._internal_position());
+  }
+  if (from._internal_path_idx() != 0) {
+    _this->_internal_set_path_idx(from._internal_path_idx());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Source::CopyFrom(const Source& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Source)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Source::IsInitialized() const {
+  return true;
+}
+
+void Source::InternalSwap(Source* other) {
+  using std::swap;
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(Source, _impl_.path_idx_)
+      + sizeof(Source::_impl_.path_idx_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(Source, _impl_.position_)>(
+          reinterpret_cast<char*>(&_impl_.position_),
+          reinterpret_cast<char*>(&other->_impl_.position_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Source::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[2]);
+}
+
+// ===================================================================
+
+class ToolFingerprint::_Internal {
+ public:
+};
+
+ToolFingerprint::ToolFingerprint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.ToolFingerprint)
+}
+ToolFingerprint::ToolFingerprint(const ToolFingerprint& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  ToolFingerprint* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.tool_){}
+    , decltype(_impl_.version_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.tool_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.tool_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_tool().empty()) {
+    _this->_impl_.tool_.Set(from._internal_tool(), 
+      _this->GetArenaForAllocation());
+  }
+  _impl_.version_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.version_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_version().empty()) {
+    _this->_impl_.version_.Set(from._internal_version(), 
+      _this->GetArenaForAllocation());
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.ToolFingerprint)
+}
+
+inline void ToolFingerprint::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.tool_){}
+    , decltype(_impl_.version_){}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.tool_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.tool_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.version_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.version_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+ToolFingerprint::~ToolFingerprint() {
+  // @@protoc_insertion_point(destructor:aapt.pb.ToolFingerprint)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void ToolFingerprint::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.tool_.Destroy();
+  _impl_.version_.Destroy();
+}
+
+void ToolFingerprint::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void ToolFingerprint::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.ToolFingerprint)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.tool_.ClearToEmpty();
+  _impl_.version_.ClearToEmpty();
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* ToolFingerprint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // string tool = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          auto str = _internal_mutable_tool();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.ToolFingerprint.tool"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string version = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          auto str = _internal_mutable_version();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.ToolFingerprint.version"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* ToolFingerprint::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.ToolFingerprint)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // string tool = 1;
+  if (!this->_internal_tool().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_tool().data(), static_cast<int>(this->_internal_tool().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.ToolFingerprint.tool");
+    target = stream->WriteStringMaybeAliased(
+        1, this->_internal_tool(), target);
+  }
+
+  // string version = 2;
+  if (!this->_internal_version().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.ToolFingerprint.version");
+    target = stream->WriteStringMaybeAliased(
+        2, this->_internal_version(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.ToolFingerprint)
+  return target;
+}
+
+size_t ToolFingerprint::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.ToolFingerprint)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string tool = 1;
+  if (!this->_internal_tool().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_tool());
+  }
+
+  // string version = 2;
+  if (!this->_internal_version().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_version());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ToolFingerprint::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    ToolFingerprint::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ToolFingerprint::GetClassData() const { return &_class_data_; }
+
+
+void ToolFingerprint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<ToolFingerprint*>(&to_msg);
+  auto& from = static_cast<const ToolFingerprint&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.ToolFingerprint)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_tool().empty()) {
+    _this->_internal_set_tool(from._internal_tool());
+  }
+  if (!from._internal_version().empty()) {
+    _this->_internal_set_version(from._internal_version());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void ToolFingerprint::CopyFrom(const ToolFingerprint& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.ToolFingerprint)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool ToolFingerprint::IsInitialized() const {
+  return true;
+}
+
+void ToolFingerprint::InternalSwap(ToolFingerprint* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.tool_, lhs_arena,
+      &other->_impl_.tool_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.version_, lhs_arena,
+      &other->_impl_.version_, rhs_arena
+  );
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata ToolFingerprint::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[3]);
+}
+
+// ===================================================================
+
+class ResourceTable::_Internal {
+ public:
+  static const ::aapt::pb::StringPool& source_pool(const ResourceTable* msg);
+};
+
+const ::aapt::pb::StringPool&
+ResourceTable::_Internal::source_pool(const ResourceTable* msg) {
+  return *msg->_impl_.source_pool_;
+}
+ResourceTable::ResourceTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.ResourceTable)
+}
+ResourceTable::ResourceTable(const ResourceTable& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  ResourceTable* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.package_){from._impl_.package_}
+    , decltype(_impl_.overlayable_){from._impl_.overlayable_}
+    , decltype(_impl_.tool_fingerprint_){from._impl_.tool_fingerprint_}
+    , decltype(_impl_.source_pool_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  if (from._internal_has_source_pool()) {
+    _this->_impl_.source_pool_ = new ::aapt::pb::StringPool(*from._impl_.source_pool_);
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.ResourceTable)
+}
+
+inline void ResourceTable::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.package_){arena}
+    , decltype(_impl_.overlayable_){arena}
+    , decltype(_impl_.tool_fingerprint_){arena}
+    , decltype(_impl_.source_pool_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+}
+
+ResourceTable::~ResourceTable() {
+  // @@protoc_insertion_point(destructor:aapt.pb.ResourceTable)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void ResourceTable::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.package_.~RepeatedPtrField();
+  _impl_.overlayable_.~RepeatedPtrField();
+  _impl_.tool_fingerprint_.~RepeatedPtrField();
+  if (this != internal_default_instance()) delete _impl_.source_pool_;
+}
+
+void ResourceTable::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void ResourceTable::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.ResourceTable)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.package_.Clear();
+  _impl_.overlayable_.Clear();
+  _impl_.tool_fingerprint_.Clear();
+  if (GetArenaForAllocation() == nullptr && _impl_.source_pool_ != nullptr) {
+    delete _impl_.source_pool_;
+  }
+  _impl_.source_pool_ = nullptr;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* ResourceTable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.StringPool source_pool = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr = ctx->ParseMessage(_internal_mutable_source_pool(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // repeated .aapt.pb.Package package = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          ptr -= 1;
+          do {
+            ptr += 1;
+            ptr = ctx->ParseMessage(_internal_add_package(), ptr);
+            CHK_(ptr);
+            if (!ctx->DataAvailable(ptr)) break;
+          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // repeated .aapt.pb.Overlayable overlayable = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          ptr -= 1;
+          do {
+            ptr += 1;
+            ptr = ctx->ParseMessage(_internal_add_overlayable(), ptr);
+            CHK_(ptr);
+            if (!ctx->DataAvailable(ptr)) break;
+          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // repeated .aapt.pb.ToolFingerprint tool_fingerprint = 4;
+      case 4:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
+          ptr -= 1;
+          do {
+            ptr += 1;
+            ptr = ctx->ParseMessage(_internal_add_tool_fingerprint(), ptr);
+            CHK_(ptr);
+            if (!ctx->DataAvailable(ptr)) break;
+          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* ResourceTable::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.ResourceTable)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.StringPool source_pool = 1;
+  if (this->_internal_has_source_pool()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(1, _Internal::source_pool(this),
+        _Internal::source_pool(this).GetCachedSize(), target, stream);
+  }
+
+  // repeated .aapt.pb.Package package = 2;
+  for (unsigned i = 0,
+      n = static_cast<unsigned>(this->_internal_package_size()); i < n; i++) {
+    const auto& repfield = this->_internal_package(i);
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
+  }
+
+  // repeated .aapt.pb.Overlayable overlayable = 3;
+  for (unsigned i = 0,
+      n = static_cast<unsigned>(this->_internal_overlayable_size()); i < n; i++) {
+    const auto& repfield = this->_internal_overlayable(i);
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
+  }
+
+  // repeated .aapt.pb.ToolFingerprint tool_fingerprint = 4;
+  for (unsigned i = 0,
+      n = static_cast<unsigned>(this->_internal_tool_fingerprint_size()); i < n; i++) {
+    const auto& repfield = this->_internal_tool_fingerprint(i);
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.ResourceTable)
+  return target;
+}
+
+size_t ResourceTable::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.ResourceTable)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // repeated .aapt.pb.Package package = 2;
+  total_size += 1UL * this->_internal_package_size();
+  for (const auto& msg : this->_impl_.package_) {
+    total_size +=
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
+  }
+
+  // repeated .aapt.pb.Overlayable overlayable = 3;
+  total_size += 1UL * this->_internal_overlayable_size();
+  for (const auto& msg : this->_impl_.overlayable_) {
+    total_size +=
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
+  }
+
+  // repeated .aapt.pb.ToolFingerprint tool_fingerprint = 4;
+  total_size += 1UL * this->_internal_tool_fingerprint_size();
+  for (const auto& msg : this->_impl_.tool_fingerprint_) {
+    total_size +=
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
+  }
+
+  // .aapt.pb.StringPool source_pool = 1;
+  if (this->_internal_has_source_pool()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.source_pool_);
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResourceTable::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    ResourceTable::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResourceTable::GetClassData() const { return &_class_data_; }
+
+
+void ResourceTable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<ResourceTable*>(&to_msg);
+  auto& from = static_cast<const ResourceTable&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.ResourceTable)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  _this->_impl_.package_.MergeFrom(from._impl_.package_);
+  _this->_impl_.overlayable_.MergeFrom(from._impl_.overlayable_);
+  _this->_impl_.tool_fingerprint_.MergeFrom(from._impl_.tool_fingerprint_);
+  if (from._internal_has_source_pool()) {
+    _this->_internal_mutable_source_pool()->::aapt::pb::StringPool::MergeFrom(
+        from._internal_source_pool());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void ResourceTable::CopyFrom(const ResourceTable& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.ResourceTable)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool ResourceTable::IsInitialized() const {
+  return true;
+}
+
+void ResourceTable::InternalSwap(ResourceTable* other) {
+  using std::swap;
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  _impl_.package_.InternalSwap(&other->_impl_.package_);
+  _impl_.overlayable_.InternalSwap(&other->_impl_.overlayable_);
+  _impl_.tool_fingerprint_.InternalSwap(&other->_impl_.tool_fingerprint_);
+  swap(_impl_.source_pool_, other->_impl_.source_pool_);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata ResourceTable::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[4]);
+}
+
+// ===================================================================
+
+class PackageId::_Internal {
+ public:
+};
+
+PackageId::PackageId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.PackageId)
+}
+PackageId::PackageId(const PackageId& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  PackageId* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.id_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _this->_impl_.id_ = from._impl_.id_;
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.PackageId)
+}
+
+inline void PackageId::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.id_){0u}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+}
+
+PackageId::~PackageId() {
+  // @@protoc_insertion_point(destructor:aapt.pb.PackageId)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void PackageId::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+}
+
+void PackageId::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void PackageId::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.PackageId)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.id_ = 0u;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* PackageId::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // uint32 id = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
+          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* PackageId::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.PackageId)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // uint32 id = 1;
+  if (this->_internal_id() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.PackageId)
+  return target;
+}
+
+size_t PackageId::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.PackageId)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // uint32 id = 1;
+  if (this->_internal_id() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PackageId::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    PackageId::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PackageId::GetClassData() const { return &_class_data_; }
+
+
+void PackageId::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<PackageId*>(&to_msg);
+  auto& from = static_cast<const PackageId&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.PackageId)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (from._internal_id() != 0) {
+    _this->_internal_set_id(from._internal_id());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void PackageId::CopyFrom(const PackageId& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.PackageId)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool PackageId::IsInitialized() const {
+  return true;
+}
+
+void PackageId::InternalSwap(PackageId* other) {
+  using std::swap;
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  swap(_impl_.id_, other->_impl_.id_);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata PackageId::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[5]);
+}
+
+// ===================================================================
+
+class Package::_Internal {
+ public:
+  static const ::aapt::pb::PackageId& package_id(const Package* msg);
+};
+
+const ::aapt::pb::PackageId&
+Package::_Internal::package_id(const Package* msg) {
+  return *msg->_impl_.package_id_;
+}
+Package::Package(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Package)
+}
+Package::Package(const Package& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Package* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.type_){from._impl_.type_}
+    , decltype(_impl_.package_name_){}
+    , decltype(_impl_.package_id_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.package_name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.package_name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_package_name().empty()) {
+    _this->_impl_.package_name_.Set(from._internal_package_name(), 
+      _this->GetArenaForAllocation());
+  }
+  if (from._internal_has_package_id()) {
+    _this->_impl_.package_id_ = new ::aapt::pb::PackageId(*from._impl_.package_id_);
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Package)
+}
+
+inline void Package::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.type_){arena}
+    , decltype(_impl_.package_name_){}
+    , decltype(_impl_.package_id_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.package_name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.package_name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+Package::~Package() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Package)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Package::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.type_.~RepeatedPtrField();
+  _impl_.package_name_.Destroy();
+  if (this != internal_default_instance()) delete _impl_.package_id_;
+}
+
+void Package::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Package::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Package)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.type_.Clear();
+  _impl_.package_name_.ClearToEmpty();
+  if (GetArenaForAllocation() == nullptr && _impl_.package_id_ != nullptr) {
+    delete _impl_.package_id_;
+  }
+  _impl_.package_id_ = nullptr;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Package::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.PackageId package_id = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr = ctx->ParseMessage(_internal_mutable_package_id(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string package_name = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          auto str = _internal_mutable_package_name();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.Package.package_name"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // repeated .aapt.pb.Type type = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          ptr -= 1;
+          do {
+            ptr += 1;
+            ptr = ctx->ParseMessage(_internal_add_type(), ptr);
+            CHK_(ptr);
+            if (!ctx->DataAvailable(ptr)) break;
+          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Package::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Package)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.PackageId package_id = 1;
+  if (this->_internal_has_package_id()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(1, _Internal::package_id(this),
+        _Internal::package_id(this).GetCachedSize(), target, stream);
+  }
+
+  // string package_name = 2;
+  if (!this->_internal_package_name().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_package_name().data(), static_cast<int>(this->_internal_package_name().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.Package.package_name");
+    target = stream->WriteStringMaybeAliased(
+        2, this->_internal_package_name(), target);
+  }
+
+  // repeated .aapt.pb.Type type = 3;
+  for (unsigned i = 0,
+      n = static_cast<unsigned>(this->_internal_type_size()); i < n; i++) {
+    const auto& repfield = this->_internal_type(i);
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Package)
+  return target;
+}
+
+size_t Package::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Package)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // repeated .aapt.pb.Type type = 3;
+  total_size += 1UL * this->_internal_type_size();
+  for (const auto& msg : this->_impl_.type_) {
+    total_size +=
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
+  }
+
+  // string package_name = 2;
+  if (!this->_internal_package_name().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_package_name());
+  }
+
+  // .aapt.pb.PackageId package_id = 1;
+  if (this->_internal_has_package_id()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.package_id_);
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Package::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Package::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Package::GetClassData() const { return &_class_data_; }
+
+
+void Package::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Package*>(&to_msg);
+  auto& from = static_cast<const Package&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Package)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  _this->_impl_.type_.MergeFrom(from._impl_.type_);
+  if (!from._internal_package_name().empty()) {
+    _this->_internal_set_package_name(from._internal_package_name());
+  }
+  if (from._internal_has_package_id()) {
+    _this->_internal_mutable_package_id()->::aapt::pb::PackageId::MergeFrom(
+        from._internal_package_id());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Package::CopyFrom(const Package& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Package)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Package::IsInitialized() const {
+  return true;
+}
+
+void Package::InternalSwap(Package* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  _impl_.type_.InternalSwap(&other->_impl_.type_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.package_name_, lhs_arena,
+      &other->_impl_.package_name_, rhs_arena
+  );
+  swap(_impl_.package_id_, other->_impl_.package_id_);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Package::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[6]);
+}
+
+// ===================================================================
+
+class TypeId::_Internal {
+ public:
+};
+
+TypeId::TypeId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.TypeId)
+}
+TypeId::TypeId(const TypeId& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  TypeId* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.id_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _this->_impl_.id_ = from._impl_.id_;
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.TypeId)
+}
+
+inline void TypeId::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.id_){0u}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+}
+
+TypeId::~TypeId() {
+  // @@protoc_insertion_point(destructor:aapt.pb.TypeId)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void TypeId::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+}
+
+void TypeId::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void TypeId::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.TypeId)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.id_ = 0u;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* TypeId::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // uint32 id = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
+          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* TypeId::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.TypeId)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // uint32 id = 1;
+  if (this->_internal_id() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.TypeId)
+  return target;
+}
+
+size_t TypeId::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.TypeId)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // uint32 id = 1;
+  if (this->_internal_id() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TypeId::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    TypeId::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TypeId::GetClassData() const { return &_class_data_; }
+
+
+void TypeId::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<TypeId*>(&to_msg);
+  auto& from = static_cast<const TypeId&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.TypeId)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (from._internal_id() != 0) {
+    _this->_internal_set_id(from._internal_id());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void TypeId::CopyFrom(const TypeId& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.TypeId)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool TypeId::IsInitialized() const {
+  return true;
+}
+
+void TypeId::InternalSwap(TypeId* other) {
+  using std::swap;
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  swap(_impl_.id_, other->_impl_.id_);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata TypeId::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[7]);
+}
+
+// ===================================================================
+
+class Type::_Internal {
+ public:
+  static const ::aapt::pb::TypeId& type_id(const Type* msg);
+};
+
+const ::aapt::pb::TypeId&
+Type::_Internal::type_id(const Type* msg) {
+  return *msg->_impl_.type_id_;
+}
+Type::Type(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Type)
+}
+Type::Type(const Type& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Type* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.entry_){from._impl_.entry_}
+    , decltype(_impl_.name_){}
+    , decltype(_impl_.type_id_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_name().empty()) {
+    _this->_impl_.name_.Set(from._internal_name(), 
+      _this->GetArenaForAllocation());
+  }
+  if (from._internal_has_type_id()) {
+    _this->_impl_.type_id_ = new ::aapt::pb::TypeId(*from._impl_.type_id_);
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Type)
+}
+
+inline void Type::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.entry_){arena}
+    , decltype(_impl_.name_){}
+    , decltype(_impl_.type_id_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+Type::~Type() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Type)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Type::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.entry_.~RepeatedPtrField();
+  _impl_.name_.Destroy();
+  if (this != internal_default_instance()) delete _impl_.type_id_;
+}
+
+void Type::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Type::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Type)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.entry_.Clear();
+  _impl_.name_.ClearToEmpty();
+  if (GetArenaForAllocation() == nullptr && _impl_.type_id_ != nullptr) {
+    delete _impl_.type_id_;
+  }
+  _impl_.type_id_ = nullptr;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Type::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.TypeId type_id = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr = ctx->ParseMessage(_internal_mutable_type_id(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string name = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          auto str = _internal_mutable_name();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.Type.name"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // repeated .aapt.pb.Entry entry = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          ptr -= 1;
+          do {
+            ptr += 1;
+            ptr = ctx->ParseMessage(_internal_add_entry(), ptr);
+            CHK_(ptr);
+            if (!ctx->DataAvailable(ptr)) break;
+          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Type::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Type)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.TypeId type_id = 1;
+  if (this->_internal_has_type_id()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(1, _Internal::type_id(this),
+        _Internal::type_id(this).GetCachedSize(), target, stream);
+  }
+
+  // string name = 2;
+  if (!this->_internal_name().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.Type.name");
+    target = stream->WriteStringMaybeAliased(
+        2, this->_internal_name(), target);
+  }
+
+  // repeated .aapt.pb.Entry entry = 3;
+  for (unsigned i = 0,
+      n = static_cast<unsigned>(this->_internal_entry_size()); i < n; i++) {
+    const auto& repfield = this->_internal_entry(i);
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Type)
+  return target;
+}
+
+size_t Type::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Type)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // repeated .aapt.pb.Entry entry = 3;
+  total_size += 1UL * this->_internal_entry_size();
+  for (const auto& msg : this->_impl_.entry_) {
+    total_size +=
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
+  }
+
+  // string name = 2;
+  if (!this->_internal_name().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_name());
+  }
+
+  // .aapt.pb.TypeId type_id = 1;
+  if (this->_internal_has_type_id()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.type_id_);
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Type::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Type::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Type::GetClassData() const { return &_class_data_; }
+
+
+void Type::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Type*>(&to_msg);
+  auto& from = static_cast<const Type&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Type)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  _this->_impl_.entry_.MergeFrom(from._impl_.entry_);
+  if (!from._internal_name().empty()) {
+    _this->_internal_set_name(from._internal_name());
+  }
+  if (from._internal_has_type_id()) {
+    _this->_internal_mutable_type_id()->::aapt::pb::TypeId::MergeFrom(
+        from._internal_type_id());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Type::CopyFrom(const Type& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Type)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Type::IsInitialized() const {
+  return true;
+}
+
+void Type::InternalSwap(Type* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  _impl_.entry_.InternalSwap(&other->_impl_.entry_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.name_, lhs_arena,
+      &other->_impl_.name_, rhs_arena
+  );
+  swap(_impl_.type_id_, other->_impl_.type_id_);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Type::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[8]);
+}
+
+// ===================================================================
+
+class Visibility::_Internal {
+ public:
+  static const ::aapt::pb::Source& source(const Visibility* msg);
+};
+
+const ::aapt::pb::Source&
+Visibility::_Internal::source(const Visibility* msg) {
+  return *msg->_impl_.source_;
+}
+Visibility::Visibility(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Visibility)
+}
+Visibility::Visibility(const Visibility& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Visibility* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.comment_){}
+    , decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.level_){}
+    , decltype(_impl_.staged_api_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.comment_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_comment().empty()) {
+    _this->_impl_.comment_.Set(from._internal_comment(), 
+      _this->GetArenaForAllocation());
+  }
+  if (from._internal_has_source()) {
+    _this->_impl_.source_ = new ::aapt::pb::Source(*from._impl_.source_);
+  }
+  ::memcpy(&_impl_.level_, &from._impl_.level_,
+    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.staged_api_) -
+    reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.staged_api_));
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Visibility)
+}
+
+inline void Visibility::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.comment_){}
+    , decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.level_){0}
+    , decltype(_impl_.staged_api_){false}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.comment_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+Visibility::~Visibility() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Visibility)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Visibility::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.comment_.Destroy();
+  if (this != internal_default_instance()) delete _impl_.source_;
+}
+
+void Visibility::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Visibility::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Visibility)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.comment_.ClearToEmpty();
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+  ::memset(&_impl_.level_, 0, static_cast<size_t>(
+      reinterpret_cast<char*>(&_impl_.staged_api_) -
+      reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.staged_api_));
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Visibility::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.Visibility.Level level = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
+          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+          _internal_set_level(static_cast<::aapt::pb::Visibility_Level>(val));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Source source = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string comment = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          auto str = _internal_mutable_comment();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.Visibility.comment"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // bool staged_api = 4;
+      case 4:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
+          _impl_.staged_api_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Visibility::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Visibility)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.Visibility.Level level = 1;
+  if (this->_internal_level() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteEnumToArray(
+      1, this->_internal_level(), target);
+  }
+
+  // .aapt.pb.Source source = 2;
+  if (this->_internal_has_source()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(2, _Internal::source(this),
+        _Internal::source(this).GetCachedSize(), target, stream);
+  }
+
+  // string comment = 3;
+  if (!this->_internal_comment().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_comment().data(), static_cast<int>(this->_internal_comment().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.Visibility.comment");
+    target = stream->WriteStringMaybeAliased(
+        3, this->_internal_comment(), target);
+  }
+
+  // bool staged_api = 4;
+  if (this->_internal_staged_api() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_staged_api(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Visibility)
+  return target;
+}
+
+size_t Visibility::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Visibility)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string comment = 3;
+  if (!this->_internal_comment().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_comment());
+  }
+
+  // .aapt.pb.Source source = 2;
+  if (this->_internal_has_source()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.source_);
+  }
+
+  // .aapt.pb.Visibility.Level level = 1;
+  if (this->_internal_level() != 0) {
+    total_size += 1 +
+      ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
+  }
+
+  // bool staged_api = 4;
+  if (this->_internal_staged_api() != 0) {
+    total_size += 1 + 1;
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Visibility::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Visibility::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Visibility::GetClassData() const { return &_class_data_; }
+
+
+void Visibility::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Visibility*>(&to_msg);
+  auto& from = static_cast<const Visibility&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Visibility)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_comment().empty()) {
+    _this->_internal_set_comment(from._internal_comment());
+  }
+  if (from._internal_has_source()) {
+    _this->_internal_mutable_source()->::aapt::pb::Source::MergeFrom(
+        from._internal_source());
+  }
+  if (from._internal_level() != 0) {
+    _this->_internal_set_level(from._internal_level());
+  }
+  if (from._internal_staged_api() != 0) {
+    _this->_internal_set_staged_api(from._internal_staged_api());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Visibility::CopyFrom(const Visibility& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Visibility)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Visibility::IsInitialized() const {
+  return true;
+}
+
+void Visibility::InternalSwap(Visibility* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.comment_, lhs_arena,
+      &other->_impl_.comment_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(Visibility, _impl_.staged_api_)
+      + sizeof(Visibility::_impl_.staged_api_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(Visibility, _impl_.source_)>(
+          reinterpret_cast<char*>(&_impl_.source_),
+          reinterpret_cast<char*>(&other->_impl_.source_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Visibility::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[9]);
+}
+
+// ===================================================================
+
+class AllowNew::_Internal {
+ public:
+  static const ::aapt::pb::Source& source(const AllowNew* msg);
+};
+
+const ::aapt::pb::Source&
+AllowNew::_Internal::source(const AllowNew* msg) {
+  return *msg->_impl_.source_;
+}
+AllowNew::AllowNew(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.AllowNew)
+}
+AllowNew::AllowNew(const AllowNew& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  AllowNew* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.comment_){}
+    , decltype(_impl_.source_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.comment_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_comment().empty()) {
+    _this->_impl_.comment_.Set(from._internal_comment(), 
+      _this->GetArenaForAllocation());
+  }
+  if (from._internal_has_source()) {
+    _this->_impl_.source_ = new ::aapt::pb::Source(*from._impl_.source_);
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.AllowNew)
+}
+
+inline void AllowNew::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.comment_){}
+    , decltype(_impl_.source_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.comment_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+AllowNew::~AllowNew() {
+  // @@protoc_insertion_point(destructor:aapt.pb.AllowNew)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void AllowNew::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.comment_.Destroy();
+  if (this != internal_default_instance()) delete _impl_.source_;
+}
+
+void AllowNew::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void AllowNew::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.AllowNew)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.comment_.ClearToEmpty();
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* AllowNew::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.Source source = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string comment = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          auto str = _internal_mutable_comment();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.AllowNew.comment"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* AllowNew::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.AllowNew)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.Source source = 1;
+  if (this->_internal_has_source()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(1, _Internal::source(this),
+        _Internal::source(this).GetCachedSize(), target, stream);
+  }
+
+  // string comment = 2;
+  if (!this->_internal_comment().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_comment().data(), static_cast<int>(this->_internal_comment().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.AllowNew.comment");
+    target = stream->WriteStringMaybeAliased(
+        2, this->_internal_comment(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.AllowNew)
+  return target;
+}
+
+size_t AllowNew::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.AllowNew)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string comment = 2;
+  if (!this->_internal_comment().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_comment());
+  }
+
+  // .aapt.pb.Source source = 1;
+  if (this->_internal_has_source()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.source_);
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AllowNew::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    AllowNew::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AllowNew::GetClassData() const { return &_class_data_; }
+
+
+void AllowNew::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<AllowNew*>(&to_msg);
+  auto& from = static_cast<const AllowNew&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.AllowNew)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_comment().empty()) {
+    _this->_internal_set_comment(from._internal_comment());
+  }
+  if (from._internal_has_source()) {
+    _this->_internal_mutable_source()->::aapt::pb::Source::MergeFrom(
+        from._internal_source());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void AllowNew::CopyFrom(const AllowNew& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.AllowNew)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool AllowNew::IsInitialized() const {
+  return true;
+}
+
+void AllowNew::InternalSwap(AllowNew* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.comment_, lhs_arena,
+      &other->_impl_.comment_, rhs_arena
+  );
+  swap(_impl_.source_, other->_impl_.source_);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata AllowNew::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[10]);
+}
+
+// ===================================================================
+
+class Overlayable::_Internal {
+ public:
+  static const ::aapt::pb::Source& source(const Overlayable* msg);
+};
+
+const ::aapt::pb::Source&
+Overlayable::_Internal::source(const Overlayable* msg) {
+  return *msg->_impl_.source_;
+}
+Overlayable::Overlayable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Overlayable)
+}
+Overlayable::Overlayable(const Overlayable& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Overlayable* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.name_){}
+    , decltype(_impl_.actor_){}
+    , decltype(_impl_.source_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_name().empty()) {
+    _this->_impl_.name_.Set(from._internal_name(), 
+      _this->GetArenaForAllocation());
+  }
+  _impl_.actor_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.actor_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_actor().empty()) {
+    _this->_impl_.actor_.Set(from._internal_actor(), 
+      _this->GetArenaForAllocation());
+  }
+  if (from._internal_has_source()) {
+    _this->_impl_.source_ = new ::aapt::pb::Source(*from._impl_.source_);
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Overlayable)
+}
+
+inline void Overlayable::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.name_){}
+    , decltype(_impl_.actor_){}
+    , decltype(_impl_.source_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.actor_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.actor_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+Overlayable::~Overlayable() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Overlayable)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Overlayable::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.name_.Destroy();
+  _impl_.actor_.Destroy();
+  if (this != internal_default_instance()) delete _impl_.source_;
+}
+
+void Overlayable::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Overlayable::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Overlayable)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.name_.ClearToEmpty();
+  _impl_.actor_.ClearToEmpty();
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Overlayable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // string name = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          auto str = _internal_mutable_name();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.Overlayable.name"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Source source = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string actor = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          auto str = _internal_mutable_actor();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.Overlayable.actor"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Overlayable::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Overlayable)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // string name = 1;
+  if (!this->_internal_name().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.Overlayable.name");
+    target = stream->WriteStringMaybeAliased(
+        1, this->_internal_name(), target);
+  }
+
+  // .aapt.pb.Source source = 2;
+  if (this->_internal_has_source()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(2, _Internal::source(this),
+        _Internal::source(this).GetCachedSize(), target, stream);
+  }
+
+  // string actor = 3;
+  if (!this->_internal_actor().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_actor().data(), static_cast<int>(this->_internal_actor().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.Overlayable.actor");
+    target = stream->WriteStringMaybeAliased(
+        3, this->_internal_actor(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Overlayable)
+  return target;
+}
+
+size_t Overlayable::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Overlayable)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string name = 1;
+  if (!this->_internal_name().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_name());
+  }
+
+  // string actor = 3;
+  if (!this->_internal_actor().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_actor());
+  }
+
+  // .aapt.pb.Source source = 2;
+  if (this->_internal_has_source()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.source_);
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Overlayable::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Overlayable::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Overlayable::GetClassData() const { return &_class_data_; }
+
+
+void Overlayable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Overlayable*>(&to_msg);
+  auto& from = static_cast<const Overlayable&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Overlayable)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_name().empty()) {
+    _this->_internal_set_name(from._internal_name());
+  }
+  if (!from._internal_actor().empty()) {
+    _this->_internal_set_actor(from._internal_actor());
+  }
+  if (from._internal_has_source()) {
+    _this->_internal_mutable_source()->::aapt::pb::Source::MergeFrom(
+        from._internal_source());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Overlayable::CopyFrom(const Overlayable& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Overlayable)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Overlayable::IsInitialized() const {
+  return true;
+}
+
+void Overlayable::InternalSwap(Overlayable* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.name_, lhs_arena,
+      &other->_impl_.name_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.actor_, lhs_arena,
+      &other->_impl_.actor_, rhs_arena
+  );
+  swap(_impl_.source_, other->_impl_.source_);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Overlayable::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[11]);
+}
+
+// ===================================================================
+
+class OverlayableItem::_Internal {
+ public:
+  static const ::aapt::pb::Source& source(const OverlayableItem* msg);
+};
+
+const ::aapt::pb::Source&
+OverlayableItem::_Internal::source(const OverlayableItem* msg) {
+  return *msg->_impl_.source_;
+}
+OverlayableItem::OverlayableItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.OverlayableItem)
+}
+OverlayableItem::OverlayableItem(const OverlayableItem& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  OverlayableItem* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.policy_){from._impl_.policy_}
+    , /*decltype(_impl_._policy_cached_byte_size_)*/{0}
+    , decltype(_impl_.comment_){}
+    , decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.overlayable_idx_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.comment_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_comment().empty()) {
+    _this->_impl_.comment_.Set(from._internal_comment(), 
+      _this->GetArenaForAllocation());
+  }
+  if (from._internal_has_source()) {
+    _this->_impl_.source_ = new ::aapt::pb::Source(*from._impl_.source_);
+  }
+  _this->_impl_.overlayable_idx_ = from._impl_.overlayable_idx_;
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.OverlayableItem)
+}
+
+inline void OverlayableItem::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.policy_){arena}
+    , /*decltype(_impl_._policy_cached_byte_size_)*/{0}
+    , decltype(_impl_.comment_){}
+    , decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.overlayable_idx_){0u}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.comment_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+OverlayableItem::~OverlayableItem() {
+  // @@protoc_insertion_point(destructor:aapt.pb.OverlayableItem)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void OverlayableItem::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.policy_.~RepeatedField();
+  _impl_.comment_.Destroy();
+  if (this != internal_default_instance()) delete _impl_.source_;
+}
+
+void OverlayableItem::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void OverlayableItem::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.OverlayableItem)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.policy_.Clear();
+  _impl_.comment_.ClearToEmpty();
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+  _impl_.overlayable_idx_ = 0u;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* OverlayableItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.Source source = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string comment = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          auto str = _internal_mutable_comment();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.OverlayableItem.comment"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // repeated .aapt.pb.OverlayableItem.Policy policy = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_policy(), ptr, ctx);
+          CHK_(ptr);
+        } else if (static_cast<::uint8_t>(tag) == 24) {
+          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+          _internal_add_policy(static_cast<::aapt::pb::OverlayableItem_Policy>(val));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 overlayable_idx = 4;
+      case 4:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
+          _impl_.overlayable_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* OverlayableItem::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.OverlayableItem)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.Source source = 1;
+  if (this->_internal_has_source()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(1, _Internal::source(this),
+        _Internal::source(this).GetCachedSize(), target, stream);
+  }
+
+  // string comment = 2;
+  if (!this->_internal_comment().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_comment().data(), static_cast<int>(this->_internal_comment().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.OverlayableItem.comment");
+    target = stream->WriteStringMaybeAliased(
+        2, this->_internal_comment(), target);
+  }
+
+  // repeated .aapt.pb.OverlayableItem.Policy policy = 3;
+  {
+    int byte_size = _impl_._policy_cached_byte_size_.load(std::memory_order_relaxed);
+    if (byte_size > 0) {
+      target = stream->WriteEnumPacked(
+          3, _impl_.policy_, byte_size, target);
+    }
+  }
+
+  // uint32 overlayable_idx = 4;
+  if (this->_internal_overlayable_idx() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_overlayable_idx(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.OverlayableItem)
+  return target;
+}
+
+size_t OverlayableItem::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.OverlayableItem)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // repeated .aapt.pb.OverlayableItem.Policy policy = 3;
+  {
+    size_t data_size = 0;
+    unsigned int count = static_cast<unsigned int>(this->_internal_policy_size());for (unsigned int i = 0; i < count; i++) {
+      data_size += ::_pbi::WireFormatLite::EnumSize(
+        this->_internal_policy(static_cast<int>(i)));
+    }
+    if (data_size > 0) {
+      total_size += 1 +
+        ::_pbi::WireFormatLite::Int32Size(static_cast<::int32_t>(data_size));
+    }
+    int cached_size = ::_pbi::ToCachedSize(data_size);
+    _impl_._policy_cached_byte_size_.store(cached_size,
+                                    std::memory_order_relaxed);
+    total_size += data_size;
+  }
+
+  // string comment = 2;
+  if (!this->_internal_comment().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_comment());
+  }
+
+  // .aapt.pb.Source source = 1;
+  if (this->_internal_has_source()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.source_);
+  }
+
+  // uint32 overlayable_idx = 4;
+  if (this->_internal_overlayable_idx() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_overlayable_idx());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OverlayableItem::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    OverlayableItem::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OverlayableItem::GetClassData() const { return &_class_data_; }
+
+
+void OverlayableItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<OverlayableItem*>(&to_msg);
+  auto& from = static_cast<const OverlayableItem&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.OverlayableItem)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  _this->_impl_.policy_.MergeFrom(from._impl_.policy_);
+  if (!from._internal_comment().empty()) {
+    _this->_internal_set_comment(from._internal_comment());
+  }
+  if (from._internal_has_source()) {
+    _this->_internal_mutable_source()->::aapt::pb::Source::MergeFrom(
+        from._internal_source());
+  }
+  if (from._internal_overlayable_idx() != 0) {
+    _this->_internal_set_overlayable_idx(from._internal_overlayable_idx());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void OverlayableItem::CopyFrom(const OverlayableItem& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.OverlayableItem)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool OverlayableItem::IsInitialized() const {
+  return true;
+}
+
+void OverlayableItem::InternalSwap(OverlayableItem* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  _impl_.policy_.InternalSwap(&other->_impl_.policy_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.comment_, lhs_arena,
+      &other->_impl_.comment_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(OverlayableItem, _impl_.overlayable_idx_)
+      + sizeof(OverlayableItem::_impl_.overlayable_idx_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(OverlayableItem, _impl_.source_)>(
+          reinterpret_cast<char*>(&_impl_.source_),
+          reinterpret_cast<char*>(&other->_impl_.source_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata OverlayableItem::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[12]);
+}
+
+// ===================================================================
+
+class StagedId::_Internal {
+ public:
+  static const ::aapt::pb::Source& source(const StagedId* msg);
+};
+
+const ::aapt::pb::Source&
+StagedId::_Internal::source(const StagedId* msg) {
+  return *msg->_impl_.source_;
+}
+StagedId::StagedId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.StagedId)
+}
+StagedId::StagedId(const StagedId& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  StagedId* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.staged_id_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  if (from._internal_has_source()) {
+    _this->_impl_.source_ = new ::aapt::pb::Source(*from._impl_.source_);
+  }
+  _this->_impl_.staged_id_ = from._impl_.staged_id_;
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.StagedId)
+}
+
+inline void StagedId::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.staged_id_){0u}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+}
+
+StagedId::~StagedId() {
+  // @@protoc_insertion_point(destructor:aapt.pb.StagedId)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void StagedId::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  if (this != internal_default_instance()) delete _impl_.source_;
+}
+
+void StagedId::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void StagedId::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.StagedId)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+  _impl_.staged_id_ = 0u;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* StagedId::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.Source source = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 staged_id = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
+          _impl_.staged_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* StagedId::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.StagedId)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.Source source = 1;
+  if (this->_internal_has_source()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(1, _Internal::source(this),
+        _Internal::source(this).GetCachedSize(), target, stream);
+  }
+
+  // uint32 staged_id = 2;
+  if (this->_internal_staged_id() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_staged_id(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.StagedId)
+  return target;
+}
+
+size_t StagedId::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.StagedId)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // .aapt.pb.Source source = 1;
+  if (this->_internal_has_source()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.source_);
+  }
+
+  // uint32 staged_id = 2;
+  if (this->_internal_staged_id() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_staged_id());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StagedId::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    StagedId::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StagedId::GetClassData() const { return &_class_data_; }
+
+
+void StagedId::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<StagedId*>(&to_msg);
+  auto& from = static_cast<const StagedId&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.StagedId)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (from._internal_has_source()) {
+    _this->_internal_mutable_source()->::aapt::pb::Source::MergeFrom(
+        from._internal_source());
+  }
+  if (from._internal_staged_id() != 0) {
+    _this->_internal_set_staged_id(from._internal_staged_id());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void StagedId::CopyFrom(const StagedId& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.StagedId)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StagedId::IsInitialized() const {
+  return true;
+}
+
+void StagedId::InternalSwap(StagedId* other) {
+  using std::swap;
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(StagedId, _impl_.staged_id_)
+      + sizeof(StagedId::_impl_.staged_id_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(StagedId, _impl_.source_)>(
+          reinterpret_cast<char*>(&_impl_.source_),
+          reinterpret_cast<char*>(&other->_impl_.source_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata StagedId::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[13]);
+}
+
+// ===================================================================
+
+class EntryId::_Internal {
+ public:
+};
+
+EntryId::EntryId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.EntryId)
+}
+EntryId::EntryId(const EntryId& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  EntryId* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.id_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _this->_impl_.id_ = from._impl_.id_;
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.EntryId)
+}
+
+inline void EntryId::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.id_){0u}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+}
+
+EntryId::~EntryId() {
+  // @@protoc_insertion_point(destructor:aapt.pb.EntryId)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void EntryId::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+}
+
+void EntryId::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void EntryId::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.EntryId)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.id_ = 0u;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* EntryId::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // uint32 id = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
+          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* EntryId::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.EntryId)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // uint32 id = 1;
+  if (this->_internal_id() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.EntryId)
+  return target;
+}
+
+size_t EntryId::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.EntryId)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // uint32 id = 1;
+  if (this->_internal_id() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EntryId::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    EntryId::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EntryId::GetClassData() const { return &_class_data_; }
+
+
+void EntryId::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<EntryId*>(&to_msg);
+  auto& from = static_cast<const EntryId&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.EntryId)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (from._internal_id() != 0) {
+    _this->_internal_set_id(from._internal_id());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void EntryId::CopyFrom(const EntryId& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.EntryId)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool EntryId::IsInitialized() const {
+  return true;
+}
+
+void EntryId::InternalSwap(EntryId* other) {
+  using std::swap;
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  swap(_impl_.id_, other->_impl_.id_);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata EntryId::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[14]);
+}
+
+// ===================================================================
+
+class Entry::_Internal {
+ public:
+  static const ::aapt::pb::EntryId& entry_id(const Entry* msg);
+  static const ::aapt::pb::Visibility& visibility(const Entry* msg);
+  static const ::aapt::pb::AllowNew& allow_new(const Entry* msg);
+  static const ::aapt::pb::OverlayableItem& overlayable_item(const Entry* msg);
+  static const ::aapt::pb::StagedId& staged_id(const Entry* msg);
+};
+
+const ::aapt::pb::EntryId&
+Entry::_Internal::entry_id(const Entry* msg) {
+  return *msg->_impl_.entry_id_;
+}
+const ::aapt::pb::Visibility&
+Entry::_Internal::visibility(const Entry* msg) {
+  return *msg->_impl_.visibility_;
+}
+const ::aapt::pb::AllowNew&
+Entry::_Internal::allow_new(const Entry* msg) {
+  return *msg->_impl_.allow_new_;
+}
+const ::aapt::pb::OverlayableItem&
+Entry::_Internal::overlayable_item(const Entry* msg) {
+  return *msg->_impl_.overlayable_item_;
+}
+const ::aapt::pb::StagedId&
+Entry::_Internal::staged_id(const Entry* msg) {
+  return *msg->_impl_.staged_id_;
+}
+Entry::Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Entry)
+}
+Entry::Entry(const Entry& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Entry* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.config_value_){from._impl_.config_value_}
+    , decltype(_impl_.name_){}
+    , decltype(_impl_.entry_id_){nullptr}
+    , decltype(_impl_.visibility_){nullptr}
+    , decltype(_impl_.allow_new_){nullptr}
+    , decltype(_impl_.overlayable_item_){nullptr}
+    , decltype(_impl_.staged_id_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_name().empty()) {
+    _this->_impl_.name_.Set(from._internal_name(), 
+      _this->GetArenaForAllocation());
+  }
+  if (from._internal_has_entry_id()) {
+    _this->_impl_.entry_id_ = new ::aapt::pb::EntryId(*from._impl_.entry_id_);
+  }
+  if (from._internal_has_visibility()) {
+    _this->_impl_.visibility_ = new ::aapt::pb::Visibility(*from._impl_.visibility_);
+  }
+  if (from._internal_has_allow_new()) {
+    _this->_impl_.allow_new_ = new ::aapt::pb::AllowNew(*from._impl_.allow_new_);
+  }
+  if (from._internal_has_overlayable_item()) {
+    _this->_impl_.overlayable_item_ = new ::aapt::pb::OverlayableItem(*from._impl_.overlayable_item_);
+  }
+  if (from._internal_has_staged_id()) {
+    _this->_impl_.staged_id_ = new ::aapt::pb::StagedId(*from._impl_.staged_id_);
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Entry)
+}
+
+inline void Entry::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.config_value_){arena}
+    , decltype(_impl_.name_){}
+    , decltype(_impl_.entry_id_){nullptr}
+    , decltype(_impl_.visibility_){nullptr}
+    , decltype(_impl_.allow_new_){nullptr}
+    , decltype(_impl_.overlayable_item_){nullptr}
+    , decltype(_impl_.staged_id_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+Entry::~Entry() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Entry)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Entry::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.config_value_.~RepeatedPtrField();
+  _impl_.name_.Destroy();
+  if (this != internal_default_instance()) delete _impl_.entry_id_;
+  if (this != internal_default_instance()) delete _impl_.visibility_;
+  if (this != internal_default_instance()) delete _impl_.allow_new_;
+  if (this != internal_default_instance()) delete _impl_.overlayable_item_;
+  if (this != internal_default_instance()) delete _impl_.staged_id_;
+}
+
+void Entry::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Entry::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Entry)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.config_value_.Clear();
+  _impl_.name_.ClearToEmpty();
+  if (GetArenaForAllocation() == nullptr && _impl_.entry_id_ != nullptr) {
+    delete _impl_.entry_id_;
+  }
+  _impl_.entry_id_ = nullptr;
+  if (GetArenaForAllocation() == nullptr && _impl_.visibility_ != nullptr) {
+    delete _impl_.visibility_;
+  }
+  _impl_.visibility_ = nullptr;
+  if (GetArenaForAllocation() == nullptr && _impl_.allow_new_ != nullptr) {
+    delete _impl_.allow_new_;
+  }
+  _impl_.allow_new_ = nullptr;
+  if (GetArenaForAllocation() == nullptr && _impl_.overlayable_item_ != nullptr) {
+    delete _impl_.overlayable_item_;
+  }
+  _impl_.overlayable_item_ = nullptr;
+  if (GetArenaForAllocation() == nullptr && _impl_.staged_id_ != nullptr) {
+    delete _impl_.staged_id_;
+  }
+  _impl_.staged_id_ = nullptr;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Entry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.EntryId entry_id = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr = ctx->ParseMessage(_internal_mutable_entry_id(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string name = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          auto str = _internal_mutable_name();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.Entry.name"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Visibility visibility = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          ptr = ctx->ParseMessage(_internal_mutable_visibility(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.AllowNew allow_new = 4;
+      case 4:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
+          ptr = ctx->ParseMessage(_internal_mutable_allow_new(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.OverlayableItem overlayable_item = 5;
+      case 5:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
+          ptr = ctx->ParseMessage(_internal_mutable_overlayable_item(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // repeated .aapt.pb.ConfigValue config_value = 6;
+      case 6:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
+          ptr -= 1;
+          do {
+            ptr += 1;
+            ptr = ctx->ParseMessage(_internal_add_config_value(), ptr);
+            CHK_(ptr);
+            if (!ctx->DataAvailable(ptr)) break;
+          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.StagedId staged_id = 7;
+      case 7:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
+          ptr = ctx->ParseMessage(_internal_mutable_staged_id(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Entry::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Entry)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.EntryId entry_id = 1;
+  if (this->_internal_has_entry_id()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(1, _Internal::entry_id(this),
+        _Internal::entry_id(this).GetCachedSize(), target, stream);
+  }
+
+  // string name = 2;
+  if (!this->_internal_name().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.Entry.name");
+    target = stream->WriteStringMaybeAliased(
+        2, this->_internal_name(), target);
+  }
+
+  // .aapt.pb.Visibility visibility = 3;
+  if (this->_internal_has_visibility()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(3, _Internal::visibility(this),
+        _Internal::visibility(this).GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.AllowNew allow_new = 4;
+  if (this->_internal_has_allow_new()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(4, _Internal::allow_new(this),
+        _Internal::allow_new(this).GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.OverlayableItem overlayable_item = 5;
+  if (this->_internal_has_overlayable_item()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(5, _Internal::overlayable_item(this),
+        _Internal::overlayable_item(this).GetCachedSize(), target, stream);
+  }
+
+  // repeated .aapt.pb.ConfigValue config_value = 6;
+  for (unsigned i = 0,
+      n = static_cast<unsigned>(this->_internal_config_value_size()); i < n; i++) {
+    const auto& repfield = this->_internal_config_value(i);
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.StagedId staged_id = 7;
+  if (this->_internal_has_staged_id()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(7, _Internal::staged_id(this),
+        _Internal::staged_id(this).GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Entry)
+  return target;
+}
+
+size_t Entry::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Entry)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // repeated .aapt.pb.ConfigValue config_value = 6;
+  total_size += 1UL * this->_internal_config_value_size();
+  for (const auto& msg : this->_impl_.config_value_) {
+    total_size +=
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
+  }
+
+  // string name = 2;
+  if (!this->_internal_name().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_name());
+  }
+
+  // .aapt.pb.EntryId entry_id = 1;
+  if (this->_internal_has_entry_id()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.entry_id_);
+  }
+
+  // .aapt.pb.Visibility visibility = 3;
+  if (this->_internal_has_visibility()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.visibility_);
+  }
+
+  // .aapt.pb.AllowNew allow_new = 4;
+  if (this->_internal_has_allow_new()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.allow_new_);
+  }
+
+  // .aapt.pb.OverlayableItem overlayable_item = 5;
+  if (this->_internal_has_overlayable_item()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.overlayable_item_);
+  }
+
+  // .aapt.pb.StagedId staged_id = 7;
+  if (this->_internal_has_staged_id()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.staged_id_);
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Entry::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Entry::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Entry::GetClassData() const { return &_class_data_; }
+
+
+void Entry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Entry*>(&to_msg);
+  auto& from = static_cast<const Entry&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Entry)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  _this->_impl_.config_value_.MergeFrom(from._impl_.config_value_);
+  if (!from._internal_name().empty()) {
+    _this->_internal_set_name(from._internal_name());
+  }
+  if (from._internal_has_entry_id()) {
+    _this->_internal_mutable_entry_id()->::aapt::pb::EntryId::MergeFrom(
+        from._internal_entry_id());
+  }
+  if (from._internal_has_visibility()) {
+    _this->_internal_mutable_visibility()->::aapt::pb::Visibility::MergeFrom(
+        from._internal_visibility());
+  }
+  if (from._internal_has_allow_new()) {
+    _this->_internal_mutable_allow_new()->::aapt::pb::AllowNew::MergeFrom(
+        from._internal_allow_new());
+  }
+  if (from._internal_has_overlayable_item()) {
+    _this->_internal_mutable_overlayable_item()->::aapt::pb::OverlayableItem::MergeFrom(
+        from._internal_overlayable_item());
+  }
+  if (from._internal_has_staged_id()) {
+    _this->_internal_mutable_staged_id()->::aapt::pb::StagedId::MergeFrom(
+        from._internal_staged_id());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Entry::CopyFrom(const Entry& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Entry)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Entry::IsInitialized() const {
+  return true;
+}
+
+void Entry::InternalSwap(Entry* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  _impl_.config_value_.InternalSwap(&other->_impl_.config_value_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.name_, lhs_arena,
+      &other->_impl_.name_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(Entry, _impl_.staged_id_)
+      + sizeof(Entry::_impl_.staged_id_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(Entry, _impl_.entry_id_)>(
+          reinterpret_cast<char*>(&_impl_.entry_id_),
+          reinterpret_cast<char*>(&other->_impl_.entry_id_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Entry::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[15]);
+}
+
+// ===================================================================
+
+class ConfigValue::_Internal {
+ public:
+  static const ::aapt::pb::Configuration& config(const ConfigValue* msg);
+  static const ::aapt::pb::Value& value(const ConfigValue* msg);
+};
+
+const ::aapt::pb::Configuration&
+ConfigValue::_Internal::config(const ConfigValue* msg) {
+  return *msg->_impl_.config_;
+}
+const ::aapt::pb::Value&
+ConfigValue::_Internal::value(const ConfigValue* msg) {
+  return *msg->_impl_.value_;
+}
+void ConfigValue::clear_config() {
+  if (GetArenaForAllocation() == nullptr && _impl_.config_ != nullptr) {
+    delete _impl_.config_;
+  }
+  _impl_.config_ = nullptr;
+}
+ConfigValue::ConfigValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.ConfigValue)
+}
+ConfigValue::ConfigValue(const ConfigValue& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  ConfigValue* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.config_){nullptr}
+    , decltype(_impl_.value_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  if (from._internal_has_config()) {
+    _this->_impl_.config_ = new ::aapt::pb::Configuration(*from._impl_.config_);
+  }
+  if (from._internal_has_value()) {
+    _this->_impl_.value_ = new ::aapt::pb::Value(*from._impl_.value_);
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.ConfigValue)
+}
+
+inline void ConfigValue::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.config_){nullptr}
+    , decltype(_impl_.value_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+}
+
+ConfigValue::~ConfigValue() {
+  // @@protoc_insertion_point(destructor:aapt.pb.ConfigValue)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void ConfigValue::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  if (this != internal_default_instance()) delete _impl_.config_;
+  if (this != internal_default_instance()) delete _impl_.value_;
+}
+
+void ConfigValue::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void ConfigValue::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.ConfigValue)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  if (GetArenaForAllocation() == nullptr && _impl_.config_ != nullptr) {
+    delete _impl_.config_;
+  }
+  _impl_.config_ = nullptr;
+  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
+    delete _impl_.value_;
+  }
+  _impl_.value_ = nullptr;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* ConfigValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.Configuration config = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Value value = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* ConfigValue::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.ConfigValue)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.Configuration config = 1;
+  if (this->_internal_has_config()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(1, _Internal::config(this),
+        _Internal::config(this).GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.Value value = 2;
+  if (this->_internal_has_value()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(2, _Internal::value(this),
+        _Internal::value(this).GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.ConfigValue)
+  return target;
+}
+
+size_t ConfigValue::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.ConfigValue)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // .aapt.pb.Configuration config = 1;
+  if (this->_internal_has_config()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.config_);
+  }
+
+  // .aapt.pb.Value value = 2;
+  if (this->_internal_has_value()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.value_);
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConfigValue::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    ConfigValue::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConfigValue::GetClassData() const { return &_class_data_; }
+
+
+void ConfigValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<ConfigValue*>(&to_msg);
+  auto& from = static_cast<const ConfigValue&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.ConfigValue)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (from._internal_has_config()) {
+    _this->_internal_mutable_config()->::aapt::pb::Configuration::MergeFrom(
+        from._internal_config());
+  }
+  if (from._internal_has_value()) {
+    _this->_internal_mutable_value()->::aapt::pb::Value::MergeFrom(
+        from._internal_value());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void ConfigValue::CopyFrom(const ConfigValue& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.ConfigValue)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool ConfigValue::IsInitialized() const {
+  return true;
+}
+
+void ConfigValue::InternalSwap(ConfigValue* other) {
+  using std::swap;
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(ConfigValue, _impl_.value_)
+      + sizeof(ConfigValue::_impl_.value_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(ConfigValue, _impl_.config_)>(
+          reinterpret_cast<char*>(&_impl_.config_),
+          reinterpret_cast<char*>(&other->_impl_.config_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata ConfigValue::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[16]);
+}
+
+// ===================================================================
+
+class Value::_Internal {
+ public:
+  static const ::aapt::pb::Source& source(const Value* msg);
+  static const ::aapt::pb::Item& item(const Value* msg);
+  static const ::aapt::pb::CompoundValue& compound_value(const Value* msg);
+};
+
+const ::aapt::pb::Source&
+Value::_Internal::source(const Value* msg) {
+  return *msg->_impl_.source_;
+}
+const ::aapt::pb::Item&
+Value::_Internal::item(const Value* msg) {
+  return *msg->_impl_.value_.item_;
+}
+const ::aapt::pb::CompoundValue&
+Value::_Internal::compound_value(const Value* msg) {
+  return *msg->_impl_.value_.compound_value_;
+}
+void Value::set_allocated_item(::aapt::pb::Item* item) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  clear_value();
+  if (item) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
+    if (message_arena != submessage_arena) {
+      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, item, submessage_arena);
+    }
+    set_has_item();
+    _impl_.value_.item_ = item;
+  }
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Value.item)
+}
+void Value::set_allocated_compound_value(::aapt::pb::CompoundValue* compound_value) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  clear_value();
+  if (compound_value) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(compound_value);
+    if (message_arena != submessage_arena) {
+      compound_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, compound_value, submessage_arena);
+    }
+    set_has_compound_value();
+    _impl_.value_.compound_value_ = compound_value;
+  }
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Value.compound_value)
+}
+Value::Value(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Value)
+}
+Value::Value(const Value& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Value* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.comment_){}
+    , decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.weak_){}
+    , decltype(_impl_.value_){}
+    , /*decltype(_impl_._cached_size_)*/{}
+    , /*decltype(_impl_._oneof_case_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.comment_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_comment().empty()) {
+    _this->_impl_.comment_.Set(from._internal_comment(), 
+      _this->GetArenaForAllocation());
+  }
+  if (from._internal_has_source()) {
+    _this->_impl_.source_ = new ::aapt::pb::Source(*from._impl_.source_);
+  }
+  _this->_impl_.weak_ = from._impl_.weak_;
+  clear_has_value();
+  switch (from.value_case()) {
+    case kItem: {
+      _this->_internal_mutable_item()->::aapt::pb::Item::MergeFrom(
+          from._internal_item());
+      break;
+    }
+    case kCompoundValue: {
+      _this->_internal_mutable_compound_value()->::aapt::pb::CompoundValue::MergeFrom(
+          from._internal_compound_value());
+      break;
+    }
+    case VALUE_NOT_SET: {
+      break;
+    }
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Value)
+}
+
+inline void Value::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.comment_){}
+    , decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.weak_){false}
+    , decltype(_impl_.value_){}
+    , /*decltype(_impl_._cached_size_)*/{}
+    , /*decltype(_impl_._oneof_case_)*/{}
+  };
+  _impl_.comment_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  clear_has_value();
+}
+
+Value::~Value() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Value)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Value::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.comment_.Destroy();
+  if (this != internal_default_instance()) delete _impl_.source_;
+  if (has_value()) {
+    clear_value();
+  }
+}
+
+void Value::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Value::clear_value() {
+// @@protoc_insertion_point(one_of_clear_start:aapt.pb.Value)
+  switch (value_case()) {
+    case kItem: {
+      if (GetArenaForAllocation() == nullptr) {
+        delete _impl_.value_.item_;
+      }
+      break;
+    }
+    case kCompoundValue: {
+      if (GetArenaForAllocation() == nullptr) {
+        delete _impl_.value_.compound_value_;
+      }
+      break;
+    }
+    case VALUE_NOT_SET: {
+      break;
+    }
+  }
+  _impl_._oneof_case_[0] = VALUE_NOT_SET;
+}
+
+
+void Value::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Value)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.comment_.ClearToEmpty();
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+  _impl_.weak_ = false;
+  clear_value();
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Value::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.Source source = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string comment = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          auto str = _internal_mutable_comment();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.Value.comment"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // bool weak = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
+          _impl_.weak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Item item = 4;
+      case 4:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
+          ptr = ctx->ParseMessage(_internal_mutable_item(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.CompoundValue compound_value = 5;
+      case 5:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
+          ptr = ctx->ParseMessage(_internal_mutable_compound_value(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Value::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Value)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.Source source = 1;
+  if (this->_internal_has_source()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(1, _Internal::source(this),
+        _Internal::source(this).GetCachedSize(), target, stream);
+  }
+
+  // string comment = 2;
+  if (!this->_internal_comment().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_comment().data(), static_cast<int>(this->_internal_comment().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.Value.comment");
+    target = stream->WriteStringMaybeAliased(
+        2, this->_internal_comment(), target);
+  }
+
+  // bool weak = 3;
+  if (this->_internal_weak() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_weak(), target);
+  }
+
+  // .aapt.pb.Item item = 4;
+  if (_internal_has_item()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(4, _Internal::item(this),
+        _Internal::item(this).GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.CompoundValue compound_value = 5;
+  if (_internal_has_compound_value()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(5, _Internal::compound_value(this),
+        _Internal::compound_value(this).GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Value)
+  return target;
+}
+
+size_t Value::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Value)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string comment = 2;
+  if (!this->_internal_comment().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_comment());
+  }
+
+  // .aapt.pb.Source source = 1;
+  if (this->_internal_has_source()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.source_);
+  }
+
+  // bool weak = 3;
+  if (this->_internal_weak() != 0) {
+    total_size += 1 + 1;
+  }
+
+  switch (value_case()) {
+    // .aapt.pb.Item item = 4;
+    case kItem: {
+      total_size += 1 +
+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+          *_impl_.value_.item_);
+      break;
+    }
+    // .aapt.pb.CompoundValue compound_value = 5;
+    case kCompoundValue: {
+      total_size += 1 +
+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+          *_impl_.value_.compound_value_);
+      break;
+    }
+    case VALUE_NOT_SET: {
+      break;
+    }
+  }
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Value::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Value::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Value::GetClassData() const { return &_class_data_; }
+
+
+void Value::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Value*>(&to_msg);
+  auto& from = static_cast<const Value&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Value)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_comment().empty()) {
+    _this->_internal_set_comment(from._internal_comment());
+  }
+  if (from._internal_has_source()) {
+    _this->_internal_mutable_source()->::aapt::pb::Source::MergeFrom(
+        from._internal_source());
+  }
+  if (from._internal_weak() != 0) {
+    _this->_internal_set_weak(from._internal_weak());
+  }
+  switch (from.value_case()) {
+    case kItem: {
+      _this->_internal_mutable_item()->::aapt::pb::Item::MergeFrom(
+          from._internal_item());
+      break;
+    }
+    case kCompoundValue: {
+      _this->_internal_mutable_compound_value()->::aapt::pb::CompoundValue::MergeFrom(
+          from._internal_compound_value());
+      break;
+    }
+    case VALUE_NOT_SET: {
+      break;
+    }
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Value::CopyFrom(const Value& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Value)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Value::IsInitialized() const {
+  return true;
+}
+
+void Value::InternalSwap(Value* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.comment_, lhs_arena,
+      &other->_impl_.comment_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(Value, _impl_.weak_)
+      + sizeof(Value::_impl_.weak_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(Value, _impl_.source_)>(
+          reinterpret_cast<char*>(&_impl_.source_),
+          reinterpret_cast<char*>(&other->_impl_.source_));
+  swap(_impl_.value_, other->_impl_.value_);
+  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Value::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[17]);
+}
+
+// ===================================================================
+
+class Item::_Internal {
+ public:
+  static const ::aapt::pb::Reference& ref(const Item* msg);
+  static const ::aapt::pb::String& str(const Item* msg);
+  static const ::aapt::pb::RawString& raw_str(const Item* msg);
+  static const ::aapt::pb::StyledString& styled_str(const Item* msg);
+  static const ::aapt::pb::FileReference& file(const Item* msg);
+  static const ::aapt::pb::Id& id(const Item* msg);
+  static const ::aapt::pb::Primitive& prim(const Item* msg);
+};
+
+const ::aapt::pb::Reference&
+Item::_Internal::ref(const Item* msg) {
+  return *msg->_impl_.value_.ref_;
+}
+const ::aapt::pb::String&
+Item::_Internal::str(const Item* msg) {
+  return *msg->_impl_.value_.str_;
+}
+const ::aapt::pb::RawString&
+Item::_Internal::raw_str(const Item* msg) {
+  return *msg->_impl_.value_.raw_str_;
+}
+const ::aapt::pb::StyledString&
+Item::_Internal::styled_str(const Item* msg) {
+  return *msg->_impl_.value_.styled_str_;
+}
+const ::aapt::pb::FileReference&
+Item::_Internal::file(const Item* msg) {
+  return *msg->_impl_.value_.file_;
+}
+const ::aapt::pb::Id&
+Item::_Internal::id(const Item* msg) {
+  return *msg->_impl_.value_.id_;
+}
+const ::aapt::pb::Primitive&
+Item::_Internal::prim(const Item* msg) {
+  return *msg->_impl_.value_.prim_;
+}
+void Item::set_allocated_ref(::aapt::pb::Reference* ref) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  clear_value();
+  if (ref) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ref);
+    if (message_arena != submessage_arena) {
+      ref = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, ref, submessage_arena);
+    }
+    set_has_ref();
+    _impl_.value_.ref_ = ref;
+  }
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.ref)
+}
+void Item::set_allocated_str(::aapt::pb::String* str) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  clear_value();
+  if (str) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(str);
+    if (message_arena != submessage_arena) {
+      str = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, str, submessage_arena);
+    }
+    set_has_str();
+    _impl_.value_.str_ = str;
+  }
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.str)
+}
+void Item::set_allocated_raw_str(::aapt::pb::RawString* raw_str) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  clear_value();
+  if (raw_str) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(raw_str);
+    if (message_arena != submessage_arena) {
+      raw_str = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, raw_str, submessage_arena);
+    }
+    set_has_raw_str();
+    _impl_.value_.raw_str_ = raw_str;
+  }
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.raw_str)
+}
+void Item::set_allocated_styled_str(::aapt::pb::StyledString* styled_str) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  clear_value();
+  if (styled_str) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(styled_str);
+    if (message_arena != submessage_arena) {
+      styled_str = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, styled_str, submessage_arena);
+    }
+    set_has_styled_str();
+    _impl_.value_.styled_str_ = styled_str;
+  }
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.styled_str)
+}
+void Item::set_allocated_file(::aapt::pb::FileReference* file) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  clear_value();
+  if (file) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(file);
+    if (message_arena != submessage_arena) {
+      file = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, file, submessage_arena);
+    }
+    set_has_file();
+    _impl_.value_.file_ = file;
+  }
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.file)
+}
+void Item::set_allocated_id(::aapt::pb::Id* id) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  clear_value();
+  if (id) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(id);
+    if (message_arena != submessage_arena) {
+      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, id, submessage_arena);
+    }
+    set_has_id();
+    _impl_.value_.id_ = id;
+  }
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.id)
+}
+void Item::set_allocated_prim(::aapt::pb::Primitive* prim) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  clear_value();
+  if (prim) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(prim);
+    if (message_arena != submessage_arena) {
+      prim = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, prim, submessage_arena);
+    }
+    set_has_prim();
+    _impl_.value_.prim_ = prim;
+  }
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.prim)
+}
+Item::Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Item)
+}
+Item::Item(const Item& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Item* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.value_){}
+    , /*decltype(_impl_._cached_size_)*/{}
+    , /*decltype(_impl_._oneof_case_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  clear_has_value();
+  switch (from.value_case()) {
+    case kRef: {
+      _this->_internal_mutable_ref()->::aapt::pb::Reference::MergeFrom(
+          from._internal_ref());
+      break;
+    }
+    case kStr: {
+      _this->_internal_mutable_str()->::aapt::pb::String::MergeFrom(
+          from._internal_str());
+      break;
+    }
+    case kRawStr: {
+      _this->_internal_mutable_raw_str()->::aapt::pb::RawString::MergeFrom(
+          from._internal_raw_str());
+      break;
+    }
+    case kStyledStr: {
+      _this->_internal_mutable_styled_str()->::aapt::pb::StyledString::MergeFrom(
+          from._internal_styled_str());
+      break;
+    }
+    case kFile: {
+      _this->_internal_mutable_file()->::aapt::pb::FileReference::MergeFrom(
+          from._internal_file());
+      break;
+    }
+    case kId: {
+      _this->_internal_mutable_id()->::aapt::pb::Id::MergeFrom(
+          from._internal_id());
+      break;
+    }
+    case kPrim: {
+      _this->_internal_mutable_prim()->::aapt::pb::Primitive::MergeFrom(
+          from._internal_prim());
+      break;
+    }
+    case VALUE_NOT_SET: {
+      break;
+    }
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Item)
+}
+
+inline void Item::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.value_){}
+    , /*decltype(_impl_._cached_size_)*/{}
+    , /*decltype(_impl_._oneof_case_)*/{}
+  };
+  clear_has_value();
+}
+
+Item::~Item() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Item)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Item::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  if (has_value()) {
+    clear_value();
+  }
+}
+
+void Item::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Item::clear_value() {
+// @@protoc_insertion_point(one_of_clear_start:aapt.pb.Item)
+  switch (value_case()) {
+    case kRef: {
+      if (GetArenaForAllocation() == nullptr) {
+        delete _impl_.value_.ref_;
+      }
+      break;
+    }
+    case kStr: {
+      if (GetArenaForAllocation() == nullptr) {
+        delete _impl_.value_.str_;
+      }
+      break;
+    }
+    case kRawStr: {
+      if (GetArenaForAllocation() == nullptr) {
+        delete _impl_.value_.raw_str_;
+      }
+      break;
+    }
+    case kStyledStr: {
+      if (GetArenaForAllocation() == nullptr) {
+        delete _impl_.value_.styled_str_;
+      }
+      break;
+    }
+    case kFile: {
+      if (GetArenaForAllocation() == nullptr) {
+        delete _impl_.value_.file_;
+      }
+      break;
+    }
+    case kId: {
+      if (GetArenaForAllocation() == nullptr) {
+        delete _impl_.value_.id_;
+      }
+      break;
+    }
+    case kPrim: {
+      if (GetArenaForAllocation() == nullptr) {
+        delete _impl_.value_.prim_;
+      }
+      break;
+    }
+    case VALUE_NOT_SET: {
+      break;
+    }
+  }
+  _impl_._oneof_case_[0] = VALUE_NOT_SET;
+}
+
+
+void Item::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Item)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  clear_value();
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Item::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.Reference ref = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr = ctx->ParseMessage(_internal_mutable_ref(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.String str = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          ptr = ctx->ParseMessage(_internal_mutable_str(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.RawString raw_str = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          ptr = ctx->ParseMessage(_internal_mutable_raw_str(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.StyledString styled_str = 4;
+      case 4:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
+          ptr = ctx->ParseMessage(_internal_mutable_styled_str(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.FileReference file = 5;
+      case 5:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
+          ptr = ctx->ParseMessage(_internal_mutable_file(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Id id = 6;
+      case 6:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
+          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Primitive prim = 7;
+      case 7:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
+          ptr = ctx->ParseMessage(_internal_mutable_prim(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Item::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Item)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.Reference ref = 1;
+  if (_internal_has_ref()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(1, _Internal::ref(this),
+        _Internal::ref(this).GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.String str = 2;
+  if (_internal_has_str()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(2, _Internal::str(this),
+        _Internal::str(this).GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.RawString raw_str = 3;
+  if (_internal_has_raw_str()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(3, _Internal::raw_str(this),
+        _Internal::raw_str(this).GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.StyledString styled_str = 4;
+  if (_internal_has_styled_str()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(4, _Internal::styled_str(this),
+        _Internal::styled_str(this).GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.FileReference file = 5;
+  if (_internal_has_file()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(5, _Internal::file(this),
+        _Internal::file(this).GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.Id id = 6;
+  if (_internal_has_id()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(6, _Internal::id(this),
+        _Internal::id(this).GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.Primitive prim = 7;
+  if (_internal_has_prim()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(7, _Internal::prim(this),
+        _Internal::prim(this).GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Item)
+  return target;
+}
+
+size_t Item::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Item)
+  size_t total_size = 0;
+
+  switch (value_case()) {
+    // .aapt.pb.Reference ref = 1;
+    case kRef: {
+      total_size += 1 +
+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+          *_impl_.value_.ref_);
+      break;
+    }
+    // .aapt.pb.String str = 2;
+    case kStr: {
+      total_size += 1 +
+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+          *_impl_.value_.str_);
+      break;
+    }
+    // .aapt.pb.RawString raw_str = 3;
+    case kRawStr: {
+      total_size += 1 +
+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+          *_impl_.value_.raw_str_);
+      break;
+    }
+    // .aapt.pb.StyledString styled_str = 4;
+    case kStyledStr: {
+      total_size += 1 +
+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+          *_impl_.value_.styled_str_);
+      break;
+    }
+    // .aapt.pb.FileReference file = 5;
+    case kFile: {
+      total_size += 1 +
+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+          *_impl_.value_.file_);
+      break;
+    }
+    // .aapt.pb.Id id = 6;
+    case kId: {
+      total_size += 1 +
+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+          *_impl_.value_.id_);
+      break;
+    }
+    // .aapt.pb.Primitive prim = 7;
+    case kPrim: {
+      total_size += 1 +
+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+          *_impl_.value_.prim_);
+      break;
+    }
+    case VALUE_NOT_SET: {
+      break;
+    }
+  }
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Item::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Item::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Item::GetClassData() const { return &_class_data_; }
+
+
+void Item::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Item*>(&to_msg);
+  auto& from = static_cast<const Item&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Item)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  switch (from.value_case()) {
+    case kRef: {
+      _this->_internal_mutable_ref()->::aapt::pb::Reference::MergeFrom(
+          from._internal_ref());
+      break;
+    }
+    case kStr: {
+      _this->_internal_mutable_str()->::aapt::pb::String::MergeFrom(
+          from._internal_str());
+      break;
+    }
+    case kRawStr: {
+      _this->_internal_mutable_raw_str()->::aapt::pb::RawString::MergeFrom(
+          from._internal_raw_str());
+      break;
+    }
+    case kStyledStr: {
+      _this->_internal_mutable_styled_str()->::aapt::pb::StyledString::MergeFrom(
+          from._internal_styled_str());
+      break;
+    }
+    case kFile: {
+      _this->_internal_mutable_file()->::aapt::pb::FileReference::MergeFrom(
+          from._internal_file());
+      break;
+    }
+    case kId: {
+      _this->_internal_mutable_id()->::aapt::pb::Id::MergeFrom(
+          from._internal_id());
+      break;
+    }
+    case kPrim: {
+      _this->_internal_mutable_prim()->::aapt::pb::Primitive::MergeFrom(
+          from._internal_prim());
+      break;
+    }
+    case VALUE_NOT_SET: {
+      break;
+    }
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Item::CopyFrom(const Item& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Item)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Item::IsInitialized() const {
+  return true;
+}
+
+void Item::InternalSwap(Item* other) {
+  using std::swap;
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  swap(_impl_.value_, other->_impl_.value_);
+  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Item::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[18]);
+}
+
+// ===================================================================
+
+class CompoundValue::_Internal {
+ public:
+  static const ::aapt::pb::Attribute& attr(const CompoundValue* msg);
+  static const ::aapt::pb::Style& style(const CompoundValue* msg);
+  static const ::aapt::pb::Styleable& styleable(const CompoundValue* msg);
+  static const ::aapt::pb::Array& array(const CompoundValue* msg);
+  static const ::aapt::pb::Plural& plural(const CompoundValue* msg);
+  static const ::aapt::pb::MacroBody& macro(const CompoundValue* msg);
+};
+
+const ::aapt::pb::Attribute&
+CompoundValue::_Internal::attr(const CompoundValue* msg) {
+  return *msg->_impl_.value_.attr_;
+}
+const ::aapt::pb::Style&
+CompoundValue::_Internal::style(const CompoundValue* msg) {
+  return *msg->_impl_.value_.style_;
+}
+const ::aapt::pb::Styleable&
+CompoundValue::_Internal::styleable(const CompoundValue* msg) {
+  return *msg->_impl_.value_.styleable_;
+}
+const ::aapt::pb::Array&
+CompoundValue::_Internal::array(const CompoundValue* msg) {
+  return *msg->_impl_.value_.array_;
+}
+const ::aapt::pb::Plural&
+CompoundValue::_Internal::plural(const CompoundValue* msg) {
+  return *msg->_impl_.value_.plural_;
+}
+const ::aapt::pb::MacroBody&
+CompoundValue::_Internal::macro(const CompoundValue* msg) {
+  return *msg->_impl_.value_.macro_;
+}
+void CompoundValue::set_allocated_attr(::aapt::pb::Attribute* attr) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  clear_value();
+  if (attr) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attr);
+    if (message_arena != submessage_arena) {
+      attr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, attr, submessage_arena);
+    }
+    set_has_attr();
+    _impl_.value_.attr_ = attr;
+  }
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.attr)
+}
+void CompoundValue::set_allocated_style(::aapt::pb::Style* style) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  clear_value();
+  if (style) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(style);
+    if (message_arena != submessage_arena) {
+      style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, style, submessage_arena);
+    }
+    set_has_style();
+    _impl_.value_.style_ = style;
+  }
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.style)
+}
+void CompoundValue::set_allocated_styleable(::aapt::pb::Styleable* styleable) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  clear_value();
+  if (styleable) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(styleable);
+    if (message_arena != submessage_arena) {
+      styleable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, styleable, submessage_arena);
+    }
+    set_has_styleable();
+    _impl_.value_.styleable_ = styleable;
+  }
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.styleable)
+}
+void CompoundValue::set_allocated_array(::aapt::pb::Array* array) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  clear_value();
+  if (array) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(array);
+    if (message_arena != submessage_arena) {
+      array = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, array, submessage_arena);
+    }
+    set_has_array();
+    _impl_.value_.array_ = array;
+  }
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.array)
+}
+void CompoundValue::set_allocated_plural(::aapt::pb::Plural* plural) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  clear_value();
+  if (plural) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(plural);
+    if (message_arena != submessage_arena) {
+      plural = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, plural, submessage_arena);
+    }
+    set_has_plural();
+    _impl_.value_.plural_ = plural;
+  }
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.plural)
+}
+void CompoundValue::set_allocated_macro(::aapt::pb::MacroBody* macro) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  clear_value();
+  if (macro) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(macro);
+    if (message_arena != submessage_arena) {
+      macro = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, macro, submessage_arena);
+    }
+    set_has_macro();
+    _impl_.value_.macro_ = macro;
+  }
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.macro)
+}
+CompoundValue::CompoundValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.CompoundValue)
+}
+CompoundValue::CompoundValue(const CompoundValue& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  CompoundValue* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.value_){}
+    , /*decltype(_impl_._cached_size_)*/{}
+    , /*decltype(_impl_._oneof_case_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  clear_has_value();
+  switch (from.value_case()) {
+    case kAttr: {
+      _this->_internal_mutable_attr()->::aapt::pb::Attribute::MergeFrom(
+          from._internal_attr());
+      break;
+    }
+    case kStyle: {
+      _this->_internal_mutable_style()->::aapt::pb::Style::MergeFrom(
+          from._internal_style());
+      break;
+    }
+    case kStyleable: {
+      _this->_internal_mutable_styleable()->::aapt::pb::Styleable::MergeFrom(
+          from._internal_styleable());
+      break;
+    }
+    case kArray: {
+      _this->_internal_mutable_array()->::aapt::pb::Array::MergeFrom(
+          from._internal_array());
+      break;
+    }
+    case kPlural: {
+      _this->_internal_mutable_plural()->::aapt::pb::Plural::MergeFrom(
+          from._internal_plural());
+      break;
+    }
+    case kMacro: {
+      _this->_internal_mutable_macro()->::aapt::pb::MacroBody::MergeFrom(
+          from._internal_macro());
+      break;
+    }
+    case VALUE_NOT_SET: {
+      break;
+    }
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.CompoundValue)
+}
+
+inline void CompoundValue::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.value_){}
+    , /*decltype(_impl_._cached_size_)*/{}
+    , /*decltype(_impl_._oneof_case_)*/{}
+  };
+  clear_has_value();
+}
+
+CompoundValue::~CompoundValue() {
+  // @@protoc_insertion_point(destructor:aapt.pb.CompoundValue)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void CompoundValue::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  if (has_value()) {
+    clear_value();
+  }
+}
+
+void CompoundValue::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void CompoundValue::clear_value() {
+// @@protoc_insertion_point(one_of_clear_start:aapt.pb.CompoundValue)
+  switch (value_case()) {
+    case kAttr: {
+      if (GetArenaForAllocation() == nullptr) {
+        delete _impl_.value_.attr_;
+      }
+      break;
+    }
+    case kStyle: {
+      if (GetArenaForAllocation() == nullptr) {
+        delete _impl_.value_.style_;
+      }
+      break;
+    }
+    case kStyleable: {
+      if (GetArenaForAllocation() == nullptr) {
+        delete _impl_.value_.styleable_;
+      }
+      break;
+    }
+    case kArray: {
+      if (GetArenaForAllocation() == nullptr) {
+        delete _impl_.value_.array_;
+      }
+      break;
+    }
+    case kPlural: {
+      if (GetArenaForAllocation() == nullptr) {
+        delete _impl_.value_.plural_;
+      }
+      break;
+    }
+    case kMacro: {
+      if (GetArenaForAllocation() == nullptr) {
+        delete _impl_.value_.macro_;
+      }
+      break;
+    }
+    case VALUE_NOT_SET: {
+      break;
+    }
+  }
+  _impl_._oneof_case_[0] = VALUE_NOT_SET;
+}
+
+
+void CompoundValue::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.CompoundValue)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  clear_value();
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* CompoundValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.Attribute attr = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr = ctx->ParseMessage(_internal_mutable_attr(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Style style = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          ptr = ctx->ParseMessage(_internal_mutable_style(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Styleable styleable = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          ptr = ctx->ParseMessage(_internal_mutable_styleable(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Array array = 4;
+      case 4:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
+          ptr = ctx->ParseMessage(_internal_mutable_array(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Plural plural = 5;
+      case 5:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
+          ptr = ctx->ParseMessage(_internal_mutable_plural(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.MacroBody macro = 6;
+      case 6:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
+          ptr = ctx->ParseMessage(_internal_mutable_macro(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* CompoundValue::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.CompoundValue)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.Attribute attr = 1;
+  if (_internal_has_attr()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(1, _Internal::attr(this),
+        _Internal::attr(this).GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.Style style = 2;
+  if (_internal_has_style()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(2, _Internal::style(this),
+        _Internal::style(this).GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.Styleable styleable = 3;
+  if (_internal_has_styleable()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(3, _Internal::styleable(this),
+        _Internal::styleable(this).GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.Array array = 4;
+  if (_internal_has_array()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(4, _Internal::array(this),
+        _Internal::array(this).GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.Plural plural = 5;
+  if (_internal_has_plural()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(5, _Internal::plural(this),
+        _Internal::plural(this).GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.MacroBody macro = 6;
+  if (_internal_has_macro()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(6, _Internal::macro(this),
+        _Internal::macro(this).GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.CompoundValue)
+  return target;
+}
+
+size_t CompoundValue::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.CompoundValue)
+  size_t total_size = 0;
+
+  switch (value_case()) {
+    // .aapt.pb.Attribute attr = 1;
+    case kAttr: {
+      total_size += 1 +
+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+          *_impl_.value_.attr_);
+      break;
+    }
+    // .aapt.pb.Style style = 2;
+    case kStyle: {
+      total_size += 1 +
+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+          *_impl_.value_.style_);
+      break;
+    }
+    // .aapt.pb.Styleable styleable = 3;
+    case kStyleable: {
+      total_size += 1 +
+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+          *_impl_.value_.styleable_);
+      break;
+    }
+    // .aapt.pb.Array array = 4;
+    case kArray: {
+      total_size += 1 +
+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+          *_impl_.value_.array_);
+      break;
+    }
+    // .aapt.pb.Plural plural = 5;
+    case kPlural: {
+      total_size += 1 +
+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+          *_impl_.value_.plural_);
+      break;
+    }
+    // .aapt.pb.MacroBody macro = 6;
+    case kMacro: {
+      total_size += 1 +
+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+          *_impl_.value_.macro_);
+      break;
+    }
+    case VALUE_NOT_SET: {
+      break;
+    }
+  }
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CompoundValue::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    CompoundValue::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CompoundValue::GetClassData() const { return &_class_data_; }
+
+
+void CompoundValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<CompoundValue*>(&to_msg);
+  auto& from = static_cast<const CompoundValue&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.CompoundValue)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  switch (from.value_case()) {
+    case kAttr: {
+      _this->_internal_mutable_attr()->::aapt::pb::Attribute::MergeFrom(
+          from._internal_attr());
+      break;
+    }
+    case kStyle: {
+      _this->_internal_mutable_style()->::aapt::pb::Style::MergeFrom(
+          from._internal_style());
+      break;
+    }
+    case kStyleable: {
+      _this->_internal_mutable_styleable()->::aapt::pb::Styleable::MergeFrom(
+          from._internal_styleable());
+      break;
+    }
+    case kArray: {
+      _this->_internal_mutable_array()->::aapt::pb::Array::MergeFrom(
+          from._internal_array());
+      break;
+    }
+    case kPlural: {
+      _this->_internal_mutable_plural()->::aapt::pb::Plural::MergeFrom(
+          from._internal_plural());
+      break;
+    }
+    case kMacro: {
+      _this->_internal_mutable_macro()->::aapt::pb::MacroBody::MergeFrom(
+          from._internal_macro());
+      break;
+    }
+    case VALUE_NOT_SET: {
+      break;
+    }
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void CompoundValue::CopyFrom(const CompoundValue& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.CompoundValue)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool CompoundValue::IsInitialized() const {
+  return true;
+}
+
+void CompoundValue::InternalSwap(CompoundValue* other) {
+  using std::swap;
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  swap(_impl_.value_, other->_impl_.value_);
+  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata CompoundValue::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[19]);
+}
+
+// ===================================================================
+
+class Boolean::_Internal {
+ public:
+};
+
+Boolean::Boolean(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Boolean)
+}
+Boolean::Boolean(const Boolean& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Boolean* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.value_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _this->_impl_.value_ = from._impl_.value_;
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Boolean)
+}
+
+inline void Boolean::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.value_){false}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+}
+
+Boolean::~Boolean() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Boolean)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Boolean::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+}
+
+void Boolean::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Boolean::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Boolean)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.value_ = false;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Boolean::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // bool value = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
+          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Boolean::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Boolean)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // bool value = 1;
+  if (this->_internal_value() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_value(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Boolean)
+  return target;
+}
+
+size_t Boolean::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Boolean)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // bool value = 1;
+  if (this->_internal_value() != 0) {
+    total_size += 1 + 1;
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Boolean::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Boolean::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Boolean::GetClassData() const { return &_class_data_; }
+
+
+void Boolean::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Boolean*>(&to_msg);
+  auto& from = static_cast<const Boolean&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Boolean)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (from._internal_value() != 0) {
+    _this->_internal_set_value(from._internal_value());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Boolean::CopyFrom(const Boolean& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Boolean)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Boolean::IsInitialized() const {
+  return true;
+}
+
+void Boolean::InternalSwap(Boolean* other) {
+  using std::swap;
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  swap(_impl_.value_, other->_impl_.value_);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Boolean::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[20]);
+}
+
+// ===================================================================
+
+class Reference::_Internal {
+ public:
+  static const ::aapt::pb::Boolean& is_dynamic(const Reference* msg);
+};
+
+const ::aapt::pb::Boolean&
+Reference::_Internal::is_dynamic(const Reference* msg) {
+  return *msg->_impl_.is_dynamic_;
+}
+Reference::Reference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Reference)
+}
+Reference::Reference(const Reference& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Reference* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.name_){}
+    , decltype(_impl_.is_dynamic_){nullptr}
+    , decltype(_impl_.type_){}
+    , decltype(_impl_.id_){}
+    , decltype(_impl_.private__){}
+    , decltype(_impl_.allow_raw_){}
+    , decltype(_impl_.type_flags_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_name().empty()) {
+    _this->_impl_.name_.Set(from._internal_name(), 
+      _this->GetArenaForAllocation());
+  }
+  if (from._internal_has_is_dynamic()) {
+    _this->_impl_.is_dynamic_ = new ::aapt::pb::Boolean(*from._impl_.is_dynamic_);
+  }
+  ::memcpy(&_impl_.type_, &from._impl_.type_,
+    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_flags_) -
+    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.type_flags_));
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Reference)
+}
+
+inline void Reference::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.name_){}
+    , decltype(_impl_.is_dynamic_){nullptr}
+    , decltype(_impl_.type_){0}
+    , decltype(_impl_.id_){0u}
+    , decltype(_impl_.private__){false}
+    , decltype(_impl_.allow_raw_){false}
+    , decltype(_impl_.type_flags_){0u}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+Reference::~Reference() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Reference)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Reference::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.name_.Destroy();
+  if (this != internal_default_instance()) delete _impl_.is_dynamic_;
+}
+
+void Reference::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Reference::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Reference)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.name_.ClearToEmpty();
+  if (GetArenaForAllocation() == nullptr && _impl_.is_dynamic_ != nullptr) {
+    delete _impl_.is_dynamic_;
+  }
+  _impl_.is_dynamic_ = nullptr;
+  ::memset(&_impl_.type_, 0, static_cast<size_t>(
+      reinterpret_cast<char*>(&_impl_.type_flags_) -
+      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.type_flags_));
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Reference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.Reference.Type type = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
+          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+          _internal_set_type(static_cast<::aapt::pb::Reference_Type>(val));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 id = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
+          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string name = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          auto str = _internal_mutable_name();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.Reference.name"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // bool private = 4;
+      case 4:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
+          _impl_.private__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Boolean is_dynamic = 5;
+      case 5:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
+          ptr = ctx->ParseMessage(_internal_mutable_is_dynamic(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 type_flags = 6;
+      case 6:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
+          _impl_.type_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // bool allow_raw = 7;
+      case 7:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
+          _impl_.allow_raw_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Reference::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Reference)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.Reference.Type type = 1;
+  if (this->_internal_type() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteEnumToArray(
+      1, this->_internal_type(), target);
+  }
+
+  // uint32 id = 2;
+  if (this->_internal_id() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_id(), target);
+  }
+
+  // string name = 3;
+  if (!this->_internal_name().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.Reference.name");
+    target = stream->WriteStringMaybeAliased(
+        3, this->_internal_name(), target);
+  }
+
+  // bool private = 4;
+  if (this->_internal_private_() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_private_(), target);
+  }
+
+  // .aapt.pb.Boolean is_dynamic = 5;
+  if (this->_internal_has_is_dynamic()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(5, _Internal::is_dynamic(this),
+        _Internal::is_dynamic(this).GetCachedSize(), target, stream);
+  }
+
+  // uint32 type_flags = 6;
+  if (this->_internal_type_flags() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_type_flags(), target);
+  }
+
+  // bool allow_raw = 7;
+  if (this->_internal_allow_raw() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_allow_raw(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Reference)
+  return target;
+}
+
+size_t Reference::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Reference)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string name = 3;
+  if (!this->_internal_name().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_name());
+  }
+
+  // .aapt.pb.Boolean is_dynamic = 5;
+  if (this->_internal_has_is_dynamic()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.is_dynamic_);
+  }
+
+  // .aapt.pb.Reference.Type type = 1;
+  if (this->_internal_type() != 0) {
+    total_size += 1 +
+      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
+  }
+
+  // uint32 id = 2;
+  if (this->_internal_id() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
+  }
+
+  // bool private = 4;
+  if (this->_internal_private_() != 0) {
+    total_size += 1 + 1;
+  }
+
+  // bool allow_raw = 7;
+  if (this->_internal_allow_raw() != 0) {
+    total_size += 1 + 1;
+  }
+
+  // uint32 type_flags = 6;
+  if (this->_internal_type_flags() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type_flags());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Reference::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Reference::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Reference::GetClassData() const { return &_class_data_; }
+
+
+void Reference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Reference*>(&to_msg);
+  auto& from = static_cast<const Reference&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Reference)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_name().empty()) {
+    _this->_internal_set_name(from._internal_name());
+  }
+  if (from._internal_has_is_dynamic()) {
+    _this->_internal_mutable_is_dynamic()->::aapt::pb::Boolean::MergeFrom(
+        from._internal_is_dynamic());
+  }
+  if (from._internal_type() != 0) {
+    _this->_internal_set_type(from._internal_type());
+  }
+  if (from._internal_id() != 0) {
+    _this->_internal_set_id(from._internal_id());
+  }
+  if (from._internal_private_() != 0) {
+    _this->_internal_set_private_(from._internal_private_());
+  }
+  if (from._internal_allow_raw() != 0) {
+    _this->_internal_set_allow_raw(from._internal_allow_raw());
+  }
+  if (from._internal_type_flags() != 0) {
+    _this->_internal_set_type_flags(from._internal_type_flags());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Reference::CopyFrom(const Reference& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Reference)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Reference::IsInitialized() const {
+  return true;
+}
+
+void Reference::InternalSwap(Reference* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.name_, lhs_arena,
+      &other->_impl_.name_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(Reference, _impl_.type_flags_)
+      + sizeof(Reference::_impl_.type_flags_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(Reference, _impl_.is_dynamic_)>(
+          reinterpret_cast<char*>(&_impl_.is_dynamic_),
+          reinterpret_cast<char*>(&other->_impl_.is_dynamic_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Reference::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[21]);
+}
+
+// ===================================================================
+
+class Id::_Internal {
+ public:
+};
+
+Id::Id(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Id)
+}
+Id::Id(const Id& from)
+  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
+  Id* const _this = this; (void)_this;
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Id)
+}
+
+
+
+
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Id::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
+    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Id::GetClassData() const { return &_class_data_; }
+
+
+
+
+
+
+
+::PROTOBUF_NAMESPACE_ID::Metadata Id::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[22]);
+}
+
+// ===================================================================
+
+class String::_Internal {
+ public:
+};
+
+String::String(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.String)
+}
+String::String(const String& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  String* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.value_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.value_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.value_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_value().empty()) {
+    _this->_impl_.value_.Set(from._internal_value(), 
+      _this->GetArenaForAllocation());
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.String)
+}
+
+inline void String::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.value_){}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.value_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.value_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+String::~String() {
+  // @@protoc_insertion_point(destructor:aapt.pb.String)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void String::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.value_.Destroy();
+}
+
+void String::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void String::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.String)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.value_.ClearToEmpty();
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* String::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // string value = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          auto str = _internal_mutable_value();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.String.value"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* String::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.String)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // string value = 1;
+  if (!this->_internal_value().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.String.value");
+    target = stream->WriteStringMaybeAliased(
+        1, this->_internal_value(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.String)
+  return target;
+}
+
+size_t String::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.String)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string value = 1;
+  if (!this->_internal_value().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_value());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData String::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    String::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*String::GetClassData() const { return &_class_data_; }
+
+
+void String::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<String*>(&to_msg);
+  auto& from = static_cast<const String&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.String)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_value().empty()) {
+    _this->_internal_set_value(from._internal_value());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void String::CopyFrom(const String& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.String)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool String::IsInitialized() const {
+  return true;
+}
+
+void String::InternalSwap(String* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.value_, lhs_arena,
+      &other->_impl_.value_, rhs_arena
+  );
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata String::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[23]);
+}
+
+// ===================================================================
+
+class RawString::_Internal {
+ public:
+};
+
+RawString::RawString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.RawString)
+}
+RawString::RawString(const RawString& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  RawString* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.value_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.value_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.value_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_value().empty()) {
+    _this->_impl_.value_.Set(from._internal_value(), 
+      _this->GetArenaForAllocation());
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.RawString)
+}
+
+inline void RawString::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.value_){}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.value_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.value_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+RawString::~RawString() {
+  // @@protoc_insertion_point(destructor:aapt.pb.RawString)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void RawString::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.value_.Destroy();
+}
+
+void RawString::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void RawString::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.RawString)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.value_.ClearToEmpty();
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* RawString::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // string value = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          auto str = _internal_mutable_value();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.RawString.value"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* RawString::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.RawString)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // string value = 1;
+  if (!this->_internal_value().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.RawString.value");
+    target = stream->WriteStringMaybeAliased(
+        1, this->_internal_value(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.RawString)
+  return target;
+}
+
+size_t RawString::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.RawString)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string value = 1;
+  if (!this->_internal_value().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_value());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RawString::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    RawString::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RawString::GetClassData() const { return &_class_data_; }
+
+
+void RawString::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<RawString*>(&to_msg);
+  auto& from = static_cast<const RawString&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.RawString)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_value().empty()) {
+    _this->_internal_set_value(from._internal_value());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void RawString::CopyFrom(const RawString& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.RawString)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool RawString::IsInitialized() const {
+  return true;
+}
+
+void RawString::InternalSwap(RawString* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.value_, lhs_arena,
+      &other->_impl_.value_, rhs_arena
+  );
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata RawString::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[24]);
+}
+
+// ===================================================================
+
+class StyledString_Span::_Internal {
+ public:
+};
+
+StyledString_Span::StyledString_Span(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.StyledString.Span)
+}
+StyledString_Span::StyledString_Span(const StyledString_Span& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  StyledString_Span* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.tag_){}
+    , decltype(_impl_.first_char_){}
+    , decltype(_impl_.last_char_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.tag_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.tag_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_tag().empty()) {
+    _this->_impl_.tag_.Set(from._internal_tag(), 
+      _this->GetArenaForAllocation());
+  }
+  ::memcpy(&_impl_.first_char_, &from._impl_.first_char_,
+    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.last_char_) -
+    reinterpret_cast<char*>(&_impl_.first_char_)) + sizeof(_impl_.last_char_));
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.StyledString.Span)
+}
+
+inline void StyledString_Span::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.tag_){}
+    , decltype(_impl_.first_char_){0u}
+    , decltype(_impl_.last_char_){0u}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.tag_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.tag_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+StyledString_Span::~StyledString_Span() {
+  // @@protoc_insertion_point(destructor:aapt.pb.StyledString.Span)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void StyledString_Span::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.tag_.Destroy();
+}
+
+void StyledString_Span::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void StyledString_Span::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.StyledString.Span)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.tag_.ClearToEmpty();
+  ::memset(&_impl_.first_char_, 0, static_cast<size_t>(
+      reinterpret_cast<char*>(&_impl_.last_char_) -
+      reinterpret_cast<char*>(&_impl_.first_char_)) + sizeof(_impl_.last_char_));
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* StyledString_Span::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // string tag = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          auto str = _internal_mutable_tag();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.StyledString.Span.tag"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 first_char = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
+          _impl_.first_char_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 last_char = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
+          _impl_.last_char_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* StyledString_Span::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.StyledString.Span)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // string tag = 1;
+  if (!this->_internal_tag().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.StyledString.Span.tag");
+    target = stream->WriteStringMaybeAliased(
+        1, this->_internal_tag(), target);
+  }
+
+  // uint32 first_char = 2;
+  if (this->_internal_first_char() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_first_char(), target);
+  }
+
+  // uint32 last_char = 3;
+  if (this->_internal_last_char() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_last_char(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.StyledString.Span)
+  return target;
+}
+
+size_t StyledString_Span::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.StyledString.Span)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string tag = 1;
+  if (!this->_internal_tag().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_tag());
+  }
+
+  // uint32 first_char = 2;
+  if (this->_internal_first_char() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_first_char());
+  }
+
+  // uint32 last_char = 3;
+  if (this->_internal_last_char() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_last_char());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyledString_Span::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    StyledString_Span::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyledString_Span::GetClassData() const { return &_class_data_; }
+
+
+void StyledString_Span::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<StyledString_Span*>(&to_msg);
+  auto& from = static_cast<const StyledString_Span&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.StyledString.Span)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_tag().empty()) {
+    _this->_internal_set_tag(from._internal_tag());
+  }
+  if (from._internal_first_char() != 0) {
+    _this->_internal_set_first_char(from._internal_first_char());
+  }
+  if (from._internal_last_char() != 0) {
+    _this->_internal_set_last_char(from._internal_last_char());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void StyledString_Span::CopyFrom(const StyledString_Span& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.StyledString.Span)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StyledString_Span::IsInitialized() const {
+  return true;
+}
+
+void StyledString_Span::InternalSwap(StyledString_Span* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.tag_, lhs_arena,
+      &other->_impl_.tag_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(StyledString_Span, _impl_.last_char_)
+      + sizeof(StyledString_Span::_impl_.last_char_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(StyledString_Span, _impl_.first_char_)>(
+          reinterpret_cast<char*>(&_impl_.first_char_),
+          reinterpret_cast<char*>(&other->_impl_.first_char_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata StyledString_Span::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[25]);
+}
+
+// ===================================================================
+
+class StyledString::_Internal {
+ public:
+};
+
+StyledString::StyledString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.StyledString)
+}
+StyledString::StyledString(const StyledString& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  StyledString* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.span_){from._impl_.span_}
+    , decltype(_impl_.value_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.value_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.value_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_value().empty()) {
+    _this->_impl_.value_.Set(from._internal_value(), 
+      _this->GetArenaForAllocation());
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.StyledString)
+}
+
+inline void StyledString::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.span_){arena}
+    , decltype(_impl_.value_){}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.value_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.value_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+StyledString::~StyledString() {
+  // @@protoc_insertion_point(destructor:aapt.pb.StyledString)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void StyledString::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.span_.~RepeatedPtrField();
+  _impl_.value_.Destroy();
+}
+
+void StyledString::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void StyledString::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.StyledString)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.span_.Clear();
+  _impl_.value_.ClearToEmpty();
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* StyledString::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // string value = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          auto str = _internal_mutable_value();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.StyledString.value"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // repeated .aapt.pb.StyledString.Span span = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          ptr -= 1;
+          do {
+            ptr += 1;
+            ptr = ctx->ParseMessage(_internal_add_span(), ptr);
+            CHK_(ptr);
+            if (!ctx->DataAvailable(ptr)) break;
+          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* StyledString::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.StyledString)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // string value = 1;
+  if (!this->_internal_value().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.StyledString.value");
+    target = stream->WriteStringMaybeAliased(
+        1, this->_internal_value(), target);
+  }
+
+  // repeated .aapt.pb.StyledString.Span span = 2;
+  for (unsigned i = 0,
+      n = static_cast<unsigned>(this->_internal_span_size()); i < n; i++) {
+    const auto& repfield = this->_internal_span(i);
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.StyledString)
+  return target;
+}
+
+size_t StyledString::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.StyledString)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // repeated .aapt.pb.StyledString.Span span = 2;
+  total_size += 1UL * this->_internal_span_size();
+  for (const auto& msg : this->_impl_.span_) {
+    total_size +=
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
+  }
+
+  // string value = 1;
+  if (!this->_internal_value().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_value());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyledString::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    StyledString::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyledString::GetClassData() const { return &_class_data_; }
+
+
+void StyledString::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<StyledString*>(&to_msg);
+  auto& from = static_cast<const StyledString&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.StyledString)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  _this->_impl_.span_.MergeFrom(from._impl_.span_);
+  if (!from._internal_value().empty()) {
+    _this->_internal_set_value(from._internal_value());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void StyledString::CopyFrom(const StyledString& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.StyledString)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StyledString::IsInitialized() const {
+  return true;
+}
+
+void StyledString::InternalSwap(StyledString* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  _impl_.span_.InternalSwap(&other->_impl_.span_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.value_, lhs_arena,
+      &other->_impl_.value_, rhs_arena
+  );
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata StyledString::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[26]);
+}
+
+// ===================================================================
+
+class FileReference::_Internal {
+ public:
+};
+
+FileReference::FileReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.FileReference)
+}
+FileReference::FileReference(const FileReference& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  FileReference* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.path_){}
+    , decltype(_impl_.type_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.path_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.path_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_path().empty()) {
+    _this->_impl_.path_.Set(from._internal_path(), 
+      _this->GetArenaForAllocation());
+  }
+  _this->_impl_.type_ = from._impl_.type_;
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.FileReference)
+}
+
+inline void FileReference::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.path_){}
+    , decltype(_impl_.type_){0}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.path_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.path_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+FileReference::~FileReference() {
+  // @@protoc_insertion_point(destructor:aapt.pb.FileReference)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void FileReference::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.path_.Destroy();
+}
+
+void FileReference::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void FileReference::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.FileReference)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.path_.ClearToEmpty();
+  _impl_.type_ = 0;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* FileReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // string path = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          auto str = _internal_mutable_path();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.FileReference.path"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.FileReference.Type type = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
+          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+          _internal_set_type(static_cast<::aapt::pb::FileReference_Type>(val));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* FileReference::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.FileReference)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // string path = 1;
+  if (!this->_internal_path().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.FileReference.path");
+    target = stream->WriteStringMaybeAliased(
+        1, this->_internal_path(), target);
+  }
+
+  // .aapt.pb.FileReference.Type type = 2;
+  if (this->_internal_type() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteEnumToArray(
+      2, this->_internal_type(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.FileReference)
+  return target;
+}
+
+size_t FileReference::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.FileReference)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string path = 1;
+  if (!this->_internal_path().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_path());
+  }
+
+  // .aapt.pb.FileReference.Type type = 2;
+  if (this->_internal_type() != 0) {
+    total_size += 1 +
+      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FileReference::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    FileReference::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FileReference::GetClassData() const { return &_class_data_; }
+
+
+void FileReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<FileReference*>(&to_msg);
+  auto& from = static_cast<const FileReference&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.FileReference)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_path().empty()) {
+    _this->_internal_set_path(from._internal_path());
+  }
+  if (from._internal_type() != 0) {
+    _this->_internal_set_type(from._internal_type());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void FileReference::CopyFrom(const FileReference& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.FileReference)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool FileReference::IsInitialized() const {
+  return true;
+}
+
+void FileReference::InternalSwap(FileReference* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.path_, lhs_arena,
+      &other->_impl_.path_, rhs_arena
+  );
+  swap(_impl_.type_, other->_impl_.type_);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata FileReference::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[27]);
+}
+
+// ===================================================================
+
+class Primitive_NullType::_Internal {
+ public:
+};
+
+Primitive_NullType::Primitive_NullType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Primitive.NullType)
+}
+Primitive_NullType::Primitive_NullType(const Primitive_NullType& from)
+  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
+  Primitive_NullType* const _this = this; (void)_this;
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Primitive.NullType)
+}
+
+
+
+
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Primitive_NullType::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
+    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Primitive_NullType::GetClassData() const { return &_class_data_; }
+
+
+
+
+
+
+
+::PROTOBUF_NAMESPACE_ID::Metadata Primitive_NullType::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[28]);
+}
+
+// ===================================================================
+
+class Primitive_EmptyType::_Internal {
+ public:
+};
+
+Primitive_EmptyType::Primitive_EmptyType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Primitive.EmptyType)
+}
+Primitive_EmptyType::Primitive_EmptyType(const Primitive_EmptyType& from)
+  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
+  Primitive_EmptyType* const _this = this; (void)_this;
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Primitive.EmptyType)
+}
+
+
+
+
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Primitive_EmptyType::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
+    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Primitive_EmptyType::GetClassData() const { return &_class_data_; }
+
+
+
+
+
+
+
+::PROTOBUF_NAMESPACE_ID::Metadata Primitive_EmptyType::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[29]);
+}
+
+// ===================================================================
+
+class Primitive::_Internal {
+ public:
+  static const ::aapt::pb::Primitive_NullType& null_value(const Primitive* msg);
+  static const ::aapt::pb::Primitive_EmptyType& empty_value(const Primitive* msg);
+};
+
+const ::aapt::pb::Primitive_NullType&
+Primitive::_Internal::null_value(const Primitive* msg) {
+  return *msg->_impl_.oneof_value_.null_value_;
+}
+const ::aapt::pb::Primitive_EmptyType&
+Primitive::_Internal::empty_value(const Primitive* msg) {
+  return *msg->_impl_.oneof_value_.empty_value_;
+}
+void Primitive::set_allocated_null_value(::aapt::pb::Primitive_NullType* null_value) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  clear_oneof_value();
+  if (null_value) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(null_value);
+    if (message_arena != submessage_arena) {
+      null_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, null_value, submessage_arena);
+    }
+    set_has_null_value();
+    _impl_.oneof_value_.null_value_ = null_value;
+  }
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Primitive.null_value)
+}
+void Primitive::set_allocated_empty_value(::aapt::pb::Primitive_EmptyType* empty_value) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  clear_oneof_value();
+  if (empty_value) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(empty_value);
+    if (message_arena != submessage_arena) {
+      empty_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, empty_value, submessage_arena);
+    }
+    set_has_empty_value();
+    _impl_.oneof_value_.empty_value_ = empty_value;
+  }
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Primitive.empty_value)
+}
+Primitive::Primitive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Primitive)
+}
+Primitive::Primitive(const Primitive& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Primitive* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.oneof_value_){}
+    , /*decltype(_impl_._cached_size_)*/{}
+    , /*decltype(_impl_._oneof_case_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  clear_has_oneof_value();
+  switch (from.oneof_value_case()) {
+    case kNullValue: {
+      _this->_internal_mutable_null_value()->::aapt::pb::Primitive_NullType::MergeFrom(
+          from._internal_null_value());
+      break;
+    }
+    case kEmptyValue: {
+      _this->_internal_mutable_empty_value()->::aapt::pb::Primitive_EmptyType::MergeFrom(
+          from._internal_empty_value());
+      break;
+    }
+    case kFloatValue: {
+      _this->_internal_set_float_value(from._internal_float_value());
+      break;
+    }
+    case kDimensionValue: {
+      _this->_internal_set_dimension_value(from._internal_dimension_value());
+      break;
+    }
+    case kFractionValue: {
+      _this->_internal_set_fraction_value(from._internal_fraction_value());
+      break;
+    }
+    case kIntDecimalValue: {
+      _this->_internal_set_int_decimal_value(from._internal_int_decimal_value());
+      break;
+    }
+    case kIntHexadecimalValue: {
+      _this->_internal_set_int_hexadecimal_value(from._internal_int_hexadecimal_value());
+      break;
+    }
+    case kBooleanValue: {
+      _this->_internal_set_boolean_value(from._internal_boolean_value());
+      break;
+    }
+    case kColorArgb8Value: {
+      _this->_internal_set_color_argb8_value(from._internal_color_argb8_value());
+      break;
+    }
+    case kColorRgb8Value: {
+      _this->_internal_set_color_rgb8_value(from._internal_color_rgb8_value());
+      break;
+    }
+    case kColorArgb4Value: {
+      _this->_internal_set_color_argb4_value(from._internal_color_argb4_value());
+      break;
+    }
+    case kColorRgb4Value: {
+      _this->_internal_set_color_rgb4_value(from._internal_color_rgb4_value());
+      break;
+    }
+    case kDimensionValueDeprecated: {
+      _this->_internal_set_dimension_value_deprecated(from._internal_dimension_value_deprecated());
+      break;
+    }
+    case kFractionValueDeprecated: {
+      _this->_internal_set_fraction_value_deprecated(from._internal_fraction_value_deprecated());
+      break;
+    }
+    case ONEOF_VALUE_NOT_SET: {
+      break;
+    }
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Primitive)
+}
+
+inline void Primitive::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.oneof_value_){}
+    , /*decltype(_impl_._cached_size_)*/{}
+    , /*decltype(_impl_._oneof_case_)*/{}
+  };
+  clear_has_oneof_value();
+}
+
+Primitive::~Primitive() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Primitive)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Primitive::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  if (has_oneof_value()) {
+    clear_oneof_value();
+  }
+}
+
+void Primitive::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Primitive::clear_oneof_value() {
+// @@protoc_insertion_point(one_of_clear_start:aapt.pb.Primitive)
+  switch (oneof_value_case()) {
+    case kNullValue: {
+      if (GetArenaForAllocation() == nullptr) {
+        delete _impl_.oneof_value_.null_value_;
+      }
+      break;
+    }
+    case kEmptyValue: {
+      if (GetArenaForAllocation() == nullptr) {
+        delete _impl_.oneof_value_.empty_value_;
+      }
+      break;
+    }
+    case kFloatValue: {
+      // No need to clear
+      break;
+    }
+    case kDimensionValue: {
+      // No need to clear
+      break;
+    }
+    case kFractionValue: {
+      // No need to clear
+      break;
+    }
+    case kIntDecimalValue: {
+      // No need to clear
+      break;
+    }
+    case kIntHexadecimalValue: {
+      // No need to clear
+      break;
+    }
+    case kBooleanValue: {
+      // No need to clear
+      break;
+    }
+    case kColorArgb8Value: {
+      // No need to clear
+      break;
+    }
+    case kColorRgb8Value: {
+      // No need to clear
+      break;
+    }
+    case kColorArgb4Value: {
+      // No need to clear
+      break;
+    }
+    case kColorRgb4Value: {
+      // No need to clear
+      break;
+    }
+    case kDimensionValueDeprecated: {
+      // No need to clear
+      break;
+    }
+    case kFractionValueDeprecated: {
+      // No need to clear
+      break;
+    }
+    case ONEOF_VALUE_NOT_SET: {
+      break;
+    }
+  }
+  _impl_._oneof_case_[0] = ONEOF_VALUE_NOT_SET;
+}
+
+
+void Primitive::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Primitive)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  clear_oneof_value();
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Primitive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.Primitive.NullType null_value = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr = ctx->ParseMessage(_internal_mutable_null_value(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Primitive.EmptyType empty_value = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          ptr = ctx->ParseMessage(_internal_mutable_empty_value(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // float float_value = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
+          _internal_set_float_value(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
+          ptr += sizeof(float);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // float dimension_value_deprecated = 4 [deprecated = true];
+      case 4:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 37)) {
+          _internal_set_dimension_value_deprecated(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
+          ptr += sizeof(float);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // float fraction_value_deprecated = 5 [deprecated = true];
+      case 5:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 45)) {
+          _internal_set_fraction_value_deprecated(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
+          ptr += sizeof(float);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // int32 int_decimal_value = 6;
+      case 6:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
+          _internal_set_int_decimal_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 int_hexadecimal_value = 7;
+      case 7:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
+          _internal_set_int_hexadecimal_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // bool boolean_value = 8;
+      case 8:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
+          _internal_set_boolean_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 color_argb8_value = 9;
+      case 9:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
+          _internal_set_color_argb8_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 color_rgb8_value = 10;
+      case 10:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
+          _internal_set_color_rgb8_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 color_argb4_value = 11;
+      case 11:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
+          _internal_set_color_argb4_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 color_rgb4_value = 12;
+      case 12:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
+          _internal_set_color_rgb4_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 dimension_value = 13;
+      case 13:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
+          _internal_set_dimension_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 fraction_value = 14;
+      case 14:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
+          _internal_set_fraction_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Primitive::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Primitive)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.Primitive.NullType null_value = 1;
+  if (_internal_has_null_value()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(1, _Internal::null_value(this),
+        _Internal::null_value(this).GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.Primitive.EmptyType empty_value = 2;
+  if (_internal_has_empty_value()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(2, _Internal::empty_value(this),
+        _Internal::empty_value(this).GetCachedSize(), target, stream);
+  }
+
+  // float float_value = 3;
+  if (_internal_has_float_value()) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_float_value(), target);
+  }
+
+  // float dimension_value_deprecated = 4 [deprecated = true];
+  if (_internal_has_dimension_value_deprecated()) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_dimension_value_deprecated(), target);
+  }
+
+  // float fraction_value_deprecated = 5 [deprecated = true];
+  if (_internal_has_fraction_value_deprecated()) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_fraction_value_deprecated(), target);
+  }
+
+  // int32 int_decimal_value = 6;
+  if (_internal_has_int_decimal_value()) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_int_decimal_value(), target);
+  }
+
+  // uint32 int_hexadecimal_value = 7;
+  if (_internal_has_int_hexadecimal_value()) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_int_hexadecimal_value(), target);
+  }
+
+  // bool boolean_value = 8;
+  if (_internal_has_boolean_value()) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_boolean_value(), target);
+  }
+
+  // uint32 color_argb8_value = 9;
+  if (_internal_has_color_argb8_value()) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_color_argb8_value(), target);
+  }
+
+  // uint32 color_rgb8_value = 10;
+  if (_internal_has_color_rgb8_value()) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_color_rgb8_value(), target);
+  }
+
+  // uint32 color_argb4_value = 11;
+  if (_internal_has_color_argb4_value()) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_color_argb4_value(), target);
+  }
+
+  // uint32 color_rgb4_value = 12;
+  if (_internal_has_color_rgb4_value()) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_color_rgb4_value(), target);
+  }
+
+  // uint32 dimension_value = 13;
+  if (_internal_has_dimension_value()) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_dimension_value(), target);
+  }
+
+  // uint32 fraction_value = 14;
+  if (_internal_has_fraction_value()) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_fraction_value(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Primitive)
+  return target;
+}
+
+size_t Primitive::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Primitive)
+  size_t total_size = 0;
+
+  switch (oneof_value_case()) {
+    // .aapt.pb.Primitive.NullType null_value = 1;
+    case kNullValue: {
+      total_size += 1 +
+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+          *_impl_.oneof_value_.null_value_);
+      break;
+    }
+    // .aapt.pb.Primitive.EmptyType empty_value = 2;
+    case kEmptyValue: {
+      total_size += 1 +
+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+          *_impl_.oneof_value_.empty_value_);
+      break;
+    }
+    // float float_value = 3;
+    case kFloatValue: {
+      total_size += 1 + 4;
+      break;
+    }
+    // uint32 dimension_value = 13;
+    case kDimensionValue: {
+      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dimension_value());
+      break;
+    }
+    // uint32 fraction_value = 14;
+    case kFractionValue: {
+      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fraction_value());
+      break;
+    }
+    // int32 int_decimal_value = 6;
+    case kIntDecimalValue: {
+      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_int_decimal_value());
+      break;
+    }
+    // uint32 int_hexadecimal_value = 7;
+    case kIntHexadecimalValue: {
+      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_int_hexadecimal_value());
+      break;
+    }
+    // bool boolean_value = 8;
+    case kBooleanValue: {
+      total_size += 1 + 1;
+      break;
+    }
+    // uint32 color_argb8_value = 9;
+    case kColorArgb8Value: {
+      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_color_argb8_value());
+      break;
+    }
+    // uint32 color_rgb8_value = 10;
+    case kColorRgb8Value: {
+      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_color_rgb8_value());
+      break;
+    }
+    // uint32 color_argb4_value = 11;
+    case kColorArgb4Value: {
+      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_color_argb4_value());
+      break;
+    }
+    // uint32 color_rgb4_value = 12;
+    case kColorRgb4Value: {
+      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_color_rgb4_value());
+      break;
+    }
+    // float dimension_value_deprecated = 4 [deprecated = true];
+    case kDimensionValueDeprecated: {
+      total_size += 1 + 4;
+      break;
+    }
+    // float fraction_value_deprecated = 5 [deprecated = true];
+    case kFractionValueDeprecated: {
+      total_size += 1 + 4;
+      break;
+    }
+    case ONEOF_VALUE_NOT_SET: {
+      break;
+    }
+  }
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Primitive::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Primitive::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Primitive::GetClassData() const { return &_class_data_; }
+
+
+void Primitive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Primitive*>(&to_msg);
+  auto& from = static_cast<const Primitive&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Primitive)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  switch (from.oneof_value_case()) {
+    case kNullValue: {
+      _this->_internal_mutable_null_value()->::aapt::pb::Primitive_NullType::MergeFrom(
+          from._internal_null_value());
+      break;
+    }
+    case kEmptyValue: {
+      _this->_internal_mutable_empty_value()->::aapt::pb::Primitive_EmptyType::MergeFrom(
+          from._internal_empty_value());
+      break;
+    }
+    case kFloatValue: {
+      _this->_internal_set_float_value(from._internal_float_value());
+      break;
+    }
+    case kDimensionValue: {
+      _this->_internal_set_dimension_value(from._internal_dimension_value());
+      break;
+    }
+    case kFractionValue: {
+      _this->_internal_set_fraction_value(from._internal_fraction_value());
+      break;
+    }
+    case kIntDecimalValue: {
+      _this->_internal_set_int_decimal_value(from._internal_int_decimal_value());
+      break;
+    }
+    case kIntHexadecimalValue: {
+      _this->_internal_set_int_hexadecimal_value(from._internal_int_hexadecimal_value());
+      break;
+    }
+    case kBooleanValue: {
+      _this->_internal_set_boolean_value(from._internal_boolean_value());
+      break;
+    }
+    case kColorArgb8Value: {
+      _this->_internal_set_color_argb8_value(from._internal_color_argb8_value());
+      break;
+    }
+    case kColorRgb8Value: {
+      _this->_internal_set_color_rgb8_value(from._internal_color_rgb8_value());
+      break;
+    }
+    case kColorArgb4Value: {
+      _this->_internal_set_color_argb4_value(from._internal_color_argb4_value());
+      break;
+    }
+    case kColorRgb4Value: {
+      _this->_internal_set_color_rgb4_value(from._internal_color_rgb4_value());
+      break;
+    }
+    case kDimensionValueDeprecated: {
+      _this->_internal_set_dimension_value_deprecated(from._internal_dimension_value_deprecated());
+      break;
+    }
+    case kFractionValueDeprecated: {
+      _this->_internal_set_fraction_value_deprecated(from._internal_fraction_value_deprecated());
+      break;
+    }
+    case ONEOF_VALUE_NOT_SET: {
+      break;
+    }
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Primitive::CopyFrom(const Primitive& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Primitive)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Primitive::IsInitialized() const {
+  return true;
+}
+
+void Primitive::InternalSwap(Primitive* other) {
+  using std::swap;
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  swap(_impl_.oneof_value_, other->_impl_.oneof_value_);
+  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Primitive::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[30]);
+}
+
+// ===================================================================
+
+class Attribute_Symbol::_Internal {
+ public:
+  static const ::aapt::pb::Source& source(const Attribute_Symbol* msg);
+  static const ::aapt::pb::Reference& name(const Attribute_Symbol* msg);
+};
+
+const ::aapt::pb::Source&
+Attribute_Symbol::_Internal::source(const Attribute_Symbol* msg) {
+  return *msg->_impl_.source_;
+}
+const ::aapt::pb::Reference&
+Attribute_Symbol::_Internal::name(const Attribute_Symbol* msg) {
+  return *msg->_impl_.name_;
+}
+Attribute_Symbol::Attribute_Symbol(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Attribute.Symbol)
+}
+Attribute_Symbol::Attribute_Symbol(const Attribute_Symbol& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Attribute_Symbol* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.comment_){}
+    , decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.name_){nullptr}
+    , decltype(_impl_.value_){}
+    , decltype(_impl_.type_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.comment_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_comment().empty()) {
+    _this->_impl_.comment_.Set(from._internal_comment(), 
+      _this->GetArenaForAllocation());
+  }
+  if (from._internal_has_source()) {
+    _this->_impl_.source_ = new ::aapt::pb::Source(*from._impl_.source_);
+  }
+  if (from._internal_has_name()) {
+    _this->_impl_.name_ = new ::aapt::pb::Reference(*from._impl_.name_);
+  }
+  ::memcpy(&_impl_.value_, &from._impl_.value_,
+    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
+    reinterpret_cast<char*>(&_impl_.value_)) + sizeof(_impl_.type_));
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Attribute.Symbol)
+}
+
+inline void Attribute_Symbol::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.comment_){}
+    , decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.name_){nullptr}
+    , decltype(_impl_.value_){0u}
+    , decltype(_impl_.type_){0u}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.comment_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+Attribute_Symbol::~Attribute_Symbol() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Attribute.Symbol)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Attribute_Symbol::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.comment_.Destroy();
+  if (this != internal_default_instance()) delete _impl_.source_;
+  if (this != internal_default_instance()) delete _impl_.name_;
+}
+
+void Attribute_Symbol::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Attribute_Symbol::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Attribute.Symbol)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.comment_.ClearToEmpty();
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+  if (GetArenaForAllocation() == nullptr && _impl_.name_ != nullptr) {
+    delete _impl_.name_;
+  }
+  _impl_.name_ = nullptr;
+  ::memset(&_impl_.value_, 0, static_cast<size_t>(
+      reinterpret_cast<char*>(&_impl_.type_) -
+      reinterpret_cast<char*>(&_impl_.value_)) + sizeof(_impl_.type_));
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Attribute_Symbol::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.Source source = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string comment = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          auto str = _internal_mutable_comment();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.Attribute.Symbol.comment"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Reference name = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          ptr = ctx->ParseMessage(_internal_mutable_name(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 value = 4;
+      case 4:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
+          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 type = 5;
+      case 5:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
+          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Attribute_Symbol::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Attribute.Symbol)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.Source source = 1;
+  if (this->_internal_has_source()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(1, _Internal::source(this),
+        _Internal::source(this).GetCachedSize(), target, stream);
+  }
+
+  // string comment = 2;
+  if (!this->_internal_comment().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_comment().data(), static_cast<int>(this->_internal_comment().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.Attribute.Symbol.comment");
+    target = stream->WriteStringMaybeAliased(
+        2, this->_internal_comment(), target);
+  }
+
+  // .aapt.pb.Reference name = 3;
+  if (this->_internal_has_name()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(3, _Internal::name(this),
+        _Internal::name(this).GetCachedSize(), target, stream);
+  }
+
+  // uint32 value = 4;
+  if (this->_internal_value() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_value(), target);
+  }
+
+  // uint32 type = 5;
+  if (this->_internal_type() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_type(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Attribute.Symbol)
+  return target;
+}
+
+size_t Attribute_Symbol::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Attribute.Symbol)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string comment = 2;
+  if (!this->_internal_comment().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_comment());
+  }
+
+  // .aapt.pb.Source source = 1;
+  if (this->_internal_has_source()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.source_);
+  }
+
+  // .aapt.pb.Reference name = 3;
+  if (this->_internal_has_name()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.name_);
+  }
+
+  // uint32 value = 4;
+  if (this->_internal_value() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_value());
+  }
+
+  // uint32 type = 5;
+  if (this->_internal_type() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Attribute_Symbol::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Attribute_Symbol::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Attribute_Symbol::GetClassData() const { return &_class_data_; }
+
+
+void Attribute_Symbol::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Attribute_Symbol*>(&to_msg);
+  auto& from = static_cast<const Attribute_Symbol&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Attribute.Symbol)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_comment().empty()) {
+    _this->_internal_set_comment(from._internal_comment());
+  }
+  if (from._internal_has_source()) {
+    _this->_internal_mutable_source()->::aapt::pb::Source::MergeFrom(
+        from._internal_source());
+  }
+  if (from._internal_has_name()) {
+    _this->_internal_mutable_name()->::aapt::pb::Reference::MergeFrom(
+        from._internal_name());
+  }
+  if (from._internal_value() != 0) {
+    _this->_internal_set_value(from._internal_value());
+  }
+  if (from._internal_type() != 0) {
+    _this->_internal_set_type(from._internal_type());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Attribute_Symbol::CopyFrom(const Attribute_Symbol& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Attribute.Symbol)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Attribute_Symbol::IsInitialized() const {
+  return true;
+}
+
+void Attribute_Symbol::InternalSwap(Attribute_Symbol* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.comment_, lhs_arena,
+      &other->_impl_.comment_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(Attribute_Symbol, _impl_.type_)
+      + sizeof(Attribute_Symbol::_impl_.type_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(Attribute_Symbol, _impl_.source_)>(
+          reinterpret_cast<char*>(&_impl_.source_),
+          reinterpret_cast<char*>(&other->_impl_.source_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Attribute_Symbol::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[31]);
+}
+
+// ===================================================================
+
+class Attribute::_Internal {
+ public:
+};
+
+Attribute::Attribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Attribute)
+}
+Attribute::Attribute(const Attribute& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Attribute* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.symbol_){from._impl_.symbol_}
+    , decltype(_impl_.format_flags_){}
+    , decltype(_impl_.min_int_){}
+    , decltype(_impl_.max_int_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  ::memcpy(&_impl_.format_flags_, &from._impl_.format_flags_,
+    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_int_) -
+    reinterpret_cast<char*>(&_impl_.format_flags_)) + sizeof(_impl_.max_int_));
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Attribute)
+}
+
+inline void Attribute::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.symbol_){arena}
+    , decltype(_impl_.format_flags_){0u}
+    , decltype(_impl_.min_int_){0}
+    , decltype(_impl_.max_int_){0}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+}
+
+Attribute::~Attribute() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Attribute)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Attribute::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.symbol_.~RepeatedPtrField();
+}
+
+void Attribute::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Attribute::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Attribute)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.symbol_.Clear();
+  ::memset(&_impl_.format_flags_, 0, static_cast<size_t>(
+      reinterpret_cast<char*>(&_impl_.max_int_) -
+      reinterpret_cast<char*>(&_impl_.format_flags_)) + sizeof(_impl_.max_int_));
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Attribute::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // uint32 format_flags = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
+          _impl_.format_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // int32 min_int = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
+          _impl_.min_int_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // int32 max_int = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
+          _impl_.max_int_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // repeated .aapt.pb.Attribute.Symbol symbol = 4;
+      case 4:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
+          ptr -= 1;
+          do {
+            ptr += 1;
+            ptr = ctx->ParseMessage(_internal_add_symbol(), ptr);
+            CHK_(ptr);
+            if (!ctx->DataAvailable(ptr)) break;
+          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Attribute::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Attribute)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // uint32 format_flags = 1;
+  if (this->_internal_format_flags() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_format_flags(), target);
+  }
+
+  // int32 min_int = 2;
+  if (this->_internal_min_int() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_min_int(), target);
+  }
+
+  // int32 max_int = 3;
+  if (this->_internal_max_int() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_max_int(), target);
+  }
+
+  // repeated .aapt.pb.Attribute.Symbol symbol = 4;
+  for (unsigned i = 0,
+      n = static_cast<unsigned>(this->_internal_symbol_size()); i < n; i++) {
+    const auto& repfield = this->_internal_symbol(i);
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Attribute)
+  return target;
+}
+
+size_t Attribute::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Attribute)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // repeated .aapt.pb.Attribute.Symbol symbol = 4;
+  total_size += 1UL * this->_internal_symbol_size();
+  for (const auto& msg : this->_impl_.symbol_) {
+    total_size +=
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
+  }
+
+  // uint32 format_flags = 1;
+  if (this->_internal_format_flags() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_format_flags());
+  }
+
+  // int32 min_int = 2;
+  if (this->_internal_min_int() != 0) {
+    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_min_int());
+  }
+
+  // int32 max_int = 3;
+  if (this->_internal_max_int() != 0) {
+    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_int());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Attribute::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Attribute::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Attribute::GetClassData() const { return &_class_data_; }
+
+
+void Attribute::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Attribute*>(&to_msg);
+  auto& from = static_cast<const Attribute&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Attribute)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  _this->_impl_.symbol_.MergeFrom(from._impl_.symbol_);
+  if (from._internal_format_flags() != 0) {
+    _this->_internal_set_format_flags(from._internal_format_flags());
+  }
+  if (from._internal_min_int() != 0) {
+    _this->_internal_set_min_int(from._internal_min_int());
+  }
+  if (from._internal_max_int() != 0) {
+    _this->_internal_set_max_int(from._internal_max_int());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Attribute::CopyFrom(const Attribute& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Attribute)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Attribute::IsInitialized() const {
+  return true;
+}
+
+void Attribute::InternalSwap(Attribute* other) {
+  using std::swap;
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  _impl_.symbol_.InternalSwap(&other->_impl_.symbol_);
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(Attribute, _impl_.max_int_)
+      + sizeof(Attribute::_impl_.max_int_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(Attribute, _impl_.format_flags_)>(
+          reinterpret_cast<char*>(&_impl_.format_flags_),
+          reinterpret_cast<char*>(&other->_impl_.format_flags_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Attribute::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[32]);
+}
+
+// ===================================================================
+
+class Style_Entry::_Internal {
+ public:
+  static const ::aapt::pb::Source& source(const Style_Entry* msg);
+  static const ::aapt::pb::Reference& key(const Style_Entry* msg);
+  static const ::aapt::pb::Item& item(const Style_Entry* msg);
+};
+
+const ::aapt::pb::Source&
+Style_Entry::_Internal::source(const Style_Entry* msg) {
+  return *msg->_impl_.source_;
+}
+const ::aapt::pb::Reference&
+Style_Entry::_Internal::key(const Style_Entry* msg) {
+  return *msg->_impl_.key_;
+}
+const ::aapt::pb::Item&
+Style_Entry::_Internal::item(const Style_Entry* msg) {
+  return *msg->_impl_.item_;
+}
+Style_Entry::Style_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Style.Entry)
+}
+Style_Entry::Style_Entry(const Style_Entry& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Style_Entry* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.comment_){}
+    , decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.key_){nullptr}
+    , decltype(_impl_.item_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.comment_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_comment().empty()) {
+    _this->_impl_.comment_.Set(from._internal_comment(), 
+      _this->GetArenaForAllocation());
+  }
+  if (from._internal_has_source()) {
+    _this->_impl_.source_ = new ::aapt::pb::Source(*from._impl_.source_);
+  }
+  if (from._internal_has_key()) {
+    _this->_impl_.key_ = new ::aapt::pb::Reference(*from._impl_.key_);
+  }
+  if (from._internal_has_item()) {
+    _this->_impl_.item_ = new ::aapt::pb::Item(*from._impl_.item_);
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Style.Entry)
+}
+
+inline void Style_Entry::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.comment_){}
+    , decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.key_){nullptr}
+    , decltype(_impl_.item_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.comment_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+Style_Entry::~Style_Entry() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Style.Entry)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Style_Entry::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.comment_.Destroy();
+  if (this != internal_default_instance()) delete _impl_.source_;
+  if (this != internal_default_instance()) delete _impl_.key_;
+  if (this != internal_default_instance()) delete _impl_.item_;
+}
+
+void Style_Entry::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Style_Entry::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Style.Entry)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.comment_.ClearToEmpty();
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+  if (GetArenaForAllocation() == nullptr && _impl_.key_ != nullptr) {
+    delete _impl_.key_;
+  }
+  _impl_.key_ = nullptr;
+  if (GetArenaForAllocation() == nullptr && _impl_.item_ != nullptr) {
+    delete _impl_.item_;
+  }
+  _impl_.item_ = nullptr;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Style_Entry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.Source source = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string comment = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          auto str = _internal_mutable_comment();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.Style.Entry.comment"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Reference key = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Item item = 4;
+      case 4:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
+          ptr = ctx->ParseMessage(_internal_mutable_item(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Style_Entry::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Style.Entry)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.Source source = 1;
+  if (this->_internal_has_source()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(1, _Internal::source(this),
+        _Internal::source(this).GetCachedSize(), target, stream);
+  }
+
+  // string comment = 2;
+  if (!this->_internal_comment().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_comment().data(), static_cast<int>(this->_internal_comment().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.Style.Entry.comment");
+    target = stream->WriteStringMaybeAliased(
+        2, this->_internal_comment(), target);
+  }
+
+  // .aapt.pb.Reference key = 3;
+  if (this->_internal_has_key()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(3, _Internal::key(this),
+        _Internal::key(this).GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.Item item = 4;
+  if (this->_internal_has_item()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(4, _Internal::item(this),
+        _Internal::item(this).GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Style.Entry)
+  return target;
+}
+
+size_t Style_Entry::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Style.Entry)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string comment = 2;
+  if (!this->_internal_comment().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_comment());
+  }
+
+  // .aapt.pb.Source source = 1;
+  if (this->_internal_has_source()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.source_);
+  }
+
+  // .aapt.pb.Reference key = 3;
+  if (this->_internal_has_key()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.key_);
+  }
+
+  // .aapt.pb.Item item = 4;
+  if (this->_internal_has_item()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.item_);
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Style_Entry::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Style_Entry::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Style_Entry::GetClassData() const { return &_class_data_; }
+
+
+void Style_Entry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Style_Entry*>(&to_msg);
+  auto& from = static_cast<const Style_Entry&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Style.Entry)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_comment().empty()) {
+    _this->_internal_set_comment(from._internal_comment());
+  }
+  if (from._internal_has_source()) {
+    _this->_internal_mutable_source()->::aapt::pb::Source::MergeFrom(
+        from._internal_source());
+  }
+  if (from._internal_has_key()) {
+    _this->_internal_mutable_key()->::aapt::pb::Reference::MergeFrom(
+        from._internal_key());
+  }
+  if (from._internal_has_item()) {
+    _this->_internal_mutable_item()->::aapt::pb::Item::MergeFrom(
+        from._internal_item());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Style_Entry::CopyFrom(const Style_Entry& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Style.Entry)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Style_Entry::IsInitialized() const {
+  return true;
+}
+
+void Style_Entry::InternalSwap(Style_Entry* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.comment_, lhs_arena,
+      &other->_impl_.comment_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(Style_Entry, _impl_.item_)
+      + sizeof(Style_Entry::_impl_.item_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(Style_Entry, _impl_.source_)>(
+          reinterpret_cast<char*>(&_impl_.source_),
+          reinterpret_cast<char*>(&other->_impl_.source_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Style_Entry::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[33]);
+}
+
+// ===================================================================
+
+class Style::_Internal {
+ public:
+  static const ::aapt::pb::Reference& parent(const Style* msg);
+  static const ::aapt::pb::Source& parent_source(const Style* msg);
+};
+
+const ::aapt::pb::Reference&
+Style::_Internal::parent(const Style* msg) {
+  return *msg->_impl_.parent_;
+}
+const ::aapt::pb::Source&
+Style::_Internal::parent_source(const Style* msg) {
+  return *msg->_impl_.parent_source_;
+}
+Style::Style(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Style)
+}
+Style::Style(const Style& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Style* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.entry_){from._impl_.entry_}
+    , decltype(_impl_.parent_){nullptr}
+    , decltype(_impl_.parent_source_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  if (from._internal_has_parent()) {
+    _this->_impl_.parent_ = new ::aapt::pb::Reference(*from._impl_.parent_);
+  }
+  if (from._internal_has_parent_source()) {
+    _this->_impl_.parent_source_ = new ::aapt::pb::Source(*from._impl_.parent_source_);
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Style)
+}
+
+inline void Style::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.entry_){arena}
+    , decltype(_impl_.parent_){nullptr}
+    , decltype(_impl_.parent_source_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+}
+
+Style::~Style() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Style)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Style::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.entry_.~RepeatedPtrField();
+  if (this != internal_default_instance()) delete _impl_.parent_;
+  if (this != internal_default_instance()) delete _impl_.parent_source_;
+}
+
+void Style::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Style::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Style)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.entry_.Clear();
+  if (GetArenaForAllocation() == nullptr && _impl_.parent_ != nullptr) {
+    delete _impl_.parent_;
+  }
+  _impl_.parent_ = nullptr;
+  if (GetArenaForAllocation() == nullptr && _impl_.parent_source_ != nullptr) {
+    delete _impl_.parent_source_;
+  }
+  _impl_.parent_source_ = nullptr;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Style::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.Reference parent = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Source parent_source = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          ptr = ctx->ParseMessage(_internal_mutable_parent_source(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // repeated .aapt.pb.Style.Entry entry = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          ptr -= 1;
+          do {
+            ptr += 1;
+            ptr = ctx->ParseMessage(_internal_add_entry(), ptr);
+            CHK_(ptr);
+            if (!ctx->DataAvailable(ptr)) break;
+          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Style::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Style)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.Reference parent = 1;
+  if (this->_internal_has_parent()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(1, _Internal::parent(this),
+        _Internal::parent(this).GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.Source parent_source = 2;
+  if (this->_internal_has_parent_source()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(2, _Internal::parent_source(this),
+        _Internal::parent_source(this).GetCachedSize(), target, stream);
+  }
+
+  // repeated .aapt.pb.Style.Entry entry = 3;
+  for (unsigned i = 0,
+      n = static_cast<unsigned>(this->_internal_entry_size()); i < n; i++) {
+    const auto& repfield = this->_internal_entry(i);
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Style)
+  return target;
+}
+
+size_t Style::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Style)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // repeated .aapt.pb.Style.Entry entry = 3;
+  total_size += 1UL * this->_internal_entry_size();
+  for (const auto& msg : this->_impl_.entry_) {
+    total_size +=
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
+  }
+
+  // .aapt.pb.Reference parent = 1;
+  if (this->_internal_has_parent()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.parent_);
+  }
+
+  // .aapt.pb.Source parent_source = 2;
+  if (this->_internal_has_parent_source()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.parent_source_);
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Style::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Style::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Style::GetClassData() const { return &_class_data_; }
+
+
+void Style::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Style*>(&to_msg);
+  auto& from = static_cast<const Style&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Style)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  _this->_impl_.entry_.MergeFrom(from._impl_.entry_);
+  if (from._internal_has_parent()) {
+    _this->_internal_mutable_parent()->::aapt::pb::Reference::MergeFrom(
+        from._internal_parent());
+  }
+  if (from._internal_has_parent_source()) {
+    _this->_internal_mutable_parent_source()->::aapt::pb::Source::MergeFrom(
+        from._internal_parent_source());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Style::CopyFrom(const Style& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Style)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Style::IsInitialized() const {
+  return true;
+}
+
+void Style::InternalSwap(Style* other) {
+  using std::swap;
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  _impl_.entry_.InternalSwap(&other->_impl_.entry_);
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(Style, _impl_.parent_source_)
+      + sizeof(Style::_impl_.parent_source_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(Style, _impl_.parent_)>(
+          reinterpret_cast<char*>(&_impl_.parent_),
+          reinterpret_cast<char*>(&other->_impl_.parent_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Style::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[34]);
+}
+
+// ===================================================================
+
+class Styleable_Entry::_Internal {
+ public:
+  static const ::aapt::pb::Source& source(const Styleable_Entry* msg);
+  static const ::aapt::pb::Reference& attr(const Styleable_Entry* msg);
+};
+
+const ::aapt::pb::Source&
+Styleable_Entry::_Internal::source(const Styleable_Entry* msg) {
+  return *msg->_impl_.source_;
+}
+const ::aapt::pb::Reference&
+Styleable_Entry::_Internal::attr(const Styleable_Entry* msg) {
+  return *msg->_impl_.attr_;
+}
+Styleable_Entry::Styleable_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Styleable.Entry)
+}
+Styleable_Entry::Styleable_Entry(const Styleable_Entry& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Styleable_Entry* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.comment_){}
+    , decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.attr_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.comment_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_comment().empty()) {
+    _this->_impl_.comment_.Set(from._internal_comment(), 
+      _this->GetArenaForAllocation());
+  }
+  if (from._internal_has_source()) {
+    _this->_impl_.source_ = new ::aapt::pb::Source(*from._impl_.source_);
+  }
+  if (from._internal_has_attr()) {
+    _this->_impl_.attr_ = new ::aapt::pb::Reference(*from._impl_.attr_);
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Styleable.Entry)
+}
+
+inline void Styleable_Entry::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.comment_){}
+    , decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.attr_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.comment_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+Styleable_Entry::~Styleable_Entry() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Styleable.Entry)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Styleable_Entry::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.comment_.Destroy();
+  if (this != internal_default_instance()) delete _impl_.source_;
+  if (this != internal_default_instance()) delete _impl_.attr_;
+}
+
+void Styleable_Entry::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Styleable_Entry::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Styleable.Entry)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.comment_.ClearToEmpty();
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+  if (GetArenaForAllocation() == nullptr && _impl_.attr_ != nullptr) {
+    delete _impl_.attr_;
+  }
+  _impl_.attr_ = nullptr;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Styleable_Entry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.Source source = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string comment = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          auto str = _internal_mutable_comment();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.Styleable.Entry.comment"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Reference attr = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          ptr = ctx->ParseMessage(_internal_mutable_attr(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Styleable_Entry::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Styleable.Entry)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.Source source = 1;
+  if (this->_internal_has_source()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(1, _Internal::source(this),
+        _Internal::source(this).GetCachedSize(), target, stream);
+  }
+
+  // string comment = 2;
+  if (!this->_internal_comment().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_comment().data(), static_cast<int>(this->_internal_comment().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.Styleable.Entry.comment");
+    target = stream->WriteStringMaybeAliased(
+        2, this->_internal_comment(), target);
+  }
+
+  // .aapt.pb.Reference attr = 3;
+  if (this->_internal_has_attr()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(3, _Internal::attr(this),
+        _Internal::attr(this).GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Styleable.Entry)
+  return target;
+}
+
+size_t Styleable_Entry::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Styleable.Entry)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string comment = 2;
+  if (!this->_internal_comment().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_comment());
+  }
+
+  // .aapt.pb.Source source = 1;
+  if (this->_internal_has_source()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.source_);
+  }
+
+  // .aapt.pb.Reference attr = 3;
+  if (this->_internal_has_attr()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.attr_);
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Styleable_Entry::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Styleable_Entry::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Styleable_Entry::GetClassData() const { return &_class_data_; }
+
+
+void Styleable_Entry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Styleable_Entry*>(&to_msg);
+  auto& from = static_cast<const Styleable_Entry&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Styleable.Entry)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_comment().empty()) {
+    _this->_internal_set_comment(from._internal_comment());
+  }
+  if (from._internal_has_source()) {
+    _this->_internal_mutable_source()->::aapt::pb::Source::MergeFrom(
+        from._internal_source());
+  }
+  if (from._internal_has_attr()) {
+    _this->_internal_mutable_attr()->::aapt::pb::Reference::MergeFrom(
+        from._internal_attr());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Styleable_Entry::CopyFrom(const Styleable_Entry& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Styleable.Entry)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Styleable_Entry::IsInitialized() const {
+  return true;
+}
+
+void Styleable_Entry::InternalSwap(Styleable_Entry* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.comment_, lhs_arena,
+      &other->_impl_.comment_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(Styleable_Entry, _impl_.attr_)
+      + sizeof(Styleable_Entry::_impl_.attr_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(Styleable_Entry, _impl_.source_)>(
+          reinterpret_cast<char*>(&_impl_.source_),
+          reinterpret_cast<char*>(&other->_impl_.source_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Styleable_Entry::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[35]);
+}
+
+// ===================================================================
+
+class Styleable::_Internal {
+ public:
+};
+
+Styleable::Styleable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Styleable)
+}
+Styleable::Styleable(const Styleable& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Styleable* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.entry_){from._impl_.entry_}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Styleable)
+}
+
+inline void Styleable::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.entry_){arena}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+}
+
+Styleable::~Styleable() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Styleable)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Styleable::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.entry_.~RepeatedPtrField();
+}
+
+void Styleable::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Styleable::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Styleable)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.entry_.Clear();
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Styleable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // repeated .aapt.pb.Styleable.Entry entry = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr -= 1;
+          do {
+            ptr += 1;
+            ptr = ctx->ParseMessage(_internal_add_entry(), ptr);
+            CHK_(ptr);
+            if (!ctx->DataAvailable(ptr)) break;
+          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Styleable::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Styleable)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // repeated .aapt.pb.Styleable.Entry entry = 1;
+  for (unsigned i = 0,
+      n = static_cast<unsigned>(this->_internal_entry_size()); i < n; i++) {
+    const auto& repfield = this->_internal_entry(i);
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Styleable)
+  return target;
+}
+
+size_t Styleable::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Styleable)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // repeated .aapt.pb.Styleable.Entry entry = 1;
+  total_size += 1UL * this->_internal_entry_size();
+  for (const auto& msg : this->_impl_.entry_) {
+    total_size +=
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Styleable::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Styleable::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Styleable::GetClassData() const { return &_class_data_; }
+
+
+void Styleable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Styleable*>(&to_msg);
+  auto& from = static_cast<const Styleable&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Styleable)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  _this->_impl_.entry_.MergeFrom(from._impl_.entry_);
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Styleable::CopyFrom(const Styleable& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Styleable)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Styleable::IsInitialized() const {
+  return true;
+}
+
+void Styleable::InternalSwap(Styleable* other) {
+  using std::swap;
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  _impl_.entry_.InternalSwap(&other->_impl_.entry_);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Styleable::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[36]);
+}
+
+// ===================================================================
+
+class Array_Element::_Internal {
+ public:
+  static const ::aapt::pb::Source& source(const Array_Element* msg);
+  static const ::aapt::pb::Item& item(const Array_Element* msg);
+};
+
+const ::aapt::pb::Source&
+Array_Element::_Internal::source(const Array_Element* msg) {
+  return *msg->_impl_.source_;
+}
+const ::aapt::pb::Item&
+Array_Element::_Internal::item(const Array_Element* msg) {
+  return *msg->_impl_.item_;
+}
+Array_Element::Array_Element(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Array.Element)
+}
+Array_Element::Array_Element(const Array_Element& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Array_Element* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.comment_){}
+    , decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.item_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.comment_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_comment().empty()) {
+    _this->_impl_.comment_.Set(from._internal_comment(), 
+      _this->GetArenaForAllocation());
+  }
+  if (from._internal_has_source()) {
+    _this->_impl_.source_ = new ::aapt::pb::Source(*from._impl_.source_);
+  }
+  if (from._internal_has_item()) {
+    _this->_impl_.item_ = new ::aapt::pb::Item(*from._impl_.item_);
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Array.Element)
+}
+
+inline void Array_Element::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.comment_){}
+    , decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.item_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.comment_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+Array_Element::~Array_Element() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Array.Element)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Array_Element::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.comment_.Destroy();
+  if (this != internal_default_instance()) delete _impl_.source_;
+  if (this != internal_default_instance()) delete _impl_.item_;
+}
+
+void Array_Element::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Array_Element::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Array.Element)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.comment_.ClearToEmpty();
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+  if (GetArenaForAllocation() == nullptr && _impl_.item_ != nullptr) {
+    delete _impl_.item_;
+  }
+  _impl_.item_ = nullptr;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Array_Element::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.Source source = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string comment = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          auto str = _internal_mutable_comment();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.Array.Element.comment"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Item item = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          ptr = ctx->ParseMessage(_internal_mutable_item(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Array_Element::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Array.Element)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.Source source = 1;
+  if (this->_internal_has_source()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(1, _Internal::source(this),
+        _Internal::source(this).GetCachedSize(), target, stream);
+  }
+
+  // string comment = 2;
+  if (!this->_internal_comment().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_comment().data(), static_cast<int>(this->_internal_comment().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.Array.Element.comment");
+    target = stream->WriteStringMaybeAliased(
+        2, this->_internal_comment(), target);
+  }
+
+  // .aapt.pb.Item item = 3;
+  if (this->_internal_has_item()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(3, _Internal::item(this),
+        _Internal::item(this).GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Array.Element)
+  return target;
+}
+
+size_t Array_Element::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Array.Element)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string comment = 2;
+  if (!this->_internal_comment().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_comment());
+  }
+
+  // .aapt.pb.Source source = 1;
+  if (this->_internal_has_source()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.source_);
+  }
+
+  // .aapt.pb.Item item = 3;
+  if (this->_internal_has_item()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.item_);
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Array_Element::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Array_Element::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Array_Element::GetClassData() const { return &_class_data_; }
+
+
+void Array_Element::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Array_Element*>(&to_msg);
+  auto& from = static_cast<const Array_Element&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Array.Element)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_comment().empty()) {
+    _this->_internal_set_comment(from._internal_comment());
+  }
+  if (from._internal_has_source()) {
+    _this->_internal_mutable_source()->::aapt::pb::Source::MergeFrom(
+        from._internal_source());
+  }
+  if (from._internal_has_item()) {
+    _this->_internal_mutable_item()->::aapt::pb::Item::MergeFrom(
+        from._internal_item());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Array_Element::CopyFrom(const Array_Element& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Array.Element)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Array_Element::IsInitialized() const {
+  return true;
+}
+
+void Array_Element::InternalSwap(Array_Element* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.comment_, lhs_arena,
+      &other->_impl_.comment_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(Array_Element, _impl_.item_)
+      + sizeof(Array_Element::_impl_.item_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(Array_Element, _impl_.source_)>(
+          reinterpret_cast<char*>(&_impl_.source_),
+          reinterpret_cast<char*>(&other->_impl_.source_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Array_Element::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[37]);
+}
+
+// ===================================================================
+
+class Array::_Internal {
+ public:
+};
+
+Array::Array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Array)
+}
+Array::Array(const Array& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Array* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.element_){from._impl_.element_}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Array)
+}
+
+inline void Array::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.element_){arena}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+}
+
+Array::~Array() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Array)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Array::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.element_.~RepeatedPtrField();
+}
+
+void Array::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Array::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Array)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.element_.Clear();
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Array::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // repeated .aapt.pb.Array.Element element = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr -= 1;
+          do {
+            ptr += 1;
+            ptr = ctx->ParseMessage(_internal_add_element(), ptr);
+            CHK_(ptr);
+            if (!ctx->DataAvailable(ptr)) break;
+          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Array::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Array)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // repeated .aapt.pb.Array.Element element = 1;
+  for (unsigned i = 0,
+      n = static_cast<unsigned>(this->_internal_element_size()); i < n; i++) {
+    const auto& repfield = this->_internal_element(i);
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Array)
+  return target;
+}
+
+size_t Array::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Array)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // repeated .aapt.pb.Array.Element element = 1;
+  total_size += 1UL * this->_internal_element_size();
+  for (const auto& msg : this->_impl_.element_) {
+    total_size +=
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Array::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Array::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Array::GetClassData() const { return &_class_data_; }
+
+
+void Array::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Array*>(&to_msg);
+  auto& from = static_cast<const Array&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Array)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  _this->_impl_.element_.MergeFrom(from._impl_.element_);
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Array::CopyFrom(const Array& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Array)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Array::IsInitialized() const {
+  return true;
+}
+
+void Array::InternalSwap(Array* other) {
+  using std::swap;
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  _impl_.element_.InternalSwap(&other->_impl_.element_);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Array::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[38]);
+}
+
+// ===================================================================
+
+class Plural_Entry::_Internal {
+ public:
+  static const ::aapt::pb::Source& source(const Plural_Entry* msg);
+  static const ::aapt::pb::Item& item(const Plural_Entry* msg);
+};
+
+const ::aapt::pb::Source&
+Plural_Entry::_Internal::source(const Plural_Entry* msg) {
+  return *msg->_impl_.source_;
+}
+const ::aapt::pb::Item&
+Plural_Entry::_Internal::item(const Plural_Entry* msg) {
+  return *msg->_impl_.item_;
+}
+Plural_Entry::Plural_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Plural.Entry)
+}
+Plural_Entry::Plural_Entry(const Plural_Entry& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Plural_Entry* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.comment_){}
+    , decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.item_){nullptr}
+    , decltype(_impl_.arity_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.comment_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_comment().empty()) {
+    _this->_impl_.comment_.Set(from._internal_comment(), 
+      _this->GetArenaForAllocation());
+  }
+  if (from._internal_has_source()) {
+    _this->_impl_.source_ = new ::aapt::pb::Source(*from._impl_.source_);
+  }
+  if (from._internal_has_item()) {
+    _this->_impl_.item_ = new ::aapt::pb::Item(*from._impl_.item_);
+  }
+  _this->_impl_.arity_ = from._impl_.arity_;
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Plural.Entry)
+}
+
+inline void Plural_Entry::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.comment_){}
+    , decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.item_){nullptr}
+    , decltype(_impl_.arity_){0}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.comment_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+Plural_Entry::~Plural_Entry() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Plural.Entry)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Plural_Entry::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.comment_.Destroy();
+  if (this != internal_default_instance()) delete _impl_.source_;
+  if (this != internal_default_instance()) delete _impl_.item_;
+}
+
+void Plural_Entry::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Plural_Entry::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Plural.Entry)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.comment_.ClearToEmpty();
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+  if (GetArenaForAllocation() == nullptr && _impl_.item_ != nullptr) {
+    delete _impl_.item_;
+  }
+  _impl_.item_ = nullptr;
+  _impl_.arity_ = 0;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Plural_Entry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.Source source = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string comment = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          auto str = _internal_mutable_comment();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.Plural.Entry.comment"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Plural.Arity arity = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
+          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+          _internal_set_arity(static_cast<::aapt::pb::Plural_Arity>(val));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Item item = 4;
+      case 4:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
+          ptr = ctx->ParseMessage(_internal_mutable_item(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Plural_Entry::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Plural.Entry)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.Source source = 1;
+  if (this->_internal_has_source()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(1, _Internal::source(this),
+        _Internal::source(this).GetCachedSize(), target, stream);
+  }
+
+  // string comment = 2;
+  if (!this->_internal_comment().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_comment().data(), static_cast<int>(this->_internal_comment().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.Plural.Entry.comment");
+    target = stream->WriteStringMaybeAliased(
+        2, this->_internal_comment(), target);
+  }
+
+  // .aapt.pb.Plural.Arity arity = 3;
+  if (this->_internal_arity() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteEnumToArray(
+      3, this->_internal_arity(), target);
+  }
+
+  // .aapt.pb.Item item = 4;
+  if (this->_internal_has_item()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(4, _Internal::item(this),
+        _Internal::item(this).GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Plural.Entry)
+  return target;
+}
+
+size_t Plural_Entry::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Plural.Entry)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string comment = 2;
+  if (!this->_internal_comment().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_comment());
+  }
+
+  // .aapt.pb.Source source = 1;
+  if (this->_internal_has_source()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.source_);
+  }
+
+  // .aapt.pb.Item item = 4;
+  if (this->_internal_has_item()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.item_);
+  }
+
+  // .aapt.pb.Plural.Arity arity = 3;
+  if (this->_internal_arity() != 0) {
+    total_size += 1 +
+      ::_pbi::WireFormatLite::EnumSize(this->_internal_arity());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Plural_Entry::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Plural_Entry::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Plural_Entry::GetClassData() const { return &_class_data_; }
+
+
+void Plural_Entry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Plural_Entry*>(&to_msg);
+  auto& from = static_cast<const Plural_Entry&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Plural.Entry)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_comment().empty()) {
+    _this->_internal_set_comment(from._internal_comment());
+  }
+  if (from._internal_has_source()) {
+    _this->_internal_mutable_source()->::aapt::pb::Source::MergeFrom(
+        from._internal_source());
+  }
+  if (from._internal_has_item()) {
+    _this->_internal_mutable_item()->::aapt::pb::Item::MergeFrom(
+        from._internal_item());
+  }
+  if (from._internal_arity() != 0) {
+    _this->_internal_set_arity(from._internal_arity());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Plural_Entry::CopyFrom(const Plural_Entry& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Plural.Entry)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Plural_Entry::IsInitialized() const {
+  return true;
+}
+
+void Plural_Entry::InternalSwap(Plural_Entry* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.comment_, lhs_arena,
+      &other->_impl_.comment_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(Plural_Entry, _impl_.arity_)
+      + sizeof(Plural_Entry::_impl_.arity_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(Plural_Entry, _impl_.source_)>(
+          reinterpret_cast<char*>(&_impl_.source_),
+          reinterpret_cast<char*>(&other->_impl_.source_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Plural_Entry::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[39]);
+}
+
+// ===================================================================
+
+class Plural::_Internal {
+ public:
+};
+
+Plural::Plural(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.Plural)
+}
+Plural::Plural(const Plural& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  Plural* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.entry_){from._impl_.entry_}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.Plural)
+}
+
+inline void Plural::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.entry_){arena}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+}
+
+Plural::~Plural() {
+  // @@protoc_insertion_point(destructor:aapt.pb.Plural)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void Plural::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.entry_.~RepeatedPtrField();
+}
+
+void Plural::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void Plural::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.Plural)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.entry_.Clear();
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* Plural::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // repeated .aapt.pb.Plural.Entry entry = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr -= 1;
+          do {
+            ptr += 1;
+            ptr = ctx->ParseMessage(_internal_add_entry(), ptr);
+            CHK_(ptr);
+            if (!ctx->DataAvailable(ptr)) break;
+          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* Plural::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.Plural)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // repeated .aapt.pb.Plural.Entry entry = 1;
+  for (unsigned i = 0,
+      n = static_cast<unsigned>(this->_internal_entry_size()); i < n; i++) {
+    const auto& repfield = this->_internal_entry(i);
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.Plural)
+  return target;
+}
+
+size_t Plural::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Plural)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // repeated .aapt.pb.Plural.Entry entry = 1;
+  total_size += 1UL * this->_internal_entry_size();
+  for (const auto& msg : this->_impl_.entry_) {
+    total_size +=
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Plural::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    Plural::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Plural::GetClassData() const { return &_class_data_; }
+
+
+void Plural::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<Plural*>(&to_msg);
+  auto& from = static_cast<const Plural&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Plural)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  _this->_impl_.entry_.MergeFrom(from._impl_.entry_);
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void Plural::CopyFrom(const Plural& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Plural)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool Plural::IsInitialized() const {
+  return true;
+}
+
+void Plural::InternalSwap(Plural* other) {
+  using std::swap;
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  _impl_.entry_.InternalSwap(&other->_impl_.entry_);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata Plural::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[40]);
+}
+
+// ===================================================================
+
+class XmlNode::_Internal {
+ public:
+  static const ::aapt::pb::XmlElement& element(const XmlNode* msg);
+  static const ::aapt::pb::SourcePosition& source(const XmlNode* msg);
+};
+
+const ::aapt::pb::XmlElement&
+XmlNode::_Internal::element(const XmlNode* msg) {
+  return *msg->_impl_.node_.element_;
+}
+const ::aapt::pb::SourcePosition&
+XmlNode::_Internal::source(const XmlNode* msg) {
+  return *msg->_impl_.source_;
+}
+void XmlNode::set_allocated_element(::aapt::pb::XmlElement* element) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  clear_node();
+  if (element) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(element);
+    if (message_arena != submessage_arena) {
+      element = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, element, submessage_arena);
+    }
+    set_has_element();
+    _impl_.node_.element_ = element;
+  }
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNode.element)
+}
+XmlNode::XmlNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.XmlNode)
+}
+XmlNode::XmlNode(const XmlNode& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  XmlNode* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.node_){}
+    , /*decltype(_impl_._cached_size_)*/{}
+    , /*decltype(_impl_._oneof_case_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  if (from._internal_has_source()) {
+    _this->_impl_.source_ = new ::aapt::pb::SourcePosition(*from._impl_.source_);
+  }
+  clear_has_node();
+  switch (from.node_case()) {
+    case kElement: {
+      _this->_internal_mutable_element()->::aapt::pb::XmlElement::MergeFrom(
+          from._internal_element());
+      break;
+    }
+    case kText: {
+      _this->_internal_set_text(from._internal_text());
+      break;
+    }
+    case NODE_NOT_SET: {
+      break;
+    }
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.XmlNode)
+}
+
+inline void XmlNode::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.node_){}
+    , /*decltype(_impl_._cached_size_)*/{}
+    , /*decltype(_impl_._oneof_case_)*/{}
+  };
+  clear_has_node();
+}
+
+XmlNode::~XmlNode() {
+  // @@protoc_insertion_point(destructor:aapt.pb.XmlNode)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void XmlNode::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  if (this != internal_default_instance()) delete _impl_.source_;
+  if (has_node()) {
+    clear_node();
+  }
+}
+
+void XmlNode::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void XmlNode::clear_node() {
+// @@protoc_insertion_point(one_of_clear_start:aapt.pb.XmlNode)
+  switch (node_case()) {
+    case kElement: {
+      if (GetArenaForAllocation() == nullptr) {
+        delete _impl_.node_.element_;
+      }
+      break;
+    }
+    case kText: {
+      _impl_.node_.text_.Destroy();
+      break;
+    }
+    case NODE_NOT_SET: {
+      break;
+    }
+  }
+  _impl_._oneof_case_[0] = NODE_NOT_SET;
+}
+
+
+void XmlNode::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.XmlNode)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+  clear_node();
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* XmlNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // .aapt.pb.XmlElement element = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr = ctx->ParseMessage(_internal_mutable_element(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string text = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          auto str = _internal_mutable_text();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.XmlNode.text"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.SourcePosition source = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* XmlNode::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.XmlNode)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // .aapt.pb.XmlElement element = 1;
+  if (_internal_has_element()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(1, _Internal::element(this),
+        _Internal::element(this).GetCachedSize(), target, stream);
+  }
+
+  // string text = 2;
+  if (_internal_has_text()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.XmlNode.text");
+    target = stream->WriteStringMaybeAliased(
+        2, this->_internal_text(), target);
+  }
+
+  // .aapt.pb.SourcePosition source = 3;
+  if (this->_internal_has_source()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(3, _Internal::source(this),
+        _Internal::source(this).GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.XmlNode)
+  return target;
+}
+
+size_t XmlNode::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.XmlNode)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // .aapt.pb.SourcePosition source = 3;
+  if (this->_internal_has_source()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.source_);
+  }
+
+  switch (node_case()) {
+    // .aapt.pb.XmlElement element = 1;
+    case kElement: {
+      total_size += 1 +
+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+          *_impl_.node_.element_);
+      break;
+    }
+    // string text = 2;
+    case kText: {
+      total_size += 1 +
+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+          this->_internal_text());
+      break;
+    }
+    case NODE_NOT_SET: {
+      break;
+    }
+  }
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData XmlNode::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    XmlNode::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*XmlNode::GetClassData() const { return &_class_data_; }
+
+
+void XmlNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<XmlNode*>(&to_msg);
+  auto& from = static_cast<const XmlNode&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.XmlNode)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (from._internal_has_source()) {
+    _this->_internal_mutable_source()->::aapt::pb::SourcePosition::MergeFrom(
+        from._internal_source());
+  }
+  switch (from.node_case()) {
+    case kElement: {
+      _this->_internal_mutable_element()->::aapt::pb::XmlElement::MergeFrom(
+          from._internal_element());
+      break;
+    }
+    case kText: {
+      _this->_internal_set_text(from._internal_text());
+      break;
+    }
+    case NODE_NOT_SET: {
+      break;
+    }
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void XmlNode::CopyFrom(const XmlNode& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.XmlNode)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool XmlNode::IsInitialized() const {
+  return true;
+}
+
+void XmlNode::InternalSwap(XmlNode* other) {
+  using std::swap;
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  swap(_impl_.source_, other->_impl_.source_);
+  swap(_impl_.node_, other->_impl_.node_);
+  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata XmlNode::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[41]);
+}
+
+// ===================================================================
+
+class XmlElement::_Internal {
+ public:
+};
+
+XmlElement::XmlElement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.XmlElement)
+}
+XmlElement::XmlElement(const XmlElement& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  XmlElement* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.namespace_declaration_){from._impl_.namespace_declaration_}
+    , decltype(_impl_.attribute_){from._impl_.attribute_}
+    , decltype(_impl_.child_){from._impl_.child_}
+    , decltype(_impl_.namespace_uri_){}
+    , decltype(_impl_.name_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.namespace_uri_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.namespace_uri_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_namespace_uri().empty()) {
+    _this->_impl_.namespace_uri_.Set(from._internal_namespace_uri(), 
+      _this->GetArenaForAllocation());
+  }
+  _impl_.name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_name().empty()) {
+    _this->_impl_.name_.Set(from._internal_name(), 
+      _this->GetArenaForAllocation());
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.XmlElement)
+}
+
+inline void XmlElement::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.namespace_declaration_){arena}
+    , decltype(_impl_.attribute_){arena}
+    , decltype(_impl_.child_){arena}
+    , decltype(_impl_.namespace_uri_){}
+    , decltype(_impl_.name_){}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.namespace_uri_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.namespace_uri_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+XmlElement::~XmlElement() {
+  // @@protoc_insertion_point(destructor:aapt.pb.XmlElement)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void XmlElement::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.namespace_declaration_.~RepeatedPtrField();
+  _impl_.attribute_.~RepeatedPtrField();
+  _impl_.child_.~RepeatedPtrField();
+  _impl_.namespace_uri_.Destroy();
+  _impl_.name_.Destroy();
+}
+
+void XmlElement::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void XmlElement::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.XmlElement)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.namespace_declaration_.Clear();
+  _impl_.attribute_.Clear();
+  _impl_.child_.Clear();
+  _impl_.namespace_uri_.ClearToEmpty();
+  _impl_.name_.ClearToEmpty();
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* XmlElement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // repeated .aapt.pb.XmlNamespace namespace_declaration = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          ptr -= 1;
+          do {
+            ptr += 1;
+            ptr = ctx->ParseMessage(_internal_add_namespace_declaration(), ptr);
+            CHK_(ptr);
+            if (!ctx->DataAvailable(ptr)) break;
+          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string namespace_uri = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          auto str = _internal_mutable_namespace_uri();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.XmlElement.namespace_uri"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string name = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          auto str = _internal_mutable_name();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.XmlElement.name"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // repeated .aapt.pb.XmlAttribute attribute = 4;
+      case 4:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
+          ptr -= 1;
+          do {
+            ptr += 1;
+            ptr = ctx->ParseMessage(_internal_add_attribute(), ptr);
+            CHK_(ptr);
+            if (!ctx->DataAvailable(ptr)) break;
+          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // repeated .aapt.pb.XmlNode child = 5;
+      case 5:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
+          ptr -= 1;
+          do {
+            ptr += 1;
+            ptr = ctx->ParseMessage(_internal_add_child(), ptr);
+            CHK_(ptr);
+            if (!ctx->DataAvailable(ptr)) break;
+          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* XmlElement::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.XmlElement)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // repeated .aapt.pb.XmlNamespace namespace_declaration = 1;
+  for (unsigned i = 0,
+      n = static_cast<unsigned>(this->_internal_namespace_declaration_size()); i < n; i++) {
+    const auto& repfield = this->_internal_namespace_declaration(i);
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
+  }
+
+  // string namespace_uri = 2;
+  if (!this->_internal_namespace_uri().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_namespace_uri().data(), static_cast<int>(this->_internal_namespace_uri().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.XmlElement.namespace_uri");
+    target = stream->WriteStringMaybeAliased(
+        2, this->_internal_namespace_uri(), target);
+  }
+
+  // string name = 3;
+  if (!this->_internal_name().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.XmlElement.name");
+    target = stream->WriteStringMaybeAliased(
+        3, this->_internal_name(), target);
+  }
+
+  // repeated .aapt.pb.XmlAttribute attribute = 4;
+  for (unsigned i = 0,
+      n = static_cast<unsigned>(this->_internal_attribute_size()); i < n; i++) {
+    const auto& repfield = this->_internal_attribute(i);
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
+  }
+
+  // repeated .aapt.pb.XmlNode child = 5;
+  for (unsigned i = 0,
+      n = static_cast<unsigned>(this->_internal_child_size()); i < n; i++) {
+    const auto& repfield = this->_internal_child(i);
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.XmlElement)
+  return target;
+}
+
+size_t XmlElement::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.XmlElement)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // repeated .aapt.pb.XmlNamespace namespace_declaration = 1;
+  total_size += 1UL * this->_internal_namespace_declaration_size();
+  for (const auto& msg : this->_impl_.namespace_declaration_) {
+    total_size +=
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
+  }
+
+  // repeated .aapt.pb.XmlAttribute attribute = 4;
+  total_size += 1UL * this->_internal_attribute_size();
+  for (const auto& msg : this->_impl_.attribute_) {
+    total_size +=
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
+  }
+
+  // repeated .aapt.pb.XmlNode child = 5;
+  total_size += 1UL * this->_internal_child_size();
+  for (const auto& msg : this->_impl_.child_) {
+    total_size +=
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
+  }
+
+  // string namespace_uri = 2;
+  if (!this->_internal_namespace_uri().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_namespace_uri());
+  }
+
+  // string name = 3;
+  if (!this->_internal_name().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_name());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData XmlElement::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    XmlElement::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*XmlElement::GetClassData() const { return &_class_data_; }
+
+
+void XmlElement::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<XmlElement*>(&to_msg);
+  auto& from = static_cast<const XmlElement&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.XmlElement)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  _this->_impl_.namespace_declaration_.MergeFrom(from._impl_.namespace_declaration_);
+  _this->_impl_.attribute_.MergeFrom(from._impl_.attribute_);
+  _this->_impl_.child_.MergeFrom(from._impl_.child_);
+  if (!from._internal_namespace_uri().empty()) {
+    _this->_internal_set_namespace_uri(from._internal_namespace_uri());
+  }
+  if (!from._internal_name().empty()) {
+    _this->_internal_set_name(from._internal_name());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void XmlElement::CopyFrom(const XmlElement& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.XmlElement)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool XmlElement::IsInitialized() const {
+  return true;
+}
+
+void XmlElement::InternalSwap(XmlElement* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  _impl_.namespace_declaration_.InternalSwap(&other->_impl_.namespace_declaration_);
+  _impl_.attribute_.InternalSwap(&other->_impl_.attribute_);
+  _impl_.child_.InternalSwap(&other->_impl_.child_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.namespace_uri_, lhs_arena,
+      &other->_impl_.namespace_uri_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.name_, lhs_arena,
+      &other->_impl_.name_, rhs_arena
+  );
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata XmlElement::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[42]);
+}
+
+// ===================================================================
+
+class XmlNamespace::_Internal {
+ public:
+  static const ::aapt::pb::SourcePosition& source(const XmlNamespace* msg);
+};
+
+const ::aapt::pb::SourcePosition&
+XmlNamespace::_Internal::source(const XmlNamespace* msg) {
+  return *msg->_impl_.source_;
+}
+XmlNamespace::XmlNamespace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.XmlNamespace)
+}
+XmlNamespace::XmlNamespace(const XmlNamespace& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  XmlNamespace* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.prefix_){}
+    , decltype(_impl_.uri_){}
+    , decltype(_impl_.source_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.prefix_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.prefix_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_prefix().empty()) {
+    _this->_impl_.prefix_.Set(from._internal_prefix(), 
+      _this->GetArenaForAllocation());
+  }
+  _impl_.uri_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.uri_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_uri().empty()) {
+    _this->_impl_.uri_.Set(from._internal_uri(), 
+      _this->GetArenaForAllocation());
+  }
+  if (from._internal_has_source()) {
+    _this->_impl_.source_ = new ::aapt::pb::SourcePosition(*from._impl_.source_);
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.XmlNamespace)
+}
+
+inline void XmlNamespace::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.prefix_){}
+    , decltype(_impl_.uri_){}
+    , decltype(_impl_.source_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.prefix_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.prefix_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.uri_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.uri_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+XmlNamespace::~XmlNamespace() {
+  // @@protoc_insertion_point(destructor:aapt.pb.XmlNamespace)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void XmlNamespace::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.prefix_.Destroy();
+  _impl_.uri_.Destroy();
+  if (this != internal_default_instance()) delete _impl_.source_;
+}
+
+void XmlNamespace::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void XmlNamespace::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.XmlNamespace)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.prefix_.ClearToEmpty();
+  _impl_.uri_.ClearToEmpty();
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* XmlNamespace::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // string prefix = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          auto str = _internal_mutable_prefix();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.XmlNamespace.prefix"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string uri = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          auto str = _internal_mutable_uri();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.XmlNamespace.uri"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.SourcePosition source = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* XmlNamespace::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.XmlNamespace)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // string prefix = 1;
+  if (!this->_internal_prefix().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_prefix().data(), static_cast<int>(this->_internal_prefix().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.XmlNamespace.prefix");
+    target = stream->WriteStringMaybeAliased(
+        1, this->_internal_prefix(), target);
+  }
+
+  // string uri = 2;
+  if (!this->_internal_uri().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_uri().data(), static_cast<int>(this->_internal_uri().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.XmlNamespace.uri");
+    target = stream->WriteStringMaybeAliased(
+        2, this->_internal_uri(), target);
+  }
+
+  // .aapt.pb.SourcePosition source = 3;
+  if (this->_internal_has_source()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(3, _Internal::source(this),
+        _Internal::source(this).GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.XmlNamespace)
+  return target;
+}
+
+size_t XmlNamespace::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.XmlNamespace)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string prefix = 1;
+  if (!this->_internal_prefix().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_prefix());
+  }
+
+  // string uri = 2;
+  if (!this->_internal_uri().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_uri());
+  }
+
+  // .aapt.pb.SourcePosition source = 3;
+  if (this->_internal_has_source()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.source_);
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData XmlNamespace::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    XmlNamespace::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*XmlNamespace::GetClassData() const { return &_class_data_; }
+
+
+void XmlNamespace::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<XmlNamespace*>(&to_msg);
+  auto& from = static_cast<const XmlNamespace&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.XmlNamespace)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_prefix().empty()) {
+    _this->_internal_set_prefix(from._internal_prefix());
+  }
+  if (!from._internal_uri().empty()) {
+    _this->_internal_set_uri(from._internal_uri());
+  }
+  if (from._internal_has_source()) {
+    _this->_internal_mutable_source()->::aapt::pb::SourcePosition::MergeFrom(
+        from._internal_source());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void XmlNamespace::CopyFrom(const XmlNamespace& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.XmlNamespace)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool XmlNamespace::IsInitialized() const {
+  return true;
+}
+
+void XmlNamespace::InternalSwap(XmlNamespace* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.prefix_, lhs_arena,
+      &other->_impl_.prefix_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.uri_, lhs_arena,
+      &other->_impl_.uri_, rhs_arena
+  );
+  swap(_impl_.source_, other->_impl_.source_);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata XmlNamespace::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[43]);
+}
+
+// ===================================================================
+
+class XmlAttribute::_Internal {
+ public:
+  static const ::aapt::pb::SourcePosition& source(const XmlAttribute* msg);
+  static const ::aapt::pb::Item& compiled_item(const XmlAttribute* msg);
+};
+
+const ::aapt::pb::SourcePosition&
+XmlAttribute::_Internal::source(const XmlAttribute* msg) {
+  return *msg->_impl_.source_;
+}
+const ::aapt::pb::Item&
+XmlAttribute::_Internal::compiled_item(const XmlAttribute* msg) {
+  return *msg->_impl_.compiled_item_;
+}
+XmlAttribute::XmlAttribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.XmlAttribute)
+}
+XmlAttribute::XmlAttribute(const XmlAttribute& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  XmlAttribute* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.namespace_uri_){}
+    , decltype(_impl_.name_){}
+    , decltype(_impl_.value_){}
+    , decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.compiled_item_){nullptr}
+    , decltype(_impl_.resource_id_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.namespace_uri_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.namespace_uri_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_namespace_uri().empty()) {
+    _this->_impl_.namespace_uri_.Set(from._internal_namespace_uri(), 
+      _this->GetArenaForAllocation());
+  }
+  _impl_.name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_name().empty()) {
+    _this->_impl_.name_.Set(from._internal_name(), 
+      _this->GetArenaForAllocation());
+  }
+  _impl_.value_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.value_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_value().empty()) {
+    _this->_impl_.value_.Set(from._internal_value(), 
+      _this->GetArenaForAllocation());
+  }
+  if (from._internal_has_source()) {
+    _this->_impl_.source_ = new ::aapt::pb::SourcePosition(*from._impl_.source_);
+  }
+  if (from._internal_has_compiled_item()) {
+    _this->_impl_.compiled_item_ = new ::aapt::pb::Item(*from._impl_.compiled_item_);
+  }
+  _this->_impl_.resource_id_ = from._impl_.resource_id_;
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.XmlAttribute)
+}
+
+inline void XmlAttribute::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.namespace_uri_){}
+    , decltype(_impl_.name_){}
+    , decltype(_impl_.value_){}
+    , decltype(_impl_.source_){nullptr}
+    , decltype(_impl_.compiled_item_){nullptr}
+    , decltype(_impl_.resource_id_){0u}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.namespace_uri_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.namespace_uri_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.value_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.value_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+XmlAttribute::~XmlAttribute() {
+  // @@protoc_insertion_point(destructor:aapt.pb.XmlAttribute)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void XmlAttribute::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.namespace_uri_.Destroy();
+  _impl_.name_.Destroy();
+  _impl_.value_.Destroy();
+  if (this != internal_default_instance()) delete _impl_.source_;
+  if (this != internal_default_instance()) delete _impl_.compiled_item_;
+}
+
+void XmlAttribute::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void XmlAttribute::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.XmlAttribute)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.namespace_uri_.ClearToEmpty();
+  _impl_.name_.ClearToEmpty();
+  _impl_.value_.ClearToEmpty();
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+  if (GetArenaForAllocation() == nullptr && _impl_.compiled_item_ != nullptr) {
+    delete _impl_.compiled_item_;
+  }
+  _impl_.compiled_item_ = nullptr;
+  _impl_.resource_id_ = 0u;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* XmlAttribute::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // string namespace_uri = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          auto str = _internal_mutable_namespace_uri();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.XmlAttribute.namespace_uri"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string name = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          auto str = _internal_mutable_name();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.XmlAttribute.name"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string value = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          auto str = _internal_mutable_value();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.XmlAttribute.value"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.SourcePosition source = 4;
+      case 4:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
+          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 resource_id = 5;
+      case 5:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
+          _impl_.resource_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Item compiled_item = 6;
+      case 6:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
+          ptr = ctx->ParseMessage(_internal_mutable_compiled_item(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* XmlAttribute::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.XmlAttribute)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // string namespace_uri = 1;
+  if (!this->_internal_namespace_uri().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_namespace_uri().data(), static_cast<int>(this->_internal_namespace_uri().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.XmlAttribute.namespace_uri");
+    target = stream->WriteStringMaybeAliased(
+        1, this->_internal_namespace_uri(), target);
+  }
+
+  // string name = 2;
+  if (!this->_internal_name().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.XmlAttribute.name");
+    target = stream->WriteStringMaybeAliased(
+        2, this->_internal_name(), target);
+  }
+
+  // string value = 3;
+  if (!this->_internal_value().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.XmlAttribute.value");
+    target = stream->WriteStringMaybeAliased(
+        3, this->_internal_value(), target);
+  }
+
+  // .aapt.pb.SourcePosition source = 4;
+  if (this->_internal_has_source()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(4, _Internal::source(this),
+        _Internal::source(this).GetCachedSize(), target, stream);
+  }
+
+  // uint32 resource_id = 5;
+  if (this->_internal_resource_id() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_resource_id(), target);
+  }
+
+  // .aapt.pb.Item compiled_item = 6;
+  if (this->_internal_has_compiled_item()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(6, _Internal::compiled_item(this),
+        _Internal::compiled_item(this).GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.XmlAttribute)
+  return target;
+}
+
+size_t XmlAttribute::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.XmlAttribute)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string namespace_uri = 1;
+  if (!this->_internal_namespace_uri().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_namespace_uri());
+  }
+
+  // string name = 2;
+  if (!this->_internal_name().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_name());
+  }
+
+  // string value = 3;
+  if (!this->_internal_value().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_value());
+  }
+
+  // .aapt.pb.SourcePosition source = 4;
+  if (this->_internal_has_source()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.source_);
+  }
+
+  // .aapt.pb.Item compiled_item = 6;
+  if (this->_internal_has_compiled_item()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.compiled_item_);
+  }
+
+  // uint32 resource_id = 5;
+  if (this->_internal_resource_id() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_resource_id());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData XmlAttribute::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    XmlAttribute::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*XmlAttribute::GetClassData() const { return &_class_data_; }
+
+
+void XmlAttribute::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<XmlAttribute*>(&to_msg);
+  auto& from = static_cast<const XmlAttribute&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.XmlAttribute)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_namespace_uri().empty()) {
+    _this->_internal_set_namespace_uri(from._internal_namespace_uri());
+  }
+  if (!from._internal_name().empty()) {
+    _this->_internal_set_name(from._internal_name());
+  }
+  if (!from._internal_value().empty()) {
+    _this->_internal_set_value(from._internal_value());
+  }
+  if (from._internal_has_source()) {
+    _this->_internal_mutable_source()->::aapt::pb::SourcePosition::MergeFrom(
+        from._internal_source());
+  }
+  if (from._internal_has_compiled_item()) {
+    _this->_internal_mutable_compiled_item()->::aapt::pb::Item::MergeFrom(
+        from._internal_compiled_item());
+  }
+  if (from._internal_resource_id() != 0) {
+    _this->_internal_set_resource_id(from._internal_resource_id());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void XmlAttribute::CopyFrom(const XmlAttribute& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.XmlAttribute)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool XmlAttribute::IsInitialized() const {
+  return true;
+}
+
+void XmlAttribute::InternalSwap(XmlAttribute* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.namespace_uri_, lhs_arena,
+      &other->_impl_.namespace_uri_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.name_, lhs_arena,
+      &other->_impl_.name_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.value_, lhs_arena,
+      &other->_impl_.value_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(XmlAttribute, _impl_.resource_id_)
+      + sizeof(XmlAttribute::_impl_.resource_id_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(XmlAttribute, _impl_.source_)>(
+          reinterpret_cast<char*>(&_impl_.source_),
+          reinterpret_cast<char*>(&other->_impl_.source_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata XmlAttribute::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[44]);
+}
+
+// ===================================================================
+
+class MacroBody::_Internal {
+ public:
+  static const ::aapt::pb::StyleString& style_string(const MacroBody* msg);
+  static const ::aapt::pb::SourcePosition& source(const MacroBody* msg);
+};
+
+const ::aapt::pb::StyleString&
+MacroBody::_Internal::style_string(const MacroBody* msg) {
+  return *msg->_impl_.style_string_;
+}
+const ::aapt::pb::SourcePosition&
+MacroBody::_Internal::source(const MacroBody* msg) {
+  return *msg->_impl_.source_;
+}
+MacroBody::MacroBody(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.MacroBody)
+}
+MacroBody::MacroBody(const MacroBody& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  MacroBody* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.untranslatable_sections_){from._impl_.untranslatable_sections_}
+    , decltype(_impl_.namespace_stack_){from._impl_.namespace_stack_}
+    , decltype(_impl_.raw_string_){}
+    , decltype(_impl_.style_string_){nullptr}
+    , decltype(_impl_.source_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.raw_string_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.raw_string_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_raw_string().empty()) {
+    _this->_impl_.raw_string_.Set(from._internal_raw_string(), 
+      _this->GetArenaForAllocation());
+  }
+  if (from._internal_has_style_string()) {
+    _this->_impl_.style_string_ = new ::aapt::pb::StyleString(*from._impl_.style_string_);
+  }
+  if (from._internal_has_source()) {
+    _this->_impl_.source_ = new ::aapt::pb::SourcePosition(*from._impl_.source_);
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.MacroBody)
+}
+
+inline void MacroBody::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.untranslatable_sections_){arena}
+    , decltype(_impl_.namespace_stack_){arena}
+    , decltype(_impl_.raw_string_){}
+    , decltype(_impl_.style_string_){nullptr}
+    , decltype(_impl_.source_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.raw_string_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.raw_string_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+MacroBody::~MacroBody() {
+  // @@protoc_insertion_point(destructor:aapt.pb.MacroBody)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void MacroBody::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.untranslatable_sections_.~RepeatedPtrField();
+  _impl_.namespace_stack_.~RepeatedPtrField();
+  _impl_.raw_string_.Destroy();
+  if (this != internal_default_instance()) delete _impl_.style_string_;
+  if (this != internal_default_instance()) delete _impl_.source_;
+}
+
+void MacroBody::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void MacroBody::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.MacroBody)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.untranslatable_sections_.Clear();
+  _impl_.namespace_stack_.Clear();
+  _impl_.raw_string_.ClearToEmpty();
+  if (GetArenaForAllocation() == nullptr && _impl_.style_string_ != nullptr) {
+    delete _impl_.style_string_;
+  }
+  _impl_.style_string_ = nullptr;
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* MacroBody::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // string raw_string = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          auto str = _internal_mutable_raw_string();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.MacroBody.raw_string"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.StyleString style_string = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          ptr = ctx->ParseMessage(_internal_mutable_style_string(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // repeated .aapt.pb.UntranslatableSection untranslatable_sections = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
+          ptr -= 1;
+          do {
+            ptr += 1;
+            ptr = ctx->ParseMessage(_internal_add_untranslatable_sections(), ptr);
+            CHK_(ptr);
+            if (!ctx->DataAvailable(ptr)) break;
+          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // repeated .aapt.pb.NamespaceAlias namespace_stack = 4;
+      case 4:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
+          ptr -= 1;
+          do {
+            ptr += 1;
+            ptr = ctx->ParseMessage(_internal_add_namespace_stack(), ptr);
+            CHK_(ptr);
+            if (!ctx->DataAvailable(ptr)) break;
+          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.SourcePosition source = 5;
+      case 5:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
+          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* MacroBody::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.MacroBody)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // string raw_string = 1;
+  if (!this->_internal_raw_string().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_raw_string().data(), static_cast<int>(this->_internal_raw_string().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.MacroBody.raw_string");
+    target = stream->WriteStringMaybeAliased(
+        1, this->_internal_raw_string(), target);
+  }
+
+  // .aapt.pb.StyleString style_string = 2;
+  if (this->_internal_has_style_string()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(2, _Internal::style_string(this),
+        _Internal::style_string(this).GetCachedSize(), target, stream);
+  }
+
+  // repeated .aapt.pb.UntranslatableSection untranslatable_sections = 3;
+  for (unsigned i = 0,
+      n = static_cast<unsigned>(this->_internal_untranslatable_sections_size()); i < n; i++) {
+    const auto& repfield = this->_internal_untranslatable_sections(i);
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
+  }
+
+  // repeated .aapt.pb.NamespaceAlias namespace_stack = 4;
+  for (unsigned i = 0,
+      n = static_cast<unsigned>(this->_internal_namespace_stack_size()); i < n; i++) {
+    const auto& repfield = this->_internal_namespace_stack(i);
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.SourcePosition source = 5;
+  if (this->_internal_has_source()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(5, _Internal::source(this),
+        _Internal::source(this).GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.MacroBody)
+  return target;
+}
+
+size_t MacroBody::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.MacroBody)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // repeated .aapt.pb.UntranslatableSection untranslatable_sections = 3;
+  total_size += 1UL * this->_internal_untranslatable_sections_size();
+  for (const auto& msg : this->_impl_.untranslatable_sections_) {
+    total_size +=
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
+  }
+
+  // repeated .aapt.pb.NamespaceAlias namespace_stack = 4;
+  total_size += 1UL * this->_internal_namespace_stack_size();
+  for (const auto& msg : this->_impl_.namespace_stack_) {
+    total_size +=
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
+  }
+
+  // string raw_string = 1;
+  if (!this->_internal_raw_string().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_raw_string());
+  }
+
+  // .aapt.pb.StyleString style_string = 2;
+  if (this->_internal_has_style_string()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.style_string_);
+  }
+
+  // .aapt.pb.SourcePosition source = 5;
+  if (this->_internal_has_source()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.source_);
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MacroBody::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    MacroBody::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MacroBody::GetClassData() const { return &_class_data_; }
+
+
+void MacroBody::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<MacroBody*>(&to_msg);
+  auto& from = static_cast<const MacroBody&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.MacroBody)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  _this->_impl_.untranslatable_sections_.MergeFrom(from._impl_.untranslatable_sections_);
+  _this->_impl_.namespace_stack_.MergeFrom(from._impl_.namespace_stack_);
+  if (!from._internal_raw_string().empty()) {
+    _this->_internal_set_raw_string(from._internal_raw_string());
+  }
+  if (from._internal_has_style_string()) {
+    _this->_internal_mutable_style_string()->::aapt::pb::StyleString::MergeFrom(
+        from._internal_style_string());
+  }
+  if (from._internal_has_source()) {
+    _this->_internal_mutable_source()->::aapt::pb::SourcePosition::MergeFrom(
+        from._internal_source());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void MacroBody::CopyFrom(const MacroBody& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.MacroBody)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool MacroBody::IsInitialized() const {
+  return true;
+}
+
+void MacroBody::InternalSwap(MacroBody* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  _impl_.untranslatable_sections_.InternalSwap(&other->_impl_.untranslatable_sections_);
+  _impl_.namespace_stack_.InternalSwap(&other->_impl_.namespace_stack_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.raw_string_, lhs_arena,
+      &other->_impl_.raw_string_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(MacroBody, _impl_.source_)
+      + sizeof(MacroBody::_impl_.source_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(MacroBody, _impl_.style_string_)>(
+          reinterpret_cast<char*>(&_impl_.style_string_),
+          reinterpret_cast<char*>(&other->_impl_.style_string_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata MacroBody::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[45]);
+}
+
+// ===================================================================
+
+class NamespaceAlias::_Internal {
+ public:
+};
+
+NamespaceAlias::NamespaceAlias(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.NamespaceAlias)
+}
+NamespaceAlias::NamespaceAlias(const NamespaceAlias& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  NamespaceAlias* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.prefix_){}
+    , decltype(_impl_.package_name_){}
+    , decltype(_impl_.is_private_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.prefix_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.prefix_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_prefix().empty()) {
+    _this->_impl_.prefix_.Set(from._internal_prefix(), 
+      _this->GetArenaForAllocation());
+  }
+  _impl_.package_name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.package_name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_package_name().empty()) {
+    _this->_impl_.package_name_.Set(from._internal_package_name(), 
+      _this->GetArenaForAllocation());
+  }
+  _this->_impl_.is_private_ = from._impl_.is_private_;
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.NamespaceAlias)
+}
+
+inline void NamespaceAlias::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.prefix_){}
+    , decltype(_impl_.package_name_){}
+    , decltype(_impl_.is_private_){false}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.prefix_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.prefix_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.package_name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.package_name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+NamespaceAlias::~NamespaceAlias() {
+  // @@protoc_insertion_point(destructor:aapt.pb.NamespaceAlias)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void NamespaceAlias::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.prefix_.Destroy();
+  _impl_.package_name_.Destroy();
+}
+
+void NamespaceAlias::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void NamespaceAlias::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.NamespaceAlias)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.prefix_.ClearToEmpty();
+  _impl_.package_name_.ClearToEmpty();
+  _impl_.is_private_ = false;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* NamespaceAlias::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // string prefix = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          auto str = _internal_mutable_prefix();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.NamespaceAlias.prefix"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string package_name = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          auto str = _internal_mutable_package_name();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.NamespaceAlias.package_name"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // bool is_private = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
+          _impl_.is_private_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* NamespaceAlias::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.NamespaceAlias)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // string prefix = 1;
+  if (!this->_internal_prefix().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_prefix().data(), static_cast<int>(this->_internal_prefix().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.NamespaceAlias.prefix");
+    target = stream->WriteStringMaybeAliased(
+        1, this->_internal_prefix(), target);
+  }
+
+  // string package_name = 2;
+  if (!this->_internal_package_name().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_package_name().data(), static_cast<int>(this->_internal_package_name().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.NamespaceAlias.package_name");
+    target = stream->WriteStringMaybeAliased(
+        2, this->_internal_package_name(), target);
+  }
+
+  // bool is_private = 3;
+  if (this->_internal_is_private() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_private(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.NamespaceAlias)
+  return target;
+}
+
+size_t NamespaceAlias::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.NamespaceAlias)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string prefix = 1;
+  if (!this->_internal_prefix().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_prefix());
+  }
+
+  // string package_name = 2;
+  if (!this->_internal_package_name().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_package_name());
+  }
+
+  // bool is_private = 3;
+  if (this->_internal_is_private() != 0) {
+    total_size += 1 + 1;
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamespaceAlias::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    NamespaceAlias::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamespaceAlias::GetClassData() const { return &_class_data_; }
+
+
+void NamespaceAlias::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<NamespaceAlias*>(&to_msg);
+  auto& from = static_cast<const NamespaceAlias&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.NamespaceAlias)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_prefix().empty()) {
+    _this->_internal_set_prefix(from._internal_prefix());
+  }
+  if (!from._internal_package_name().empty()) {
+    _this->_internal_set_package_name(from._internal_package_name());
+  }
+  if (from._internal_is_private() != 0) {
+    _this->_internal_set_is_private(from._internal_is_private());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void NamespaceAlias::CopyFrom(const NamespaceAlias& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.NamespaceAlias)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool NamespaceAlias::IsInitialized() const {
+  return true;
+}
+
+void NamespaceAlias::InternalSwap(NamespaceAlias* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.prefix_, lhs_arena,
+      &other->_impl_.prefix_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.package_name_, lhs_arena,
+      &other->_impl_.package_name_, rhs_arena
+  );
+  swap(_impl_.is_private_, other->_impl_.is_private_);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata NamespaceAlias::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[46]);
+}
+
+// ===================================================================
+
+class StyleString_Span::_Internal {
+ public:
+};
+
+StyleString_Span::StyleString_Span(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.StyleString.Span)
+}
+StyleString_Span::StyleString_Span(const StyleString_Span& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  StyleString_Span* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.name_){}
+    , decltype(_impl_.start_index_){}
+    , decltype(_impl_.end_index_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_name().empty()) {
+    _this->_impl_.name_.Set(from._internal_name(), 
+      _this->GetArenaForAllocation());
+  }
+  ::memcpy(&_impl_.start_index_, &from._impl_.start_index_,
+    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.end_index_) -
+    reinterpret_cast<char*>(&_impl_.start_index_)) + sizeof(_impl_.end_index_));
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.StyleString.Span)
+}
+
+inline void StyleString_Span::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.name_){}
+    , decltype(_impl_.start_index_){0u}
+    , decltype(_impl_.end_index_){0u}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+StyleString_Span::~StyleString_Span() {
+  // @@protoc_insertion_point(destructor:aapt.pb.StyleString.Span)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void StyleString_Span::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.name_.Destroy();
+}
+
+void StyleString_Span::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void StyleString_Span::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.StyleString.Span)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.name_.ClearToEmpty();
+  ::memset(&_impl_.start_index_, 0, static_cast<size_t>(
+      reinterpret_cast<char*>(&_impl_.end_index_) -
+      reinterpret_cast<char*>(&_impl_.start_index_)) + sizeof(_impl_.end_index_));
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* StyleString_Span::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // string name = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          auto str = _internal_mutable_name();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.StyleString.Span.name"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 start_index = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
+          _impl_.start_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint32 end_index = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
+          _impl_.end_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* StyleString_Span::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.StyleString.Span)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // string name = 1;
+  if (!this->_internal_name().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.StyleString.Span.name");
+    target = stream->WriteStringMaybeAliased(
+        1, this->_internal_name(), target);
+  }
+
+  // uint32 start_index = 2;
+  if (this->_internal_start_index() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_start_index(), target);
+  }
+
+  // uint32 end_index = 3;
+  if (this->_internal_end_index() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_end_index(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.StyleString.Span)
+  return target;
+}
+
+size_t StyleString_Span::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.StyleString.Span)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string name = 1;
+  if (!this->_internal_name().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_name());
+  }
+
+  // uint32 start_index = 2;
+  if (this->_internal_start_index() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start_index());
+  }
+
+  // uint32 end_index = 3;
+  if (this->_internal_end_index() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end_index());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyleString_Span::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    StyleString_Span::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyleString_Span::GetClassData() const { return &_class_data_; }
+
+
+void StyleString_Span::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<StyleString_Span*>(&to_msg);
+  auto& from = static_cast<const StyleString_Span&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.StyleString.Span)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_name().empty()) {
+    _this->_internal_set_name(from._internal_name());
+  }
+  if (from._internal_start_index() != 0) {
+    _this->_internal_set_start_index(from._internal_start_index());
+  }
+  if (from._internal_end_index() != 0) {
+    _this->_internal_set_end_index(from._internal_end_index());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void StyleString_Span::CopyFrom(const StyleString_Span& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.StyleString.Span)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StyleString_Span::IsInitialized() const {
+  return true;
+}
+
+void StyleString_Span::InternalSwap(StyleString_Span* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.name_, lhs_arena,
+      &other->_impl_.name_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(StyleString_Span, _impl_.end_index_)
+      + sizeof(StyleString_Span::_impl_.end_index_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(StyleString_Span, _impl_.start_index_)>(
+          reinterpret_cast<char*>(&_impl_.start_index_),
+          reinterpret_cast<char*>(&other->_impl_.start_index_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata StyleString_Span::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[47]);
+}
+
+// ===================================================================
+
+class StyleString::_Internal {
+ public:
+};
+
+StyleString::StyleString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.StyleString)
+}
+StyleString::StyleString(const StyleString& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  StyleString* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.spans_){from._impl_.spans_}
+    , decltype(_impl_.str_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.str_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.str_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_str().empty()) {
+    _this->_impl_.str_.Set(from._internal_str(), 
+      _this->GetArenaForAllocation());
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.StyleString)
+}
+
+inline void StyleString::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.spans_){arena}
+    , decltype(_impl_.str_){}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.str_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.str_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+StyleString::~StyleString() {
+  // @@protoc_insertion_point(destructor:aapt.pb.StyleString)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void StyleString::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.spans_.~RepeatedPtrField();
+  _impl_.str_.Destroy();
+}
+
+void StyleString::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void StyleString::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.StyleString)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.spans_.Clear();
+  _impl_.str_.ClearToEmpty();
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* StyleString::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // string str = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          auto str = _internal_mutable_str();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.StyleString.str"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // repeated .aapt.pb.StyleString.Span spans = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          ptr -= 1;
+          do {
+            ptr += 1;
+            ptr = ctx->ParseMessage(_internal_add_spans(), ptr);
+            CHK_(ptr);
+            if (!ctx->DataAvailable(ptr)) break;
+          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* StyleString::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.StyleString)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // string str = 1;
+  if (!this->_internal_str().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_str().data(), static_cast<int>(this->_internal_str().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.StyleString.str");
+    target = stream->WriteStringMaybeAliased(
+        1, this->_internal_str(), target);
+  }
+
+  // repeated .aapt.pb.StyleString.Span spans = 2;
+  for (unsigned i = 0,
+      n = static_cast<unsigned>(this->_internal_spans_size()); i < n; i++) {
+    const auto& repfield = this->_internal_spans(i);
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.StyleString)
+  return target;
+}
+
+size_t StyleString::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.StyleString)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // repeated .aapt.pb.StyleString.Span spans = 2;
+  total_size += 1UL * this->_internal_spans_size();
+  for (const auto& msg : this->_impl_.spans_) {
+    total_size +=
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
+  }
+
+  // string str = 1;
+  if (!this->_internal_str().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_str());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyleString::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    StyleString::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyleString::GetClassData() const { return &_class_data_; }
+
+
+void StyleString::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<StyleString*>(&to_msg);
+  auto& from = static_cast<const StyleString&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.StyleString)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  _this->_impl_.spans_.MergeFrom(from._impl_.spans_);
+  if (!from._internal_str().empty()) {
+    _this->_internal_set_str(from._internal_str());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void StyleString::CopyFrom(const StyleString& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.StyleString)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StyleString::IsInitialized() const {
+  return true;
+}
+
+void StyleString::InternalSwap(StyleString* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  _impl_.spans_.InternalSwap(&other->_impl_.spans_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.str_, lhs_arena,
+      &other->_impl_.str_, rhs_arena
+  );
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata StyleString::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[48]);
+}
+
+// ===================================================================
+
+class UntranslatableSection::_Internal {
+ public:
+};
+
+UntranslatableSection::UntranslatableSection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.UntranslatableSection)
+}
+UntranslatableSection::UntranslatableSection(const UntranslatableSection& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  UntranslatableSection* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.start_index_){}
+    , decltype(_impl_.end_index_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  ::memcpy(&_impl_.start_index_, &from._impl_.start_index_,
+    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.end_index_) -
+    reinterpret_cast<char*>(&_impl_.start_index_)) + sizeof(_impl_.end_index_));
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.UntranslatableSection)
+}
+
+inline void UntranslatableSection::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.start_index_){::uint64_t{0u}}
+    , decltype(_impl_.end_index_){::uint64_t{0u}}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+}
+
+UntranslatableSection::~UntranslatableSection() {
+  // @@protoc_insertion_point(destructor:aapt.pb.UntranslatableSection)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void UntranslatableSection::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+}
+
+void UntranslatableSection::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void UntranslatableSection::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.UntranslatableSection)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  ::memset(&_impl_.start_index_, 0, static_cast<size_t>(
+      reinterpret_cast<char*>(&_impl_.end_index_) -
+      reinterpret_cast<char*>(&_impl_.start_index_)) + sizeof(_impl_.end_index_));
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* UntranslatableSection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // uint64 start_index = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
+          _impl_.start_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // uint64 end_index = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
+          _impl_.end_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* UntranslatableSection::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.UntranslatableSection)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // uint64 start_index = 1;
+  if (this->_internal_start_index() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_start_index(), target);
+  }
+
+  // uint64 end_index = 2;
+  if (this->_internal_end_index() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_end_index(), target);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.UntranslatableSection)
+  return target;
+}
+
+size_t UntranslatableSection::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.UntranslatableSection)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // uint64 start_index = 1;
+  if (this->_internal_start_index() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_start_index());
+  }
+
+  // uint64 end_index = 2;
+  if (this->_internal_end_index() != 0) {
+    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_end_index());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UntranslatableSection::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    UntranslatableSection::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UntranslatableSection::GetClassData() const { return &_class_data_; }
+
+
+void UntranslatableSection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<UntranslatableSection*>(&to_msg);
+  auto& from = static_cast<const UntranslatableSection&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.UntranslatableSection)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (from._internal_start_index() != 0) {
+    _this->_internal_set_start_index(from._internal_start_index());
+  }
+  if (from._internal_end_index() != 0) {
+    _this->_internal_set_end_index(from._internal_end_index());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void UntranslatableSection::CopyFrom(const UntranslatableSection& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.UntranslatableSection)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool UntranslatableSection::IsInitialized() const {
+  return true;
+}
+
+void UntranslatableSection::InternalSwap(UntranslatableSection* other) {
+  using std::swap;
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(UntranslatableSection, _impl_.end_index_)
+      + sizeof(UntranslatableSection::_impl_.end_index_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(UntranslatableSection, _impl_.start_index_)>(
+          reinterpret_cast<char*>(&_impl_.start_index_),
+          reinterpret_cast<char*>(&other->_impl_.start_index_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata UntranslatableSection::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_Resources_2eproto_getter, &descriptor_table_Resources_2eproto_once,
+      file_level_metadata_Resources_2eproto[49]);
+}
+
+// @@protoc_insertion_point(namespace_scope)
+}  // namespace pb
+}  // namespace aapt
+PROTOBUF_NAMESPACE_OPEN
+template<> PROTOBUF_NOINLINE ::aapt::pb::StringPool*
+Arena::CreateMaybeMessage< ::aapt::pb::StringPool >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::StringPool >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::SourcePosition*
+Arena::CreateMaybeMessage< ::aapt::pb::SourcePosition >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::SourcePosition >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Source*
+Arena::CreateMaybeMessage< ::aapt::pb::Source >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Source >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::ToolFingerprint*
+Arena::CreateMaybeMessage< ::aapt::pb::ToolFingerprint >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::ToolFingerprint >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::ResourceTable*
+Arena::CreateMaybeMessage< ::aapt::pb::ResourceTable >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::ResourceTable >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::PackageId*
+Arena::CreateMaybeMessage< ::aapt::pb::PackageId >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::PackageId >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Package*
+Arena::CreateMaybeMessage< ::aapt::pb::Package >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Package >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::TypeId*
+Arena::CreateMaybeMessage< ::aapt::pb::TypeId >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::TypeId >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Type*
+Arena::CreateMaybeMessage< ::aapt::pb::Type >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Type >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Visibility*
+Arena::CreateMaybeMessage< ::aapt::pb::Visibility >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Visibility >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::AllowNew*
+Arena::CreateMaybeMessage< ::aapt::pb::AllowNew >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::AllowNew >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Overlayable*
+Arena::CreateMaybeMessage< ::aapt::pb::Overlayable >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Overlayable >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::OverlayableItem*
+Arena::CreateMaybeMessage< ::aapt::pb::OverlayableItem >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::OverlayableItem >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::StagedId*
+Arena::CreateMaybeMessage< ::aapt::pb::StagedId >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::StagedId >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::EntryId*
+Arena::CreateMaybeMessage< ::aapt::pb::EntryId >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::EntryId >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Entry*
+Arena::CreateMaybeMessage< ::aapt::pb::Entry >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Entry >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::ConfigValue*
+Arena::CreateMaybeMessage< ::aapt::pb::ConfigValue >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::ConfigValue >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Value*
+Arena::CreateMaybeMessage< ::aapt::pb::Value >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Value >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Item*
+Arena::CreateMaybeMessage< ::aapt::pb::Item >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Item >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::CompoundValue*
+Arena::CreateMaybeMessage< ::aapt::pb::CompoundValue >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::CompoundValue >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Boolean*
+Arena::CreateMaybeMessage< ::aapt::pb::Boolean >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Boolean >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Reference*
+Arena::CreateMaybeMessage< ::aapt::pb::Reference >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Reference >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Id*
+Arena::CreateMaybeMessage< ::aapt::pb::Id >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Id >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::String*
+Arena::CreateMaybeMessage< ::aapt::pb::String >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::String >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::RawString*
+Arena::CreateMaybeMessage< ::aapt::pb::RawString >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::RawString >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::StyledString_Span*
+Arena::CreateMaybeMessage< ::aapt::pb::StyledString_Span >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::StyledString_Span >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::StyledString*
+Arena::CreateMaybeMessage< ::aapt::pb::StyledString >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::StyledString >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::FileReference*
+Arena::CreateMaybeMessage< ::aapt::pb::FileReference >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::FileReference >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Primitive_NullType*
+Arena::CreateMaybeMessage< ::aapt::pb::Primitive_NullType >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Primitive_NullType >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Primitive_EmptyType*
+Arena::CreateMaybeMessage< ::aapt::pb::Primitive_EmptyType >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Primitive_EmptyType >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Primitive*
+Arena::CreateMaybeMessage< ::aapt::pb::Primitive >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Primitive >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Attribute_Symbol*
+Arena::CreateMaybeMessage< ::aapt::pb::Attribute_Symbol >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Attribute_Symbol >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Attribute*
+Arena::CreateMaybeMessage< ::aapt::pb::Attribute >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Attribute >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Style_Entry*
+Arena::CreateMaybeMessage< ::aapt::pb::Style_Entry >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Style_Entry >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Style*
+Arena::CreateMaybeMessage< ::aapt::pb::Style >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Style >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Styleable_Entry*
+Arena::CreateMaybeMessage< ::aapt::pb::Styleable_Entry >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Styleable_Entry >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Styleable*
+Arena::CreateMaybeMessage< ::aapt::pb::Styleable >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Styleable >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Array_Element*
+Arena::CreateMaybeMessage< ::aapt::pb::Array_Element >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Array_Element >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Array*
+Arena::CreateMaybeMessage< ::aapt::pb::Array >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Array >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Plural_Entry*
+Arena::CreateMaybeMessage< ::aapt::pb::Plural_Entry >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Plural_Entry >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::Plural*
+Arena::CreateMaybeMessage< ::aapt::pb::Plural >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::Plural >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::XmlNode*
+Arena::CreateMaybeMessage< ::aapt::pb::XmlNode >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::XmlNode >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::XmlElement*
+Arena::CreateMaybeMessage< ::aapt::pb::XmlElement >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::XmlElement >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::XmlNamespace*
+Arena::CreateMaybeMessage< ::aapt::pb::XmlNamespace >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::XmlNamespace >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::XmlAttribute*
+Arena::CreateMaybeMessage< ::aapt::pb::XmlAttribute >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::XmlAttribute >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::MacroBody*
+Arena::CreateMaybeMessage< ::aapt::pb::MacroBody >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::MacroBody >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::NamespaceAlias*
+Arena::CreateMaybeMessage< ::aapt::pb::NamespaceAlias >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::NamespaceAlias >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::StyleString_Span*
+Arena::CreateMaybeMessage< ::aapt::pb::StyleString_Span >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::StyleString_Span >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::StyleString*
+Arena::CreateMaybeMessage< ::aapt::pb::StyleString >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::StyleString >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::UntranslatableSection*
+Arena::CreateMaybeMessage< ::aapt::pb::UntranslatableSection >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::UntranslatableSection >(arena);
+}
+PROTOBUF_NAMESPACE_CLOSE
+
+// @@protoc_insertion_point(global_scope)
+#include <google/protobuf/port_undef.inc>
diff --git a/tools/aapt2/Resources.pb.h b/tools/aapt2/Resources.pb.h
new file mode 100644
index 00000000..87549551
--- /dev/null
+++ b/tools/aapt2/Resources.pb.h
@@ -0,0 +1,18784 @@
+// Generated by the protocol buffer compiler.  DO NOT EDIT!
+// source: Resources.proto
+
+#ifndef GOOGLE_PROTOBUF_INCLUDED_Resources_2eproto
+#define GOOGLE_PROTOBUF_INCLUDED_Resources_2eproto
+
+#include <cstdint>
+#include <limits>
+#include <string>
+
+#include <google/protobuf/port_def.inc>
+#if PROTOBUF_VERSION < 3021000
+#error This file was generated by a newer version of protoc which is
+#error incompatible with your Protocol Buffer headers. Please update
+#error your headers.
+#endif
+#if 3021007 < PROTOBUF_MIN_PROTOC_VERSION
+#error This file was generated by an older version of protoc which is
+#error incompatible with your Protocol Buffer headers. Please
+#error regenerate this file with a newer version of protoc.
+#endif
+
+#include <google/protobuf/port_undef.inc>
+#include <google/protobuf/io/coded_stream.h>
+#include <google/protobuf/arena.h>
+#include <google/protobuf/arenastring.h>
+#include <google/protobuf/generated_message_bases.h>
+#include <google/protobuf/generated_message_util.h>
+#include <google/protobuf/metadata_lite.h>
+#include <google/protobuf/generated_message_reflection.h>
+#include <google/protobuf/message.h>
+#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
+#include <google/protobuf/extension_set.h>  // IWYU pragma: export
+#include <google/protobuf/generated_enum_reflection.h>
+#include <google/protobuf/unknown_field_set.h>
+#include "Configuration.pb.h"
+// @@protoc_insertion_point(includes)
+#include <google/protobuf/port_def.inc>
+#define PROTOBUF_INTERNAL_EXPORT_Resources_2eproto
+PROTOBUF_NAMESPACE_OPEN
+namespace internal {
+class AnyMetadata;
+}  // namespace internal
+PROTOBUF_NAMESPACE_CLOSE
+
+// Internal implementation detail -- do not use these members.
+struct TableStruct_Resources_2eproto {
+  static const ::uint32_t offsets[];
+};
+extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Resources_2eproto;
+namespace aapt {
+namespace pb {
+class AllowNew;
+struct AllowNewDefaultTypeInternal;
+extern AllowNewDefaultTypeInternal _AllowNew_default_instance_;
+class Array;
+struct ArrayDefaultTypeInternal;
+extern ArrayDefaultTypeInternal _Array_default_instance_;
+class Array_Element;
+struct Array_ElementDefaultTypeInternal;
+extern Array_ElementDefaultTypeInternal _Array_Element_default_instance_;
+class Attribute;
+struct AttributeDefaultTypeInternal;
+extern AttributeDefaultTypeInternal _Attribute_default_instance_;
+class Attribute_Symbol;
+struct Attribute_SymbolDefaultTypeInternal;
+extern Attribute_SymbolDefaultTypeInternal _Attribute_Symbol_default_instance_;
+class Boolean;
+struct BooleanDefaultTypeInternal;
+extern BooleanDefaultTypeInternal _Boolean_default_instance_;
+class CompoundValue;
+struct CompoundValueDefaultTypeInternal;
+extern CompoundValueDefaultTypeInternal _CompoundValue_default_instance_;
+class ConfigValue;
+struct ConfigValueDefaultTypeInternal;
+extern ConfigValueDefaultTypeInternal _ConfigValue_default_instance_;
+class Entry;
+struct EntryDefaultTypeInternal;
+extern EntryDefaultTypeInternal _Entry_default_instance_;
+class EntryId;
+struct EntryIdDefaultTypeInternal;
+extern EntryIdDefaultTypeInternal _EntryId_default_instance_;
+class FileReference;
+struct FileReferenceDefaultTypeInternal;
+extern FileReferenceDefaultTypeInternal _FileReference_default_instance_;
+class Id;
+struct IdDefaultTypeInternal;
+extern IdDefaultTypeInternal _Id_default_instance_;
+class Item;
+struct ItemDefaultTypeInternal;
+extern ItemDefaultTypeInternal _Item_default_instance_;
+class MacroBody;
+struct MacroBodyDefaultTypeInternal;
+extern MacroBodyDefaultTypeInternal _MacroBody_default_instance_;
+class NamespaceAlias;
+struct NamespaceAliasDefaultTypeInternal;
+extern NamespaceAliasDefaultTypeInternal _NamespaceAlias_default_instance_;
+class Overlayable;
+struct OverlayableDefaultTypeInternal;
+extern OverlayableDefaultTypeInternal _Overlayable_default_instance_;
+class OverlayableItem;
+struct OverlayableItemDefaultTypeInternal;
+extern OverlayableItemDefaultTypeInternal _OverlayableItem_default_instance_;
+class Package;
+struct PackageDefaultTypeInternal;
+extern PackageDefaultTypeInternal _Package_default_instance_;
+class PackageId;
+struct PackageIdDefaultTypeInternal;
+extern PackageIdDefaultTypeInternal _PackageId_default_instance_;
+class Plural;
+struct PluralDefaultTypeInternal;
+extern PluralDefaultTypeInternal _Plural_default_instance_;
+class Plural_Entry;
+struct Plural_EntryDefaultTypeInternal;
+extern Plural_EntryDefaultTypeInternal _Plural_Entry_default_instance_;
+class Primitive;
+struct PrimitiveDefaultTypeInternal;
+extern PrimitiveDefaultTypeInternal _Primitive_default_instance_;
+class Primitive_EmptyType;
+struct Primitive_EmptyTypeDefaultTypeInternal;
+extern Primitive_EmptyTypeDefaultTypeInternal _Primitive_EmptyType_default_instance_;
+class Primitive_NullType;
+struct Primitive_NullTypeDefaultTypeInternal;
+extern Primitive_NullTypeDefaultTypeInternal _Primitive_NullType_default_instance_;
+class RawString;
+struct RawStringDefaultTypeInternal;
+extern RawStringDefaultTypeInternal _RawString_default_instance_;
+class Reference;
+struct ReferenceDefaultTypeInternal;
+extern ReferenceDefaultTypeInternal _Reference_default_instance_;
+class ResourceTable;
+struct ResourceTableDefaultTypeInternal;
+extern ResourceTableDefaultTypeInternal _ResourceTable_default_instance_;
+class Source;
+struct SourceDefaultTypeInternal;
+extern SourceDefaultTypeInternal _Source_default_instance_;
+class SourcePosition;
+struct SourcePositionDefaultTypeInternal;
+extern SourcePositionDefaultTypeInternal _SourcePosition_default_instance_;
+class StagedId;
+struct StagedIdDefaultTypeInternal;
+extern StagedIdDefaultTypeInternal _StagedId_default_instance_;
+class String;
+struct StringDefaultTypeInternal;
+extern StringDefaultTypeInternal _String_default_instance_;
+class StringPool;
+struct StringPoolDefaultTypeInternal;
+extern StringPoolDefaultTypeInternal _StringPool_default_instance_;
+class Style;
+struct StyleDefaultTypeInternal;
+extern StyleDefaultTypeInternal _Style_default_instance_;
+class StyleString;
+struct StyleStringDefaultTypeInternal;
+extern StyleStringDefaultTypeInternal _StyleString_default_instance_;
+class StyleString_Span;
+struct StyleString_SpanDefaultTypeInternal;
+extern StyleString_SpanDefaultTypeInternal _StyleString_Span_default_instance_;
+class Style_Entry;
+struct Style_EntryDefaultTypeInternal;
+extern Style_EntryDefaultTypeInternal _Style_Entry_default_instance_;
+class Styleable;
+struct StyleableDefaultTypeInternal;
+extern StyleableDefaultTypeInternal _Styleable_default_instance_;
+class Styleable_Entry;
+struct Styleable_EntryDefaultTypeInternal;
+extern Styleable_EntryDefaultTypeInternal _Styleable_Entry_default_instance_;
+class StyledString;
+struct StyledStringDefaultTypeInternal;
+extern StyledStringDefaultTypeInternal _StyledString_default_instance_;
+class StyledString_Span;
+struct StyledString_SpanDefaultTypeInternal;
+extern StyledString_SpanDefaultTypeInternal _StyledString_Span_default_instance_;
+class ToolFingerprint;
+struct ToolFingerprintDefaultTypeInternal;
+extern ToolFingerprintDefaultTypeInternal _ToolFingerprint_default_instance_;
+class Type;
+struct TypeDefaultTypeInternal;
+extern TypeDefaultTypeInternal _Type_default_instance_;
+class TypeId;
+struct TypeIdDefaultTypeInternal;
+extern TypeIdDefaultTypeInternal _TypeId_default_instance_;
+class UntranslatableSection;
+struct UntranslatableSectionDefaultTypeInternal;
+extern UntranslatableSectionDefaultTypeInternal _UntranslatableSection_default_instance_;
+class Value;
+struct ValueDefaultTypeInternal;
+extern ValueDefaultTypeInternal _Value_default_instance_;
+class Visibility;
+struct VisibilityDefaultTypeInternal;
+extern VisibilityDefaultTypeInternal _Visibility_default_instance_;
+class XmlAttribute;
+struct XmlAttributeDefaultTypeInternal;
+extern XmlAttributeDefaultTypeInternal _XmlAttribute_default_instance_;
+class XmlElement;
+struct XmlElementDefaultTypeInternal;
+extern XmlElementDefaultTypeInternal _XmlElement_default_instance_;
+class XmlNamespace;
+struct XmlNamespaceDefaultTypeInternal;
+extern XmlNamespaceDefaultTypeInternal _XmlNamespace_default_instance_;
+class XmlNode;
+struct XmlNodeDefaultTypeInternal;
+extern XmlNodeDefaultTypeInternal _XmlNode_default_instance_;
+}  // namespace pb
+}  // namespace aapt
+PROTOBUF_NAMESPACE_OPEN
+template<> ::aapt::pb::AllowNew* Arena::CreateMaybeMessage<::aapt::pb::AllowNew>(Arena*);
+template<> ::aapt::pb::Array* Arena::CreateMaybeMessage<::aapt::pb::Array>(Arena*);
+template<> ::aapt::pb::Array_Element* Arena::CreateMaybeMessage<::aapt::pb::Array_Element>(Arena*);
+template<> ::aapt::pb::Attribute* Arena::CreateMaybeMessage<::aapt::pb::Attribute>(Arena*);
+template<> ::aapt::pb::Attribute_Symbol* Arena::CreateMaybeMessage<::aapt::pb::Attribute_Symbol>(Arena*);
+template<> ::aapt::pb::Boolean* Arena::CreateMaybeMessage<::aapt::pb::Boolean>(Arena*);
+template<> ::aapt::pb::CompoundValue* Arena::CreateMaybeMessage<::aapt::pb::CompoundValue>(Arena*);
+template<> ::aapt::pb::ConfigValue* Arena::CreateMaybeMessage<::aapt::pb::ConfigValue>(Arena*);
+template<> ::aapt::pb::Entry* Arena::CreateMaybeMessage<::aapt::pb::Entry>(Arena*);
+template<> ::aapt::pb::EntryId* Arena::CreateMaybeMessage<::aapt::pb::EntryId>(Arena*);
+template<> ::aapt::pb::FileReference* Arena::CreateMaybeMessage<::aapt::pb::FileReference>(Arena*);
+template<> ::aapt::pb::Id* Arena::CreateMaybeMessage<::aapt::pb::Id>(Arena*);
+template<> ::aapt::pb::Item* Arena::CreateMaybeMessage<::aapt::pb::Item>(Arena*);
+template<> ::aapt::pb::MacroBody* Arena::CreateMaybeMessage<::aapt::pb::MacroBody>(Arena*);
+template<> ::aapt::pb::NamespaceAlias* Arena::CreateMaybeMessage<::aapt::pb::NamespaceAlias>(Arena*);
+template<> ::aapt::pb::Overlayable* Arena::CreateMaybeMessage<::aapt::pb::Overlayable>(Arena*);
+template<> ::aapt::pb::OverlayableItem* Arena::CreateMaybeMessage<::aapt::pb::OverlayableItem>(Arena*);
+template<> ::aapt::pb::Package* Arena::CreateMaybeMessage<::aapt::pb::Package>(Arena*);
+template<> ::aapt::pb::PackageId* Arena::CreateMaybeMessage<::aapt::pb::PackageId>(Arena*);
+template<> ::aapt::pb::Plural* Arena::CreateMaybeMessage<::aapt::pb::Plural>(Arena*);
+template<> ::aapt::pb::Plural_Entry* Arena::CreateMaybeMessage<::aapt::pb::Plural_Entry>(Arena*);
+template<> ::aapt::pb::Primitive* Arena::CreateMaybeMessage<::aapt::pb::Primitive>(Arena*);
+template<> ::aapt::pb::Primitive_EmptyType* Arena::CreateMaybeMessage<::aapt::pb::Primitive_EmptyType>(Arena*);
+template<> ::aapt::pb::Primitive_NullType* Arena::CreateMaybeMessage<::aapt::pb::Primitive_NullType>(Arena*);
+template<> ::aapt::pb::RawString* Arena::CreateMaybeMessage<::aapt::pb::RawString>(Arena*);
+template<> ::aapt::pb::Reference* Arena::CreateMaybeMessage<::aapt::pb::Reference>(Arena*);
+template<> ::aapt::pb::ResourceTable* Arena::CreateMaybeMessage<::aapt::pb::ResourceTable>(Arena*);
+template<> ::aapt::pb::Source* Arena::CreateMaybeMessage<::aapt::pb::Source>(Arena*);
+template<> ::aapt::pb::SourcePosition* Arena::CreateMaybeMessage<::aapt::pb::SourcePosition>(Arena*);
+template<> ::aapt::pb::StagedId* Arena::CreateMaybeMessage<::aapt::pb::StagedId>(Arena*);
+template<> ::aapt::pb::String* Arena::CreateMaybeMessage<::aapt::pb::String>(Arena*);
+template<> ::aapt::pb::StringPool* Arena::CreateMaybeMessage<::aapt::pb::StringPool>(Arena*);
+template<> ::aapt::pb::Style* Arena::CreateMaybeMessage<::aapt::pb::Style>(Arena*);
+template<> ::aapt::pb::StyleString* Arena::CreateMaybeMessage<::aapt::pb::StyleString>(Arena*);
+template<> ::aapt::pb::StyleString_Span* Arena::CreateMaybeMessage<::aapt::pb::StyleString_Span>(Arena*);
+template<> ::aapt::pb::Style_Entry* Arena::CreateMaybeMessage<::aapt::pb::Style_Entry>(Arena*);
+template<> ::aapt::pb::Styleable* Arena::CreateMaybeMessage<::aapt::pb::Styleable>(Arena*);
+template<> ::aapt::pb::Styleable_Entry* Arena::CreateMaybeMessage<::aapt::pb::Styleable_Entry>(Arena*);
+template<> ::aapt::pb::StyledString* Arena::CreateMaybeMessage<::aapt::pb::StyledString>(Arena*);
+template<> ::aapt::pb::StyledString_Span* Arena::CreateMaybeMessage<::aapt::pb::StyledString_Span>(Arena*);
+template<> ::aapt::pb::ToolFingerprint* Arena::CreateMaybeMessage<::aapt::pb::ToolFingerprint>(Arena*);
+template<> ::aapt::pb::Type* Arena::CreateMaybeMessage<::aapt::pb::Type>(Arena*);
+template<> ::aapt::pb::TypeId* Arena::CreateMaybeMessage<::aapt::pb::TypeId>(Arena*);
+template<> ::aapt::pb::UntranslatableSection* Arena::CreateMaybeMessage<::aapt::pb::UntranslatableSection>(Arena*);
+template<> ::aapt::pb::Value* Arena::CreateMaybeMessage<::aapt::pb::Value>(Arena*);
+template<> ::aapt::pb::Visibility* Arena::CreateMaybeMessage<::aapt::pb::Visibility>(Arena*);
+template<> ::aapt::pb::XmlAttribute* Arena::CreateMaybeMessage<::aapt::pb::XmlAttribute>(Arena*);
+template<> ::aapt::pb::XmlElement* Arena::CreateMaybeMessage<::aapt::pb::XmlElement>(Arena*);
+template<> ::aapt::pb::XmlNamespace* Arena::CreateMaybeMessage<::aapt::pb::XmlNamespace>(Arena*);
+template<> ::aapt::pb::XmlNode* Arena::CreateMaybeMessage<::aapt::pb::XmlNode>(Arena*);
+PROTOBUF_NAMESPACE_CLOSE
+namespace aapt {
+namespace pb {
+
+enum Visibility_Level : int {
+  Visibility_Level_UNKNOWN = 0,
+  Visibility_Level_PRIVATE = 1,
+  Visibility_Level_PUBLIC = 2,
+  Visibility_Level_Visibility_Level_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
+  Visibility_Level_Visibility_Level_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
+};
+bool Visibility_Level_IsValid(int value);
+constexpr Visibility_Level Visibility_Level_Level_MIN = Visibility_Level_UNKNOWN;
+constexpr Visibility_Level Visibility_Level_Level_MAX = Visibility_Level_PUBLIC;
+constexpr int Visibility_Level_Level_ARRAYSIZE = Visibility_Level_Level_MAX + 1;
+
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Visibility_Level_descriptor();
+template<typename T>
+inline const std::string& Visibility_Level_Name(T enum_t_value) {
+  static_assert(::std::is_same<T, Visibility_Level>::value ||
+    ::std::is_integral<T>::value,
+    "Incorrect type passed to function Visibility_Level_Name.");
+  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
+    Visibility_Level_descriptor(), enum_t_value);
+}
+inline bool Visibility_Level_Parse(
+    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Visibility_Level* value) {
+  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Visibility_Level>(
+    Visibility_Level_descriptor(), name, value);
+}
+enum OverlayableItem_Policy : int {
+  OverlayableItem_Policy_NONE = 0,
+  OverlayableItem_Policy_PUBLIC = 1,
+  OverlayableItem_Policy_SYSTEM = 2,
+  OverlayableItem_Policy_VENDOR = 3,
+  OverlayableItem_Policy_PRODUCT = 4,
+  OverlayableItem_Policy_SIGNATURE = 5,
+  OverlayableItem_Policy_ODM = 6,
+  OverlayableItem_Policy_OEM = 7,
+  OverlayableItem_Policy_ACTOR = 8,
+  OverlayableItem_Policy_CONFIG_SIGNATURE = 9,
+  OverlayableItem_Policy_OverlayableItem_Policy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
+  OverlayableItem_Policy_OverlayableItem_Policy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
+};
+bool OverlayableItem_Policy_IsValid(int value);
+constexpr OverlayableItem_Policy OverlayableItem_Policy_Policy_MIN = OverlayableItem_Policy_NONE;
+constexpr OverlayableItem_Policy OverlayableItem_Policy_Policy_MAX = OverlayableItem_Policy_CONFIG_SIGNATURE;
+constexpr int OverlayableItem_Policy_Policy_ARRAYSIZE = OverlayableItem_Policy_Policy_MAX + 1;
+
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OverlayableItem_Policy_descriptor();
+template<typename T>
+inline const std::string& OverlayableItem_Policy_Name(T enum_t_value) {
+  static_assert(::std::is_same<T, OverlayableItem_Policy>::value ||
+    ::std::is_integral<T>::value,
+    "Incorrect type passed to function OverlayableItem_Policy_Name.");
+  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
+    OverlayableItem_Policy_descriptor(), enum_t_value);
+}
+inline bool OverlayableItem_Policy_Parse(
+    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OverlayableItem_Policy* value) {
+  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OverlayableItem_Policy>(
+    OverlayableItem_Policy_descriptor(), name, value);
+}
+enum Reference_Type : int {
+  Reference_Type_REFERENCE = 0,
+  Reference_Type_ATTRIBUTE = 1,
+  Reference_Type_Reference_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
+  Reference_Type_Reference_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
+};
+bool Reference_Type_IsValid(int value);
+constexpr Reference_Type Reference_Type_Type_MIN = Reference_Type_REFERENCE;
+constexpr Reference_Type Reference_Type_Type_MAX = Reference_Type_ATTRIBUTE;
+constexpr int Reference_Type_Type_ARRAYSIZE = Reference_Type_Type_MAX + 1;
+
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Reference_Type_descriptor();
+template<typename T>
+inline const std::string& Reference_Type_Name(T enum_t_value) {
+  static_assert(::std::is_same<T, Reference_Type>::value ||
+    ::std::is_integral<T>::value,
+    "Incorrect type passed to function Reference_Type_Name.");
+  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
+    Reference_Type_descriptor(), enum_t_value);
+}
+inline bool Reference_Type_Parse(
+    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Reference_Type* value) {
+  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Reference_Type>(
+    Reference_Type_descriptor(), name, value);
+}
+enum FileReference_Type : int {
+  FileReference_Type_UNKNOWN = 0,
+  FileReference_Type_PNG = 1,
+  FileReference_Type_BINARY_XML = 2,
+  FileReference_Type_PROTO_XML = 3,
+  FileReference_Type_FileReference_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
+  FileReference_Type_FileReference_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
+};
+bool FileReference_Type_IsValid(int value);
+constexpr FileReference_Type FileReference_Type_Type_MIN = FileReference_Type_UNKNOWN;
+constexpr FileReference_Type FileReference_Type_Type_MAX = FileReference_Type_PROTO_XML;
+constexpr int FileReference_Type_Type_ARRAYSIZE = FileReference_Type_Type_MAX + 1;
+
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FileReference_Type_descriptor();
+template<typename T>
+inline const std::string& FileReference_Type_Name(T enum_t_value) {
+  static_assert(::std::is_same<T, FileReference_Type>::value ||
+    ::std::is_integral<T>::value,
+    "Incorrect type passed to function FileReference_Type_Name.");
+  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
+    FileReference_Type_descriptor(), enum_t_value);
+}
+inline bool FileReference_Type_Parse(
+    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileReference_Type* value) {
+  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FileReference_Type>(
+    FileReference_Type_descriptor(), name, value);
+}
+enum Attribute_FormatFlags : int {
+  Attribute_FormatFlags_NONE = 0,
+  Attribute_FormatFlags_ANY = 65535,
+  Attribute_FormatFlags_REFERENCE = 1,
+  Attribute_FormatFlags_STRING = 2,
+  Attribute_FormatFlags_INTEGER = 4,
+  Attribute_FormatFlags_BOOLEAN = 8,
+  Attribute_FormatFlags_COLOR = 16,
+  Attribute_FormatFlags_FLOAT = 32,
+  Attribute_FormatFlags_DIMENSION = 64,
+  Attribute_FormatFlags_FRACTION = 128,
+  Attribute_FormatFlags_ENUM = 65536,
+  Attribute_FormatFlags_FLAGS = 131072,
+  Attribute_FormatFlags_Attribute_FormatFlags_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
+  Attribute_FormatFlags_Attribute_FormatFlags_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
+};
+bool Attribute_FormatFlags_IsValid(int value);
+constexpr Attribute_FormatFlags Attribute_FormatFlags_FormatFlags_MIN = Attribute_FormatFlags_NONE;
+constexpr Attribute_FormatFlags Attribute_FormatFlags_FormatFlags_MAX = Attribute_FormatFlags_FLAGS;
+constexpr int Attribute_FormatFlags_FormatFlags_ARRAYSIZE = Attribute_FormatFlags_FormatFlags_MAX + 1;
+
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Attribute_FormatFlags_descriptor();
+template<typename T>
+inline const std::string& Attribute_FormatFlags_Name(T enum_t_value) {
+  static_assert(::std::is_same<T, Attribute_FormatFlags>::value ||
+    ::std::is_integral<T>::value,
+    "Incorrect type passed to function Attribute_FormatFlags_Name.");
+  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
+    Attribute_FormatFlags_descriptor(), enum_t_value);
+}
+inline bool Attribute_FormatFlags_Parse(
+    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Attribute_FormatFlags* value) {
+  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Attribute_FormatFlags>(
+    Attribute_FormatFlags_descriptor(), name, value);
+}
+enum Plural_Arity : int {
+  Plural_Arity_ZERO = 0,
+  Plural_Arity_ONE = 1,
+  Plural_Arity_TWO = 2,
+  Plural_Arity_FEW = 3,
+  Plural_Arity_MANY = 4,
+  Plural_Arity_OTHER = 5,
+  Plural_Arity_Plural_Arity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
+  Plural_Arity_Plural_Arity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max()
+};
+bool Plural_Arity_IsValid(int value);
+constexpr Plural_Arity Plural_Arity_Arity_MIN = Plural_Arity_ZERO;
+constexpr Plural_Arity Plural_Arity_Arity_MAX = Plural_Arity_OTHER;
+constexpr int Plural_Arity_Arity_ARRAYSIZE = Plural_Arity_Arity_MAX + 1;
+
+const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Plural_Arity_descriptor();
+template<typename T>
+inline const std::string& Plural_Arity_Name(T enum_t_value) {
+  static_assert(::std::is_same<T, Plural_Arity>::value ||
+    ::std::is_integral<T>::value,
+    "Incorrect type passed to function Plural_Arity_Name.");
+  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
+    Plural_Arity_descriptor(), enum_t_value);
+}
+inline bool Plural_Arity_Parse(
+    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Plural_Arity* value) {
+  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Plural_Arity>(
+    Plural_Arity_descriptor(), name, value);
+}
+// ===================================================================
+
+class StringPool final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.StringPool) */ {
+ public:
+  inline StringPool() : StringPool(nullptr) {}
+  ~StringPool() override;
+  explicit PROTOBUF_CONSTEXPR StringPool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  StringPool(const StringPool& from);
+  StringPool(StringPool&& from) noexcept
+    : StringPool() {
+    *this = ::std::move(from);
+  }
+
+  inline StringPool& operator=(const StringPool& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline StringPool& operator=(StringPool&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const StringPool& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const StringPool* internal_default_instance() {
+    return reinterpret_cast<const StringPool*>(
+               &_StringPool_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    0;
+
+  friend void swap(StringPool& a, StringPool& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(StringPool* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(StringPool* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  StringPool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<StringPool>(arena);
+  }
+  StringPool* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const StringPool& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const StringPool& from) {
+    StringPool::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(StringPool* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.StringPool";
+  }
+  protected:
+  explicit StringPool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kDataFieldNumber = 1,
+  };
+  // bytes data = 1;
+  void clear_data();
+  const std::string& data() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_data(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_data();
+  PROTOBUF_NODISCARD std::string* release_data();
+  void set_allocated_data(std::string* data);
+  private:
+  const std::string& _internal_data() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
+  std::string* _internal_mutable_data();
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.StringPool)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class SourcePosition final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.SourcePosition) */ {
+ public:
+  inline SourcePosition() : SourcePosition(nullptr) {}
+  ~SourcePosition() override;
+  explicit PROTOBUF_CONSTEXPR SourcePosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  SourcePosition(const SourcePosition& from);
+  SourcePosition(SourcePosition&& from) noexcept
+    : SourcePosition() {
+    *this = ::std::move(from);
+  }
+
+  inline SourcePosition& operator=(const SourcePosition& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline SourcePosition& operator=(SourcePosition&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const SourcePosition& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const SourcePosition* internal_default_instance() {
+    return reinterpret_cast<const SourcePosition*>(
+               &_SourcePosition_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    1;
+
+  friend void swap(SourcePosition& a, SourcePosition& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(SourcePosition* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(SourcePosition* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  SourcePosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<SourcePosition>(arena);
+  }
+  SourcePosition* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const SourcePosition& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const SourcePosition& from) {
+    SourcePosition::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(SourcePosition* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.SourcePosition";
+  }
+  protected:
+  explicit SourcePosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kLineNumberFieldNumber = 1,
+    kColumnNumberFieldNumber = 2,
+  };
+  // uint32 line_number = 1;
+  void clear_line_number();
+  ::uint32_t line_number() const;
+  void set_line_number(::uint32_t value);
+  private:
+  ::uint32_t _internal_line_number() const;
+  void _internal_set_line_number(::uint32_t value);
+  public:
+
+  // uint32 column_number = 2;
+  void clear_column_number();
+  ::uint32_t column_number() const;
+  void set_column_number(::uint32_t value);
+  private:
+  ::uint32_t _internal_column_number() const;
+  void _internal_set_column_number(::uint32_t value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.SourcePosition)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::uint32_t line_number_;
+    ::uint32_t column_number_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Source final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Source) */ {
+ public:
+  inline Source() : Source(nullptr) {}
+  ~Source() override;
+  explicit PROTOBUF_CONSTEXPR Source(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Source(const Source& from);
+  Source(Source&& from) noexcept
+    : Source() {
+    *this = ::std::move(from);
+  }
+
+  inline Source& operator=(const Source& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Source& operator=(Source&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Source& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Source* internal_default_instance() {
+    return reinterpret_cast<const Source*>(
+               &_Source_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    2;
+
+  friend void swap(Source& a, Source& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Source* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Source* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Source* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Source>(arena);
+  }
+  Source* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Source& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Source& from) {
+    Source::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Source* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Source";
+  }
+  protected:
+  explicit Source(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kPositionFieldNumber = 2,
+    kPathIdxFieldNumber = 1,
+  };
+  // .aapt.pb.SourcePosition position = 2;
+  bool has_position() const;
+  private:
+  bool _internal_has_position() const;
+  public:
+  void clear_position();
+  const ::aapt::pb::SourcePosition& position() const;
+  PROTOBUF_NODISCARD ::aapt::pb::SourcePosition* release_position();
+  ::aapt::pb::SourcePosition* mutable_position();
+  void set_allocated_position(::aapt::pb::SourcePosition* position);
+  private:
+  const ::aapt::pb::SourcePosition& _internal_position() const;
+  ::aapt::pb::SourcePosition* _internal_mutable_position();
+  public:
+  void unsafe_arena_set_allocated_position(
+      ::aapt::pb::SourcePosition* position);
+  ::aapt::pb::SourcePosition* unsafe_arena_release_position();
+
+  // uint32 path_idx = 1;
+  void clear_path_idx();
+  ::uint32_t path_idx() const;
+  void set_path_idx(::uint32_t value);
+  private:
+  ::uint32_t _internal_path_idx() const;
+  void _internal_set_path_idx(::uint32_t value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Source)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::aapt::pb::SourcePosition* position_;
+    ::uint32_t path_idx_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class ToolFingerprint final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.ToolFingerprint) */ {
+ public:
+  inline ToolFingerprint() : ToolFingerprint(nullptr) {}
+  ~ToolFingerprint() override;
+  explicit PROTOBUF_CONSTEXPR ToolFingerprint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  ToolFingerprint(const ToolFingerprint& from);
+  ToolFingerprint(ToolFingerprint&& from) noexcept
+    : ToolFingerprint() {
+    *this = ::std::move(from);
+  }
+
+  inline ToolFingerprint& operator=(const ToolFingerprint& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline ToolFingerprint& operator=(ToolFingerprint&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const ToolFingerprint& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const ToolFingerprint* internal_default_instance() {
+    return reinterpret_cast<const ToolFingerprint*>(
+               &_ToolFingerprint_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    3;
+
+  friend void swap(ToolFingerprint& a, ToolFingerprint& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(ToolFingerprint* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(ToolFingerprint* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  ToolFingerprint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<ToolFingerprint>(arena);
+  }
+  ToolFingerprint* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const ToolFingerprint& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const ToolFingerprint& from) {
+    ToolFingerprint::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(ToolFingerprint* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.ToolFingerprint";
+  }
+  protected:
+  explicit ToolFingerprint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kToolFieldNumber = 1,
+    kVersionFieldNumber = 2,
+  };
+  // string tool = 1;
+  void clear_tool();
+  const std::string& tool() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_tool(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_tool();
+  PROTOBUF_NODISCARD std::string* release_tool();
+  void set_allocated_tool(std::string* tool);
+  private:
+  const std::string& _internal_tool() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tool(const std::string& value);
+  std::string* _internal_mutable_tool();
+  public:
+
+  // string version = 2;
+  void clear_version();
+  const std::string& version() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_version(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_version();
+  PROTOBUF_NODISCARD std::string* release_version();
+  void set_allocated_version(std::string* version);
+  private:
+  const std::string& _internal_version() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
+  std::string* _internal_mutable_version();
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.ToolFingerprint)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tool_;
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class ResourceTable final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.ResourceTable) */ {
+ public:
+  inline ResourceTable() : ResourceTable(nullptr) {}
+  ~ResourceTable() override;
+  explicit PROTOBUF_CONSTEXPR ResourceTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  ResourceTable(const ResourceTable& from);
+  ResourceTable(ResourceTable&& from) noexcept
+    : ResourceTable() {
+    *this = ::std::move(from);
+  }
+
+  inline ResourceTable& operator=(const ResourceTable& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline ResourceTable& operator=(ResourceTable&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const ResourceTable& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const ResourceTable* internal_default_instance() {
+    return reinterpret_cast<const ResourceTable*>(
+               &_ResourceTable_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    4;
+
+  friend void swap(ResourceTable& a, ResourceTable& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(ResourceTable* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(ResourceTable* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  ResourceTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<ResourceTable>(arena);
+  }
+  ResourceTable* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const ResourceTable& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const ResourceTable& from) {
+    ResourceTable::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(ResourceTable* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.ResourceTable";
+  }
+  protected:
+  explicit ResourceTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kPackageFieldNumber = 2,
+    kOverlayableFieldNumber = 3,
+    kToolFingerprintFieldNumber = 4,
+    kSourcePoolFieldNumber = 1,
+  };
+  // repeated .aapt.pb.Package package = 2;
+  int package_size() const;
+  private:
+  int _internal_package_size() const;
+  public:
+  void clear_package();
+  ::aapt::pb::Package* mutable_package(int index);
+  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Package >*
+      mutable_package();
+  private:
+  const ::aapt::pb::Package& _internal_package(int index) const;
+  ::aapt::pb::Package* _internal_add_package();
+  public:
+  const ::aapt::pb::Package& package(int index) const;
+  ::aapt::pb::Package* add_package();
+  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Package >&
+      package() const;
+
+  // repeated .aapt.pb.Overlayable overlayable = 3;
+  int overlayable_size() const;
+  private:
+  int _internal_overlayable_size() const;
+  public:
+  void clear_overlayable();
+  ::aapt::pb::Overlayable* mutable_overlayable(int index);
+  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Overlayable >*
+      mutable_overlayable();
+  private:
+  const ::aapt::pb::Overlayable& _internal_overlayable(int index) const;
+  ::aapt::pb::Overlayable* _internal_add_overlayable();
+  public:
+  const ::aapt::pb::Overlayable& overlayable(int index) const;
+  ::aapt::pb::Overlayable* add_overlayable();
+  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Overlayable >&
+      overlayable() const;
+
+  // repeated .aapt.pb.ToolFingerprint tool_fingerprint = 4;
+  int tool_fingerprint_size() const;
+  private:
+  int _internal_tool_fingerprint_size() const;
+  public:
+  void clear_tool_fingerprint();
+  ::aapt::pb::ToolFingerprint* mutable_tool_fingerprint(int index);
+  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::ToolFingerprint >*
+      mutable_tool_fingerprint();
+  private:
+  const ::aapt::pb::ToolFingerprint& _internal_tool_fingerprint(int index) const;
+  ::aapt::pb::ToolFingerprint* _internal_add_tool_fingerprint();
+  public:
+  const ::aapt::pb::ToolFingerprint& tool_fingerprint(int index) const;
+  ::aapt::pb::ToolFingerprint* add_tool_fingerprint();
+  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::ToolFingerprint >&
+      tool_fingerprint() const;
+
+  // .aapt.pb.StringPool source_pool = 1;
+  bool has_source_pool() const;
+  private:
+  bool _internal_has_source_pool() const;
+  public:
+  void clear_source_pool();
+  const ::aapt::pb::StringPool& source_pool() const;
+  PROTOBUF_NODISCARD ::aapt::pb::StringPool* release_source_pool();
+  ::aapt::pb::StringPool* mutable_source_pool();
+  void set_allocated_source_pool(::aapt::pb::StringPool* source_pool);
+  private:
+  const ::aapt::pb::StringPool& _internal_source_pool() const;
+  ::aapt::pb::StringPool* _internal_mutable_source_pool();
+  public:
+  void unsafe_arena_set_allocated_source_pool(
+      ::aapt::pb::StringPool* source_pool);
+  ::aapt::pb::StringPool* unsafe_arena_release_source_pool();
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.ResourceTable)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Package > package_;
+    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Overlayable > overlayable_;
+    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::ToolFingerprint > tool_fingerprint_;
+    ::aapt::pb::StringPool* source_pool_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class PackageId final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.PackageId) */ {
+ public:
+  inline PackageId() : PackageId(nullptr) {}
+  ~PackageId() override;
+  explicit PROTOBUF_CONSTEXPR PackageId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  PackageId(const PackageId& from);
+  PackageId(PackageId&& from) noexcept
+    : PackageId() {
+    *this = ::std::move(from);
+  }
+
+  inline PackageId& operator=(const PackageId& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline PackageId& operator=(PackageId&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const PackageId& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const PackageId* internal_default_instance() {
+    return reinterpret_cast<const PackageId*>(
+               &_PackageId_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    5;
+
+  friend void swap(PackageId& a, PackageId& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(PackageId* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(PackageId* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  PackageId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<PackageId>(arena);
+  }
+  PackageId* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const PackageId& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const PackageId& from) {
+    PackageId::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(PackageId* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.PackageId";
+  }
+  protected:
+  explicit PackageId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kIdFieldNumber = 1,
+  };
+  // uint32 id = 1;
+  void clear_id();
+  ::uint32_t id() const;
+  void set_id(::uint32_t value);
+  private:
+  ::uint32_t _internal_id() const;
+  void _internal_set_id(::uint32_t value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.PackageId)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::uint32_t id_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Package final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Package) */ {
+ public:
+  inline Package() : Package(nullptr) {}
+  ~Package() override;
+  explicit PROTOBUF_CONSTEXPR Package(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Package(const Package& from);
+  Package(Package&& from) noexcept
+    : Package() {
+    *this = ::std::move(from);
+  }
+
+  inline Package& operator=(const Package& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Package& operator=(Package&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Package& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Package* internal_default_instance() {
+    return reinterpret_cast<const Package*>(
+               &_Package_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    6;
+
+  friend void swap(Package& a, Package& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Package* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Package* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Package* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Package>(arena);
+  }
+  Package* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Package& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Package& from) {
+    Package::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Package* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Package";
+  }
+  protected:
+  explicit Package(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kTypeFieldNumber = 3,
+    kPackageNameFieldNumber = 2,
+    kPackageIdFieldNumber = 1,
+  };
+  // repeated .aapt.pb.Type type = 3;
+  int type_size() const;
+  private:
+  int _internal_type_size() const;
+  public:
+  void clear_type();
+  ::aapt::pb::Type* mutable_type(int index);
+  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Type >*
+      mutable_type();
+  private:
+  const ::aapt::pb::Type& _internal_type(int index) const;
+  ::aapt::pb::Type* _internal_add_type();
+  public:
+  const ::aapt::pb::Type& type(int index) const;
+  ::aapt::pb::Type* add_type();
+  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Type >&
+      type() const;
+
+  // string package_name = 2;
+  void clear_package_name();
+  const std::string& package_name() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_package_name(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_package_name();
+  PROTOBUF_NODISCARD std::string* release_package_name();
+  void set_allocated_package_name(std::string* package_name);
+  private:
+  const std::string& _internal_package_name() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
+  std::string* _internal_mutable_package_name();
+  public:
+
+  // .aapt.pb.PackageId package_id = 1;
+  bool has_package_id() const;
+  private:
+  bool _internal_has_package_id() const;
+  public:
+  void clear_package_id();
+  const ::aapt::pb::PackageId& package_id() const;
+  PROTOBUF_NODISCARD ::aapt::pb::PackageId* release_package_id();
+  ::aapt::pb::PackageId* mutable_package_id();
+  void set_allocated_package_id(::aapt::pb::PackageId* package_id);
+  private:
+  const ::aapt::pb::PackageId& _internal_package_id() const;
+  ::aapt::pb::PackageId* _internal_mutable_package_id();
+  public:
+  void unsafe_arena_set_allocated_package_id(
+      ::aapt::pb::PackageId* package_id);
+  ::aapt::pb::PackageId* unsafe_arena_release_package_id();
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Package)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Type > type_;
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
+    ::aapt::pb::PackageId* package_id_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class TypeId final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.TypeId) */ {
+ public:
+  inline TypeId() : TypeId(nullptr) {}
+  ~TypeId() override;
+  explicit PROTOBUF_CONSTEXPR TypeId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  TypeId(const TypeId& from);
+  TypeId(TypeId&& from) noexcept
+    : TypeId() {
+    *this = ::std::move(from);
+  }
+
+  inline TypeId& operator=(const TypeId& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline TypeId& operator=(TypeId&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const TypeId& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const TypeId* internal_default_instance() {
+    return reinterpret_cast<const TypeId*>(
+               &_TypeId_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    7;
+
+  friend void swap(TypeId& a, TypeId& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(TypeId* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(TypeId* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  TypeId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<TypeId>(arena);
+  }
+  TypeId* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const TypeId& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const TypeId& from) {
+    TypeId::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(TypeId* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.TypeId";
+  }
+  protected:
+  explicit TypeId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kIdFieldNumber = 1,
+  };
+  // uint32 id = 1;
+  void clear_id();
+  ::uint32_t id() const;
+  void set_id(::uint32_t value);
+  private:
+  ::uint32_t _internal_id() const;
+  void _internal_set_id(::uint32_t value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.TypeId)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::uint32_t id_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Type final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Type) */ {
+ public:
+  inline Type() : Type(nullptr) {}
+  ~Type() override;
+  explicit PROTOBUF_CONSTEXPR Type(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Type(const Type& from);
+  Type(Type&& from) noexcept
+    : Type() {
+    *this = ::std::move(from);
+  }
+
+  inline Type& operator=(const Type& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Type& operator=(Type&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Type& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Type* internal_default_instance() {
+    return reinterpret_cast<const Type*>(
+               &_Type_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    8;
+
+  friend void swap(Type& a, Type& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Type* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Type* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Type* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Type>(arena);
+  }
+  Type* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Type& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Type& from) {
+    Type::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Type* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Type";
+  }
+  protected:
+  explicit Type(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kEntryFieldNumber = 3,
+    kNameFieldNumber = 2,
+    kTypeIdFieldNumber = 1,
+  };
+  // repeated .aapt.pb.Entry entry = 3;
+  int entry_size() const;
+  private:
+  int _internal_entry_size() const;
+  public:
+  void clear_entry();
+  ::aapt::pb::Entry* mutable_entry(int index);
+  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Entry >*
+      mutable_entry();
+  private:
+  const ::aapt::pb::Entry& _internal_entry(int index) const;
+  ::aapt::pb::Entry* _internal_add_entry();
+  public:
+  const ::aapt::pb::Entry& entry(int index) const;
+  ::aapt::pb::Entry* add_entry();
+  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Entry >&
+      entry() const;
+
+  // string name = 2;
+  void clear_name();
+  const std::string& name() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_name(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_name();
+  PROTOBUF_NODISCARD std::string* release_name();
+  void set_allocated_name(std::string* name);
+  private:
+  const std::string& _internal_name() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
+  std::string* _internal_mutable_name();
+  public:
+
+  // .aapt.pb.TypeId type_id = 1;
+  bool has_type_id() const;
+  private:
+  bool _internal_has_type_id() const;
+  public:
+  void clear_type_id();
+  const ::aapt::pb::TypeId& type_id() const;
+  PROTOBUF_NODISCARD ::aapt::pb::TypeId* release_type_id();
+  ::aapt::pb::TypeId* mutable_type_id();
+  void set_allocated_type_id(::aapt::pb::TypeId* type_id);
+  private:
+  const ::aapt::pb::TypeId& _internal_type_id() const;
+  ::aapt::pb::TypeId* _internal_mutable_type_id();
+  public:
+  void unsafe_arena_set_allocated_type_id(
+      ::aapt::pb::TypeId* type_id);
+  ::aapt::pb::TypeId* unsafe_arena_release_type_id();
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Type)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Entry > entry_;
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
+    ::aapt::pb::TypeId* type_id_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Visibility final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Visibility) */ {
+ public:
+  inline Visibility() : Visibility(nullptr) {}
+  ~Visibility() override;
+  explicit PROTOBUF_CONSTEXPR Visibility(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Visibility(const Visibility& from);
+  Visibility(Visibility&& from) noexcept
+    : Visibility() {
+    *this = ::std::move(from);
+  }
+
+  inline Visibility& operator=(const Visibility& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Visibility& operator=(Visibility&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Visibility& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Visibility* internal_default_instance() {
+    return reinterpret_cast<const Visibility*>(
+               &_Visibility_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    9;
+
+  friend void swap(Visibility& a, Visibility& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Visibility* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Visibility* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Visibility* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Visibility>(arena);
+  }
+  Visibility* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Visibility& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Visibility& from) {
+    Visibility::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Visibility* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Visibility";
+  }
+  protected:
+  explicit Visibility(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  typedef Visibility_Level Level;
+  static constexpr Level UNKNOWN =
+    Visibility_Level_UNKNOWN;
+  static constexpr Level PRIVATE =
+    Visibility_Level_PRIVATE;
+  static constexpr Level PUBLIC =
+    Visibility_Level_PUBLIC;
+  static inline bool Level_IsValid(int value) {
+    return Visibility_Level_IsValid(value);
+  }
+  static constexpr Level Level_MIN =
+    Visibility_Level_Level_MIN;
+  static constexpr Level Level_MAX =
+    Visibility_Level_Level_MAX;
+  static constexpr int Level_ARRAYSIZE =
+    Visibility_Level_Level_ARRAYSIZE;
+  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
+  Level_descriptor() {
+    return Visibility_Level_descriptor();
+  }
+  template<typename T>
+  static inline const std::string& Level_Name(T enum_t_value) {
+    static_assert(::std::is_same<T, Level>::value ||
+      ::std::is_integral<T>::value,
+      "Incorrect type passed to function Level_Name.");
+    return Visibility_Level_Name(enum_t_value);
+  }
+  static inline bool Level_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
+      Level* value) {
+    return Visibility_Level_Parse(name, value);
+  }
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kCommentFieldNumber = 3,
+    kSourceFieldNumber = 2,
+    kLevelFieldNumber = 1,
+    kStagedApiFieldNumber = 4,
+  };
+  // string comment = 3;
+  void clear_comment();
+  const std::string& comment() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_comment(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_comment();
+  PROTOBUF_NODISCARD std::string* release_comment();
+  void set_allocated_comment(std::string* comment);
+  private:
+  const std::string& _internal_comment() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
+  std::string* _internal_mutable_comment();
+  public:
+
+  // .aapt.pb.Source source = 2;
+  bool has_source() const;
+  private:
+  bool _internal_has_source() const;
+  public:
+  void clear_source();
+  const ::aapt::pb::Source& source() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
+  ::aapt::pb::Source* mutable_source();
+  void set_allocated_source(::aapt::pb::Source* source);
+  private:
+  const ::aapt::pb::Source& _internal_source() const;
+  ::aapt::pb::Source* _internal_mutable_source();
+  public:
+  void unsafe_arena_set_allocated_source(
+      ::aapt::pb::Source* source);
+  ::aapt::pb::Source* unsafe_arena_release_source();
+
+  // .aapt.pb.Visibility.Level level = 1;
+  void clear_level();
+  ::aapt::pb::Visibility_Level level() const;
+  void set_level(::aapt::pb::Visibility_Level value);
+  private:
+  ::aapt::pb::Visibility_Level _internal_level() const;
+  void _internal_set_level(::aapt::pb::Visibility_Level value);
+  public:
+
+  // bool staged_api = 4;
+  void clear_staged_api();
+  bool staged_api() const;
+  void set_staged_api(bool value);
+  private:
+  bool _internal_staged_api() const;
+  void _internal_set_staged_api(bool value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Visibility)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
+    ::aapt::pb::Source* source_;
+    int level_;
+    bool staged_api_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class AllowNew final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.AllowNew) */ {
+ public:
+  inline AllowNew() : AllowNew(nullptr) {}
+  ~AllowNew() override;
+  explicit PROTOBUF_CONSTEXPR AllowNew(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  AllowNew(const AllowNew& from);
+  AllowNew(AllowNew&& from) noexcept
+    : AllowNew() {
+    *this = ::std::move(from);
+  }
+
+  inline AllowNew& operator=(const AllowNew& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline AllowNew& operator=(AllowNew&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const AllowNew& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const AllowNew* internal_default_instance() {
+    return reinterpret_cast<const AllowNew*>(
+               &_AllowNew_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    10;
+
+  friend void swap(AllowNew& a, AllowNew& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(AllowNew* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(AllowNew* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  AllowNew* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<AllowNew>(arena);
+  }
+  AllowNew* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const AllowNew& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const AllowNew& from) {
+    AllowNew::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(AllowNew* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.AllowNew";
+  }
+  protected:
+  explicit AllowNew(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kCommentFieldNumber = 2,
+    kSourceFieldNumber = 1,
+  };
+  // string comment = 2;
+  void clear_comment();
+  const std::string& comment() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_comment(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_comment();
+  PROTOBUF_NODISCARD std::string* release_comment();
+  void set_allocated_comment(std::string* comment);
+  private:
+  const std::string& _internal_comment() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
+  std::string* _internal_mutable_comment();
+  public:
+
+  // .aapt.pb.Source source = 1;
+  bool has_source() const;
+  private:
+  bool _internal_has_source() const;
+  public:
+  void clear_source();
+  const ::aapt::pb::Source& source() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
+  ::aapt::pb::Source* mutable_source();
+  void set_allocated_source(::aapt::pb::Source* source);
+  private:
+  const ::aapt::pb::Source& _internal_source() const;
+  ::aapt::pb::Source* _internal_mutable_source();
+  public:
+  void unsafe_arena_set_allocated_source(
+      ::aapt::pb::Source* source);
+  ::aapt::pb::Source* unsafe_arena_release_source();
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.AllowNew)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
+    ::aapt::pb::Source* source_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Overlayable final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Overlayable) */ {
+ public:
+  inline Overlayable() : Overlayable(nullptr) {}
+  ~Overlayable() override;
+  explicit PROTOBUF_CONSTEXPR Overlayable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Overlayable(const Overlayable& from);
+  Overlayable(Overlayable&& from) noexcept
+    : Overlayable() {
+    *this = ::std::move(from);
+  }
+
+  inline Overlayable& operator=(const Overlayable& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Overlayable& operator=(Overlayable&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Overlayable& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Overlayable* internal_default_instance() {
+    return reinterpret_cast<const Overlayable*>(
+               &_Overlayable_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    11;
+
+  friend void swap(Overlayable& a, Overlayable& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Overlayable* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Overlayable* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Overlayable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Overlayable>(arena);
+  }
+  Overlayable* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Overlayable& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Overlayable& from) {
+    Overlayable::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Overlayable* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Overlayable";
+  }
+  protected:
+  explicit Overlayable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kNameFieldNumber = 1,
+    kActorFieldNumber = 3,
+    kSourceFieldNumber = 2,
+  };
+  // string name = 1;
+  void clear_name();
+  const std::string& name() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_name(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_name();
+  PROTOBUF_NODISCARD std::string* release_name();
+  void set_allocated_name(std::string* name);
+  private:
+  const std::string& _internal_name() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
+  std::string* _internal_mutable_name();
+  public:
+
+  // string actor = 3;
+  void clear_actor();
+  const std::string& actor() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_actor(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_actor();
+  PROTOBUF_NODISCARD std::string* release_actor();
+  void set_allocated_actor(std::string* actor);
+  private:
+  const std::string& _internal_actor() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actor(const std::string& value);
+  std::string* _internal_mutable_actor();
+  public:
+
+  // .aapt.pb.Source source = 2;
+  bool has_source() const;
+  private:
+  bool _internal_has_source() const;
+  public:
+  void clear_source();
+  const ::aapt::pb::Source& source() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
+  ::aapt::pb::Source* mutable_source();
+  void set_allocated_source(::aapt::pb::Source* source);
+  private:
+  const ::aapt::pb::Source& _internal_source() const;
+  ::aapt::pb::Source* _internal_mutable_source();
+  public:
+  void unsafe_arena_set_allocated_source(
+      ::aapt::pb::Source* source);
+  ::aapt::pb::Source* unsafe_arena_release_source();
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Overlayable)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actor_;
+    ::aapt::pb::Source* source_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class OverlayableItem final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.OverlayableItem) */ {
+ public:
+  inline OverlayableItem() : OverlayableItem(nullptr) {}
+  ~OverlayableItem() override;
+  explicit PROTOBUF_CONSTEXPR OverlayableItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  OverlayableItem(const OverlayableItem& from);
+  OverlayableItem(OverlayableItem&& from) noexcept
+    : OverlayableItem() {
+    *this = ::std::move(from);
+  }
+
+  inline OverlayableItem& operator=(const OverlayableItem& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline OverlayableItem& operator=(OverlayableItem&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const OverlayableItem& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const OverlayableItem* internal_default_instance() {
+    return reinterpret_cast<const OverlayableItem*>(
+               &_OverlayableItem_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    12;
+
+  friend void swap(OverlayableItem& a, OverlayableItem& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(OverlayableItem* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(OverlayableItem* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  OverlayableItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<OverlayableItem>(arena);
+  }
+  OverlayableItem* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const OverlayableItem& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const OverlayableItem& from) {
+    OverlayableItem::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(OverlayableItem* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.OverlayableItem";
+  }
+  protected:
+  explicit OverlayableItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  typedef OverlayableItem_Policy Policy;
+  static constexpr Policy NONE =
+    OverlayableItem_Policy_NONE;
+  static constexpr Policy PUBLIC =
+    OverlayableItem_Policy_PUBLIC;
+  static constexpr Policy SYSTEM =
+    OverlayableItem_Policy_SYSTEM;
+  static constexpr Policy VENDOR =
+    OverlayableItem_Policy_VENDOR;
+  static constexpr Policy PRODUCT =
+    OverlayableItem_Policy_PRODUCT;
+  static constexpr Policy SIGNATURE =
+    OverlayableItem_Policy_SIGNATURE;
+  static constexpr Policy ODM =
+    OverlayableItem_Policy_ODM;
+  static constexpr Policy OEM =
+    OverlayableItem_Policy_OEM;
+  static constexpr Policy ACTOR =
+    OverlayableItem_Policy_ACTOR;
+  static constexpr Policy CONFIG_SIGNATURE =
+    OverlayableItem_Policy_CONFIG_SIGNATURE;
+  static inline bool Policy_IsValid(int value) {
+    return OverlayableItem_Policy_IsValid(value);
+  }
+  static constexpr Policy Policy_MIN =
+    OverlayableItem_Policy_Policy_MIN;
+  static constexpr Policy Policy_MAX =
+    OverlayableItem_Policy_Policy_MAX;
+  static constexpr int Policy_ARRAYSIZE =
+    OverlayableItem_Policy_Policy_ARRAYSIZE;
+  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
+  Policy_descriptor() {
+    return OverlayableItem_Policy_descriptor();
+  }
+  template<typename T>
+  static inline const std::string& Policy_Name(T enum_t_value) {
+    static_assert(::std::is_same<T, Policy>::value ||
+      ::std::is_integral<T>::value,
+      "Incorrect type passed to function Policy_Name.");
+    return OverlayableItem_Policy_Name(enum_t_value);
+  }
+  static inline bool Policy_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
+      Policy* value) {
+    return OverlayableItem_Policy_Parse(name, value);
+  }
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kPolicyFieldNumber = 3,
+    kCommentFieldNumber = 2,
+    kSourceFieldNumber = 1,
+    kOverlayableIdxFieldNumber = 4,
+  };
+  // repeated .aapt.pb.OverlayableItem.Policy policy = 3;
+  int policy_size() const;
+  private:
+  int _internal_policy_size() const;
+  public:
+  void clear_policy();
+  private:
+  ::aapt::pb::OverlayableItem_Policy _internal_policy(int index) const;
+  void _internal_add_policy(::aapt::pb::OverlayableItem_Policy value);
+  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_policy();
+  public:
+  ::aapt::pb::OverlayableItem_Policy policy(int index) const;
+  void set_policy(int index, ::aapt::pb::OverlayableItem_Policy value);
+  void add_policy(::aapt::pb::OverlayableItem_Policy value);
+  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& policy() const;
+  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_policy();
+
+  // string comment = 2;
+  void clear_comment();
+  const std::string& comment() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_comment(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_comment();
+  PROTOBUF_NODISCARD std::string* release_comment();
+  void set_allocated_comment(std::string* comment);
+  private:
+  const std::string& _internal_comment() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
+  std::string* _internal_mutable_comment();
+  public:
+
+  // .aapt.pb.Source source = 1;
+  bool has_source() const;
+  private:
+  bool _internal_has_source() const;
+  public:
+  void clear_source();
+  const ::aapt::pb::Source& source() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
+  ::aapt::pb::Source* mutable_source();
+  void set_allocated_source(::aapt::pb::Source* source);
+  private:
+  const ::aapt::pb::Source& _internal_source() const;
+  ::aapt::pb::Source* _internal_mutable_source();
+  public:
+  void unsafe_arena_set_allocated_source(
+      ::aapt::pb::Source* source);
+  ::aapt::pb::Source* unsafe_arena_release_source();
+
+  // uint32 overlayable_idx = 4;
+  void clear_overlayable_idx();
+  ::uint32_t overlayable_idx() const;
+  void set_overlayable_idx(::uint32_t value);
+  private:
+  ::uint32_t _internal_overlayable_idx() const;
+  void _internal_set_overlayable_idx(::uint32_t value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.OverlayableItem)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> policy_;
+    mutable std::atomic<int> _policy_cached_byte_size_;
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
+    ::aapt::pb::Source* source_;
+    ::uint32_t overlayable_idx_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class StagedId final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.StagedId) */ {
+ public:
+  inline StagedId() : StagedId(nullptr) {}
+  ~StagedId() override;
+  explicit PROTOBUF_CONSTEXPR StagedId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  StagedId(const StagedId& from);
+  StagedId(StagedId&& from) noexcept
+    : StagedId() {
+    *this = ::std::move(from);
+  }
+
+  inline StagedId& operator=(const StagedId& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline StagedId& operator=(StagedId&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const StagedId& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const StagedId* internal_default_instance() {
+    return reinterpret_cast<const StagedId*>(
+               &_StagedId_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    13;
+
+  friend void swap(StagedId& a, StagedId& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(StagedId* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(StagedId* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  StagedId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<StagedId>(arena);
+  }
+  StagedId* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const StagedId& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const StagedId& from) {
+    StagedId::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(StagedId* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.StagedId";
+  }
+  protected:
+  explicit StagedId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kSourceFieldNumber = 1,
+    kStagedIdFieldNumber = 2,
+  };
+  // .aapt.pb.Source source = 1;
+  bool has_source() const;
+  private:
+  bool _internal_has_source() const;
+  public:
+  void clear_source();
+  const ::aapt::pb::Source& source() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
+  ::aapt::pb::Source* mutable_source();
+  void set_allocated_source(::aapt::pb::Source* source);
+  private:
+  const ::aapt::pb::Source& _internal_source() const;
+  ::aapt::pb::Source* _internal_mutable_source();
+  public:
+  void unsafe_arena_set_allocated_source(
+      ::aapt::pb::Source* source);
+  ::aapt::pb::Source* unsafe_arena_release_source();
+
+  // uint32 staged_id = 2;
+  void clear_staged_id();
+  ::uint32_t staged_id() const;
+  void set_staged_id(::uint32_t value);
+  private:
+  ::uint32_t _internal_staged_id() const;
+  void _internal_set_staged_id(::uint32_t value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.StagedId)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::aapt::pb::Source* source_;
+    ::uint32_t staged_id_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class EntryId final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.EntryId) */ {
+ public:
+  inline EntryId() : EntryId(nullptr) {}
+  ~EntryId() override;
+  explicit PROTOBUF_CONSTEXPR EntryId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  EntryId(const EntryId& from);
+  EntryId(EntryId&& from) noexcept
+    : EntryId() {
+    *this = ::std::move(from);
+  }
+
+  inline EntryId& operator=(const EntryId& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline EntryId& operator=(EntryId&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const EntryId& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const EntryId* internal_default_instance() {
+    return reinterpret_cast<const EntryId*>(
+               &_EntryId_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    14;
+
+  friend void swap(EntryId& a, EntryId& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(EntryId* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(EntryId* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  EntryId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<EntryId>(arena);
+  }
+  EntryId* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const EntryId& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const EntryId& from) {
+    EntryId::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(EntryId* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.EntryId";
+  }
+  protected:
+  explicit EntryId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kIdFieldNumber = 1,
+  };
+  // uint32 id = 1;
+  void clear_id();
+  ::uint32_t id() const;
+  void set_id(::uint32_t value);
+  private:
+  ::uint32_t _internal_id() const;
+  void _internal_set_id(::uint32_t value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.EntryId)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::uint32_t id_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Entry final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Entry) */ {
+ public:
+  inline Entry() : Entry(nullptr) {}
+  ~Entry() override;
+  explicit PROTOBUF_CONSTEXPR Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Entry(const Entry& from);
+  Entry(Entry&& from) noexcept
+    : Entry() {
+    *this = ::std::move(from);
+  }
+
+  inline Entry& operator=(const Entry& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Entry& operator=(Entry&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Entry& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Entry* internal_default_instance() {
+    return reinterpret_cast<const Entry*>(
+               &_Entry_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    15;
+
+  friend void swap(Entry& a, Entry& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Entry* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Entry* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Entry>(arena);
+  }
+  Entry* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Entry& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Entry& from) {
+    Entry::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Entry* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Entry";
+  }
+  protected:
+  explicit Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kConfigValueFieldNumber = 6,
+    kNameFieldNumber = 2,
+    kEntryIdFieldNumber = 1,
+    kVisibilityFieldNumber = 3,
+    kAllowNewFieldNumber = 4,
+    kOverlayableItemFieldNumber = 5,
+    kStagedIdFieldNumber = 7,
+  };
+  // repeated .aapt.pb.ConfigValue config_value = 6;
+  int config_value_size() const;
+  private:
+  int _internal_config_value_size() const;
+  public:
+  void clear_config_value();
+  ::aapt::pb::ConfigValue* mutable_config_value(int index);
+  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::ConfigValue >*
+      mutable_config_value();
+  private:
+  const ::aapt::pb::ConfigValue& _internal_config_value(int index) const;
+  ::aapt::pb::ConfigValue* _internal_add_config_value();
+  public:
+  const ::aapt::pb::ConfigValue& config_value(int index) const;
+  ::aapt::pb::ConfigValue* add_config_value();
+  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::ConfigValue >&
+      config_value() const;
+
+  // string name = 2;
+  void clear_name();
+  const std::string& name() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_name(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_name();
+  PROTOBUF_NODISCARD std::string* release_name();
+  void set_allocated_name(std::string* name);
+  private:
+  const std::string& _internal_name() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
+  std::string* _internal_mutable_name();
+  public:
+
+  // .aapt.pb.EntryId entry_id = 1;
+  bool has_entry_id() const;
+  private:
+  bool _internal_has_entry_id() const;
+  public:
+  void clear_entry_id();
+  const ::aapt::pb::EntryId& entry_id() const;
+  PROTOBUF_NODISCARD ::aapt::pb::EntryId* release_entry_id();
+  ::aapt::pb::EntryId* mutable_entry_id();
+  void set_allocated_entry_id(::aapt::pb::EntryId* entry_id);
+  private:
+  const ::aapt::pb::EntryId& _internal_entry_id() const;
+  ::aapt::pb::EntryId* _internal_mutable_entry_id();
+  public:
+  void unsafe_arena_set_allocated_entry_id(
+      ::aapt::pb::EntryId* entry_id);
+  ::aapt::pb::EntryId* unsafe_arena_release_entry_id();
+
+  // .aapt.pb.Visibility visibility = 3;
+  bool has_visibility() const;
+  private:
+  bool _internal_has_visibility() const;
+  public:
+  void clear_visibility();
+  const ::aapt::pb::Visibility& visibility() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Visibility* release_visibility();
+  ::aapt::pb::Visibility* mutable_visibility();
+  void set_allocated_visibility(::aapt::pb::Visibility* visibility);
+  private:
+  const ::aapt::pb::Visibility& _internal_visibility() const;
+  ::aapt::pb::Visibility* _internal_mutable_visibility();
+  public:
+  void unsafe_arena_set_allocated_visibility(
+      ::aapt::pb::Visibility* visibility);
+  ::aapt::pb::Visibility* unsafe_arena_release_visibility();
+
+  // .aapt.pb.AllowNew allow_new = 4;
+  bool has_allow_new() const;
+  private:
+  bool _internal_has_allow_new() const;
+  public:
+  void clear_allow_new();
+  const ::aapt::pb::AllowNew& allow_new() const;
+  PROTOBUF_NODISCARD ::aapt::pb::AllowNew* release_allow_new();
+  ::aapt::pb::AllowNew* mutable_allow_new();
+  void set_allocated_allow_new(::aapt::pb::AllowNew* allow_new);
+  private:
+  const ::aapt::pb::AllowNew& _internal_allow_new() const;
+  ::aapt::pb::AllowNew* _internal_mutable_allow_new();
+  public:
+  void unsafe_arena_set_allocated_allow_new(
+      ::aapt::pb::AllowNew* allow_new);
+  ::aapt::pb::AllowNew* unsafe_arena_release_allow_new();
+
+  // .aapt.pb.OverlayableItem overlayable_item = 5;
+  bool has_overlayable_item() const;
+  private:
+  bool _internal_has_overlayable_item() const;
+  public:
+  void clear_overlayable_item();
+  const ::aapt::pb::OverlayableItem& overlayable_item() const;
+  PROTOBUF_NODISCARD ::aapt::pb::OverlayableItem* release_overlayable_item();
+  ::aapt::pb::OverlayableItem* mutable_overlayable_item();
+  void set_allocated_overlayable_item(::aapt::pb::OverlayableItem* overlayable_item);
+  private:
+  const ::aapt::pb::OverlayableItem& _internal_overlayable_item() const;
+  ::aapt::pb::OverlayableItem* _internal_mutable_overlayable_item();
+  public:
+  void unsafe_arena_set_allocated_overlayable_item(
+      ::aapt::pb::OverlayableItem* overlayable_item);
+  ::aapt::pb::OverlayableItem* unsafe_arena_release_overlayable_item();
+
+  // .aapt.pb.StagedId staged_id = 7;
+  bool has_staged_id() const;
+  private:
+  bool _internal_has_staged_id() const;
+  public:
+  void clear_staged_id();
+  const ::aapt::pb::StagedId& staged_id() const;
+  PROTOBUF_NODISCARD ::aapt::pb::StagedId* release_staged_id();
+  ::aapt::pb::StagedId* mutable_staged_id();
+  void set_allocated_staged_id(::aapt::pb::StagedId* staged_id);
+  private:
+  const ::aapt::pb::StagedId& _internal_staged_id() const;
+  ::aapt::pb::StagedId* _internal_mutable_staged_id();
+  public:
+  void unsafe_arena_set_allocated_staged_id(
+      ::aapt::pb::StagedId* staged_id);
+  ::aapt::pb::StagedId* unsafe_arena_release_staged_id();
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Entry)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::ConfigValue > config_value_;
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
+    ::aapt::pb::EntryId* entry_id_;
+    ::aapt::pb::Visibility* visibility_;
+    ::aapt::pb::AllowNew* allow_new_;
+    ::aapt::pb::OverlayableItem* overlayable_item_;
+    ::aapt::pb::StagedId* staged_id_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class ConfigValue final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.ConfigValue) */ {
+ public:
+  inline ConfigValue() : ConfigValue(nullptr) {}
+  ~ConfigValue() override;
+  explicit PROTOBUF_CONSTEXPR ConfigValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  ConfigValue(const ConfigValue& from);
+  ConfigValue(ConfigValue&& from) noexcept
+    : ConfigValue() {
+    *this = ::std::move(from);
+  }
+
+  inline ConfigValue& operator=(const ConfigValue& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline ConfigValue& operator=(ConfigValue&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const ConfigValue& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const ConfigValue* internal_default_instance() {
+    return reinterpret_cast<const ConfigValue*>(
+               &_ConfigValue_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    16;
+
+  friend void swap(ConfigValue& a, ConfigValue& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(ConfigValue* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(ConfigValue* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  ConfigValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<ConfigValue>(arena);
+  }
+  ConfigValue* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const ConfigValue& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const ConfigValue& from) {
+    ConfigValue::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(ConfigValue* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.ConfigValue";
+  }
+  protected:
+  explicit ConfigValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kConfigFieldNumber = 1,
+    kValueFieldNumber = 2,
+  };
+  // .aapt.pb.Configuration config = 1;
+  bool has_config() const;
+  private:
+  bool _internal_has_config() const;
+  public:
+  void clear_config();
+  const ::aapt::pb::Configuration& config() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Configuration* release_config();
+  ::aapt::pb::Configuration* mutable_config();
+  void set_allocated_config(::aapt::pb::Configuration* config);
+  private:
+  const ::aapt::pb::Configuration& _internal_config() const;
+  ::aapt::pb::Configuration* _internal_mutable_config();
+  public:
+  void unsafe_arena_set_allocated_config(
+      ::aapt::pb::Configuration* config);
+  ::aapt::pb::Configuration* unsafe_arena_release_config();
+
+  // .aapt.pb.Value value = 2;
+  bool has_value() const;
+  private:
+  bool _internal_has_value() const;
+  public:
+  void clear_value();
+  const ::aapt::pb::Value& value() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Value* release_value();
+  ::aapt::pb::Value* mutable_value();
+  void set_allocated_value(::aapt::pb::Value* value);
+  private:
+  const ::aapt::pb::Value& _internal_value() const;
+  ::aapt::pb::Value* _internal_mutable_value();
+  public:
+  void unsafe_arena_set_allocated_value(
+      ::aapt::pb::Value* value);
+  ::aapt::pb::Value* unsafe_arena_release_value();
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.ConfigValue)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::aapt::pb::Configuration* config_;
+    ::aapt::pb::Value* value_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Value final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Value) */ {
+ public:
+  inline Value() : Value(nullptr) {}
+  ~Value() override;
+  explicit PROTOBUF_CONSTEXPR Value(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Value(const Value& from);
+  Value(Value&& from) noexcept
+    : Value() {
+    *this = ::std::move(from);
+  }
+
+  inline Value& operator=(const Value& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Value& operator=(Value&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Value& default_instance() {
+    return *internal_default_instance();
+  }
+  enum ValueCase {
+    kItem = 4,
+    kCompoundValue = 5,
+    VALUE_NOT_SET = 0,
+  };
+
+  static inline const Value* internal_default_instance() {
+    return reinterpret_cast<const Value*>(
+               &_Value_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    17;
+
+  friend void swap(Value& a, Value& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Value* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Value* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Value>(arena);
+  }
+  Value* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Value& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Value& from) {
+    Value::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Value* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Value";
+  }
+  protected:
+  explicit Value(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kCommentFieldNumber = 2,
+    kSourceFieldNumber = 1,
+    kWeakFieldNumber = 3,
+    kItemFieldNumber = 4,
+    kCompoundValueFieldNumber = 5,
+  };
+  // string comment = 2;
+  void clear_comment();
+  const std::string& comment() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_comment(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_comment();
+  PROTOBUF_NODISCARD std::string* release_comment();
+  void set_allocated_comment(std::string* comment);
+  private:
+  const std::string& _internal_comment() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
+  std::string* _internal_mutable_comment();
+  public:
+
+  // .aapt.pb.Source source = 1;
+  bool has_source() const;
+  private:
+  bool _internal_has_source() const;
+  public:
+  void clear_source();
+  const ::aapt::pb::Source& source() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
+  ::aapt::pb::Source* mutable_source();
+  void set_allocated_source(::aapt::pb::Source* source);
+  private:
+  const ::aapt::pb::Source& _internal_source() const;
+  ::aapt::pb::Source* _internal_mutable_source();
+  public:
+  void unsafe_arena_set_allocated_source(
+      ::aapt::pb::Source* source);
+  ::aapt::pb::Source* unsafe_arena_release_source();
+
+  // bool weak = 3;
+  void clear_weak();
+  bool weak() const;
+  void set_weak(bool value);
+  private:
+  bool _internal_weak() const;
+  void _internal_set_weak(bool value);
+  public:
+
+  // .aapt.pb.Item item = 4;
+  bool has_item() const;
+  private:
+  bool _internal_has_item() const;
+  public:
+  void clear_item();
+  const ::aapt::pb::Item& item() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Item* release_item();
+  ::aapt::pb::Item* mutable_item();
+  void set_allocated_item(::aapt::pb::Item* item);
+  private:
+  const ::aapt::pb::Item& _internal_item() const;
+  ::aapt::pb::Item* _internal_mutable_item();
+  public:
+  void unsafe_arena_set_allocated_item(
+      ::aapt::pb::Item* item);
+  ::aapt::pb::Item* unsafe_arena_release_item();
+
+  // .aapt.pb.CompoundValue compound_value = 5;
+  bool has_compound_value() const;
+  private:
+  bool _internal_has_compound_value() const;
+  public:
+  void clear_compound_value();
+  const ::aapt::pb::CompoundValue& compound_value() const;
+  PROTOBUF_NODISCARD ::aapt::pb::CompoundValue* release_compound_value();
+  ::aapt::pb::CompoundValue* mutable_compound_value();
+  void set_allocated_compound_value(::aapt::pb::CompoundValue* compound_value);
+  private:
+  const ::aapt::pb::CompoundValue& _internal_compound_value() const;
+  ::aapt::pb::CompoundValue* _internal_mutable_compound_value();
+  public:
+  void unsafe_arena_set_allocated_compound_value(
+      ::aapt::pb::CompoundValue* compound_value);
+  ::aapt::pb::CompoundValue* unsafe_arena_release_compound_value();
+
+  void clear_value();
+  ValueCase value_case() const;
+  // @@protoc_insertion_point(class_scope:aapt.pb.Value)
+ private:
+  class _Internal;
+  void set_has_item();
+  void set_has_compound_value();
+
+  inline bool has_value() const;
+  inline void clear_has_value();
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
+    ::aapt::pb::Source* source_;
+    bool weak_;
+    union ValueUnion {
+      constexpr ValueUnion() : _constinit_{} {}
+        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
+      ::aapt::pb::Item* item_;
+      ::aapt::pb::CompoundValue* compound_value_;
+    } value_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+    ::uint32_t _oneof_case_[1];
+
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Item final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Item) */ {
+ public:
+  inline Item() : Item(nullptr) {}
+  ~Item() override;
+  explicit PROTOBUF_CONSTEXPR Item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Item(const Item& from);
+  Item(Item&& from) noexcept
+    : Item() {
+    *this = ::std::move(from);
+  }
+
+  inline Item& operator=(const Item& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Item& operator=(Item&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Item& default_instance() {
+    return *internal_default_instance();
+  }
+  enum ValueCase {
+    kRef = 1,
+    kStr = 2,
+    kRawStr = 3,
+    kStyledStr = 4,
+    kFile = 5,
+    kId = 6,
+    kPrim = 7,
+    VALUE_NOT_SET = 0,
+  };
+
+  static inline const Item* internal_default_instance() {
+    return reinterpret_cast<const Item*>(
+               &_Item_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    18;
+
+  friend void swap(Item& a, Item& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Item* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Item* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Item>(arena);
+  }
+  Item* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Item& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Item& from) {
+    Item::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Item* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Item";
+  }
+  protected:
+  explicit Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kRefFieldNumber = 1,
+    kStrFieldNumber = 2,
+    kRawStrFieldNumber = 3,
+    kStyledStrFieldNumber = 4,
+    kFileFieldNumber = 5,
+    kIdFieldNumber = 6,
+    kPrimFieldNumber = 7,
+  };
+  // .aapt.pb.Reference ref = 1;
+  bool has_ref() const;
+  private:
+  bool _internal_has_ref() const;
+  public:
+  void clear_ref();
+  const ::aapt::pb::Reference& ref() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Reference* release_ref();
+  ::aapt::pb::Reference* mutable_ref();
+  void set_allocated_ref(::aapt::pb::Reference* ref);
+  private:
+  const ::aapt::pb::Reference& _internal_ref() const;
+  ::aapt::pb::Reference* _internal_mutable_ref();
+  public:
+  void unsafe_arena_set_allocated_ref(
+      ::aapt::pb::Reference* ref);
+  ::aapt::pb::Reference* unsafe_arena_release_ref();
+
+  // .aapt.pb.String str = 2;
+  bool has_str() const;
+  private:
+  bool _internal_has_str() const;
+  public:
+  void clear_str();
+  const ::aapt::pb::String& str() const;
+  PROTOBUF_NODISCARD ::aapt::pb::String* release_str();
+  ::aapt::pb::String* mutable_str();
+  void set_allocated_str(::aapt::pb::String* str);
+  private:
+  const ::aapt::pb::String& _internal_str() const;
+  ::aapt::pb::String* _internal_mutable_str();
+  public:
+  void unsafe_arena_set_allocated_str(
+      ::aapt::pb::String* str);
+  ::aapt::pb::String* unsafe_arena_release_str();
+
+  // .aapt.pb.RawString raw_str = 3;
+  bool has_raw_str() const;
+  private:
+  bool _internal_has_raw_str() const;
+  public:
+  void clear_raw_str();
+  const ::aapt::pb::RawString& raw_str() const;
+  PROTOBUF_NODISCARD ::aapt::pb::RawString* release_raw_str();
+  ::aapt::pb::RawString* mutable_raw_str();
+  void set_allocated_raw_str(::aapt::pb::RawString* raw_str);
+  private:
+  const ::aapt::pb::RawString& _internal_raw_str() const;
+  ::aapt::pb::RawString* _internal_mutable_raw_str();
+  public:
+  void unsafe_arena_set_allocated_raw_str(
+      ::aapt::pb::RawString* raw_str);
+  ::aapt::pb::RawString* unsafe_arena_release_raw_str();
+
+  // .aapt.pb.StyledString styled_str = 4;
+  bool has_styled_str() const;
+  private:
+  bool _internal_has_styled_str() const;
+  public:
+  void clear_styled_str();
+  const ::aapt::pb::StyledString& styled_str() const;
+  PROTOBUF_NODISCARD ::aapt::pb::StyledString* release_styled_str();
+  ::aapt::pb::StyledString* mutable_styled_str();
+  void set_allocated_styled_str(::aapt::pb::StyledString* styled_str);
+  private:
+  const ::aapt::pb::StyledString& _internal_styled_str() const;
+  ::aapt::pb::StyledString* _internal_mutable_styled_str();
+  public:
+  void unsafe_arena_set_allocated_styled_str(
+      ::aapt::pb::StyledString* styled_str);
+  ::aapt::pb::StyledString* unsafe_arena_release_styled_str();
+
+  // .aapt.pb.FileReference file = 5;
+  bool has_file() const;
+  private:
+  bool _internal_has_file() const;
+  public:
+  void clear_file();
+  const ::aapt::pb::FileReference& file() const;
+  PROTOBUF_NODISCARD ::aapt::pb::FileReference* release_file();
+  ::aapt::pb::FileReference* mutable_file();
+  void set_allocated_file(::aapt::pb::FileReference* file);
+  private:
+  const ::aapt::pb::FileReference& _internal_file() const;
+  ::aapt::pb::FileReference* _internal_mutable_file();
+  public:
+  void unsafe_arena_set_allocated_file(
+      ::aapt::pb::FileReference* file);
+  ::aapt::pb::FileReference* unsafe_arena_release_file();
+
+  // .aapt.pb.Id id = 6;
+  bool has_id() const;
+  private:
+  bool _internal_has_id() const;
+  public:
+  void clear_id();
+  const ::aapt::pb::Id& id() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Id* release_id();
+  ::aapt::pb::Id* mutable_id();
+  void set_allocated_id(::aapt::pb::Id* id);
+  private:
+  const ::aapt::pb::Id& _internal_id() const;
+  ::aapt::pb::Id* _internal_mutable_id();
+  public:
+  void unsafe_arena_set_allocated_id(
+      ::aapt::pb::Id* id);
+  ::aapt::pb::Id* unsafe_arena_release_id();
+
+  // .aapt.pb.Primitive prim = 7;
+  bool has_prim() const;
+  private:
+  bool _internal_has_prim() const;
+  public:
+  void clear_prim();
+  const ::aapt::pb::Primitive& prim() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Primitive* release_prim();
+  ::aapt::pb::Primitive* mutable_prim();
+  void set_allocated_prim(::aapt::pb::Primitive* prim);
+  private:
+  const ::aapt::pb::Primitive& _internal_prim() const;
+  ::aapt::pb::Primitive* _internal_mutable_prim();
+  public:
+  void unsafe_arena_set_allocated_prim(
+      ::aapt::pb::Primitive* prim);
+  ::aapt::pb::Primitive* unsafe_arena_release_prim();
+
+  void clear_value();
+  ValueCase value_case() const;
+  // @@protoc_insertion_point(class_scope:aapt.pb.Item)
+ private:
+  class _Internal;
+  void set_has_ref();
+  void set_has_str();
+  void set_has_raw_str();
+  void set_has_styled_str();
+  void set_has_file();
+  void set_has_id();
+  void set_has_prim();
+
+  inline bool has_value() const;
+  inline void clear_has_value();
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    union ValueUnion {
+      constexpr ValueUnion() : _constinit_{} {}
+        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
+      ::aapt::pb::Reference* ref_;
+      ::aapt::pb::String* str_;
+      ::aapt::pb::RawString* raw_str_;
+      ::aapt::pb::StyledString* styled_str_;
+      ::aapt::pb::FileReference* file_;
+      ::aapt::pb::Id* id_;
+      ::aapt::pb::Primitive* prim_;
+    } value_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+    ::uint32_t _oneof_case_[1];
+
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class CompoundValue final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.CompoundValue) */ {
+ public:
+  inline CompoundValue() : CompoundValue(nullptr) {}
+  ~CompoundValue() override;
+  explicit PROTOBUF_CONSTEXPR CompoundValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  CompoundValue(const CompoundValue& from);
+  CompoundValue(CompoundValue&& from) noexcept
+    : CompoundValue() {
+    *this = ::std::move(from);
+  }
+
+  inline CompoundValue& operator=(const CompoundValue& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline CompoundValue& operator=(CompoundValue&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const CompoundValue& default_instance() {
+    return *internal_default_instance();
+  }
+  enum ValueCase {
+    kAttr = 1,
+    kStyle = 2,
+    kStyleable = 3,
+    kArray = 4,
+    kPlural = 5,
+    kMacro = 6,
+    VALUE_NOT_SET = 0,
+  };
+
+  static inline const CompoundValue* internal_default_instance() {
+    return reinterpret_cast<const CompoundValue*>(
+               &_CompoundValue_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    19;
+
+  friend void swap(CompoundValue& a, CompoundValue& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(CompoundValue* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(CompoundValue* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  CompoundValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<CompoundValue>(arena);
+  }
+  CompoundValue* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const CompoundValue& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const CompoundValue& from) {
+    CompoundValue::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(CompoundValue* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.CompoundValue";
+  }
+  protected:
+  explicit CompoundValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kAttrFieldNumber = 1,
+    kStyleFieldNumber = 2,
+    kStyleableFieldNumber = 3,
+    kArrayFieldNumber = 4,
+    kPluralFieldNumber = 5,
+    kMacroFieldNumber = 6,
+  };
+  // .aapt.pb.Attribute attr = 1;
+  bool has_attr() const;
+  private:
+  bool _internal_has_attr() const;
+  public:
+  void clear_attr();
+  const ::aapt::pb::Attribute& attr() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Attribute* release_attr();
+  ::aapt::pb::Attribute* mutable_attr();
+  void set_allocated_attr(::aapt::pb::Attribute* attr);
+  private:
+  const ::aapt::pb::Attribute& _internal_attr() const;
+  ::aapt::pb::Attribute* _internal_mutable_attr();
+  public:
+  void unsafe_arena_set_allocated_attr(
+      ::aapt::pb::Attribute* attr);
+  ::aapt::pb::Attribute* unsafe_arena_release_attr();
+
+  // .aapt.pb.Style style = 2;
+  bool has_style() const;
+  private:
+  bool _internal_has_style() const;
+  public:
+  void clear_style();
+  const ::aapt::pb::Style& style() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Style* release_style();
+  ::aapt::pb::Style* mutable_style();
+  void set_allocated_style(::aapt::pb::Style* style);
+  private:
+  const ::aapt::pb::Style& _internal_style() const;
+  ::aapt::pb::Style* _internal_mutable_style();
+  public:
+  void unsafe_arena_set_allocated_style(
+      ::aapt::pb::Style* style);
+  ::aapt::pb::Style* unsafe_arena_release_style();
+
+  // .aapt.pb.Styleable styleable = 3;
+  bool has_styleable() const;
+  private:
+  bool _internal_has_styleable() const;
+  public:
+  void clear_styleable();
+  const ::aapt::pb::Styleable& styleable() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Styleable* release_styleable();
+  ::aapt::pb::Styleable* mutable_styleable();
+  void set_allocated_styleable(::aapt::pb::Styleable* styleable);
+  private:
+  const ::aapt::pb::Styleable& _internal_styleable() const;
+  ::aapt::pb::Styleable* _internal_mutable_styleable();
+  public:
+  void unsafe_arena_set_allocated_styleable(
+      ::aapt::pb::Styleable* styleable);
+  ::aapt::pb::Styleable* unsafe_arena_release_styleable();
+
+  // .aapt.pb.Array array = 4;
+  bool has_array() const;
+  private:
+  bool _internal_has_array() const;
+  public:
+  void clear_array();
+  const ::aapt::pb::Array& array() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Array* release_array();
+  ::aapt::pb::Array* mutable_array();
+  void set_allocated_array(::aapt::pb::Array* array);
+  private:
+  const ::aapt::pb::Array& _internal_array() const;
+  ::aapt::pb::Array* _internal_mutable_array();
+  public:
+  void unsafe_arena_set_allocated_array(
+      ::aapt::pb::Array* array);
+  ::aapt::pb::Array* unsafe_arena_release_array();
+
+  // .aapt.pb.Plural plural = 5;
+  bool has_plural() const;
+  private:
+  bool _internal_has_plural() const;
+  public:
+  void clear_plural();
+  const ::aapt::pb::Plural& plural() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Plural* release_plural();
+  ::aapt::pb::Plural* mutable_plural();
+  void set_allocated_plural(::aapt::pb::Plural* plural);
+  private:
+  const ::aapt::pb::Plural& _internal_plural() const;
+  ::aapt::pb::Plural* _internal_mutable_plural();
+  public:
+  void unsafe_arena_set_allocated_plural(
+      ::aapt::pb::Plural* plural);
+  ::aapt::pb::Plural* unsafe_arena_release_plural();
+
+  // .aapt.pb.MacroBody macro = 6;
+  bool has_macro() const;
+  private:
+  bool _internal_has_macro() const;
+  public:
+  void clear_macro();
+  const ::aapt::pb::MacroBody& macro() const;
+  PROTOBUF_NODISCARD ::aapt::pb::MacroBody* release_macro();
+  ::aapt::pb::MacroBody* mutable_macro();
+  void set_allocated_macro(::aapt::pb::MacroBody* macro);
+  private:
+  const ::aapt::pb::MacroBody& _internal_macro() const;
+  ::aapt::pb::MacroBody* _internal_mutable_macro();
+  public:
+  void unsafe_arena_set_allocated_macro(
+      ::aapt::pb::MacroBody* macro);
+  ::aapt::pb::MacroBody* unsafe_arena_release_macro();
+
+  void clear_value();
+  ValueCase value_case() const;
+  // @@protoc_insertion_point(class_scope:aapt.pb.CompoundValue)
+ private:
+  class _Internal;
+  void set_has_attr();
+  void set_has_style();
+  void set_has_styleable();
+  void set_has_array();
+  void set_has_plural();
+  void set_has_macro();
+
+  inline bool has_value() const;
+  inline void clear_has_value();
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    union ValueUnion {
+      constexpr ValueUnion() : _constinit_{} {}
+        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
+      ::aapt::pb::Attribute* attr_;
+      ::aapt::pb::Style* style_;
+      ::aapt::pb::Styleable* styleable_;
+      ::aapt::pb::Array* array_;
+      ::aapt::pb::Plural* plural_;
+      ::aapt::pb::MacroBody* macro_;
+    } value_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+    ::uint32_t _oneof_case_[1];
+
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Boolean final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Boolean) */ {
+ public:
+  inline Boolean() : Boolean(nullptr) {}
+  ~Boolean() override;
+  explicit PROTOBUF_CONSTEXPR Boolean(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Boolean(const Boolean& from);
+  Boolean(Boolean&& from) noexcept
+    : Boolean() {
+    *this = ::std::move(from);
+  }
+
+  inline Boolean& operator=(const Boolean& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Boolean& operator=(Boolean&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Boolean& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Boolean* internal_default_instance() {
+    return reinterpret_cast<const Boolean*>(
+               &_Boolean_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    20;
+
+  friend void swap(Boolean& a, Boolean& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Boolean* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Boolean* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Boolean* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Boolean>(arena);
+  }
+  Boolean* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Boolean& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Boolean& from) {
+    Boolean::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Boolean* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Boolean";
+  }
+  protected:
+  explicit Boolean(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kValueFieldNumber = 1,
+  };
+  // bool value = 1;
+  void clear_value();
+  bool value() const;
+  void set_value(bool value);
+  private:
+  bool _internal_value() const;
+  void _internal_set_value(bool value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Boolean)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    bool value_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Reference final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Reference) */ {
+ public:
+  inline Reference() : Reference(nullptr) {}
+  ~Reference() override;
+  explicit PROTOBUF_CONSTEXPR Reference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Reference(const Reference& from);
+  Reference(Reference&& from) noexcept
+    : Reference() {
+    *this = ::std::move(from);
+  }
+
+  inline Reference& operator=(const Reference& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Reference& operator=(Reference&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Reference& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Reference* internal_default_instance() {
+    return reinterpret_cast<const Reference*>(
+               &_Reference_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    21;
+
+  friend void swap(Reference& a, Reference& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Reference* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Reference* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Reference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Reference>(arena);
+  }
+  Reference* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Reference& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Reference& from) {
+    Reference::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Reference* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Reference";
+  }
+  protected:
+  explicit Reference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  typedef Reference_Type Type;
+  static constexpr Type REFERENCE =
+    Reference_Type_REFERENCE;
+  static constexpr Type ATTRIBUTE =
+    Reference_Type_ATTRIBUTE;
+  static inline bool Type_IsValid(int value) {
+    return Reference_Type_IsValid(value);
+  }
+  static constexpr Type Type_MIN =
+    Reference_Type_Type_MIN;
+  static constexpr Type Type_MAX =
+    Reference_Type_Type_MAX;
+  static constexpr int Type_ARRAYSIZE =
+    Reference_Type_Type_ARRAYSIZE;
+  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
+  Type_descriptor() {
+    return Reference_Type_descriptor();
+  }
+  template<typename T>
+  static inline const std::string& Type_Name(T enum_t_value) {
+    static_assert(::std::is_same<T, Type>::value ||
+      ::std::is_integral<T>::value,
+      "Incorrect type passed to function Type_Name.");
+    return Reference_Type_Name(enum_t_value);
+  }
+  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
+      Type* value) {
+    return Reference_Type_Parse(name, value);
+  }
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kNameFieldNumber = 3,
+    kIsDynamicFieldNumber = 5,
+    kTypeFieldNumber = 1,
+    kIdFieldNumber = 2,
+    kPrivateFieldNumber = 4,
+    kAllowRawFieldNumber = 7,
+    kTypeFlagsFieldNumber = 6,
+  };
+  // string name = 3;
+  void clear_name();
+  const std::string& name() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_name(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_name();
+  PROTOBUF_NODISCARD std::string* release_name();
+  void set_allocated_name(std::string* name);
+  private:
+  const std::string& _internal_name() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
+  std::string* _internal_mutable_name();
+  public:
+
+  // .aapt.pb.Boolean is_dynamic = 5;
+  bool has_is_dynamic() const;
+  private:
+  bool _internal_has_is_dynamic() const;
+  public:
+  void clear_is_dynamic();
+  const ::aapt::pb::Boolean& is_dynamic() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Boolean* release_is_dynamic();
+  ::aapt::pb::Boolean* mutable_is_dynamic();
+  void set_allocated_is_dynamic(::aapt::pb::Boolean* is_dynamic);
+  private:
+  const ::aapt::pb::Boolean& _internal_is_dynamic() const;
+  ::aapt::pb::Boolean* _internal_mutable_is_dynamic();
+  public:
+  void unsafe_arena_set_allocated_is_dynamic(
+      ::aapt::pb::Boolean* is_dynamic);
+  ::aapt::pb::Boolean* unsafe_arena_release_is_dynamic();
+
+  // .aapt.pb.Reference.Type type = 1;
+  void clear_type();
+  ::aapt::pb::Reference_Type type() const;
+  void set_type(::aapt::pb::Reference_Type value);
+  private:
+  ::aapt::pb::Reference_Type _internal_type() const;
+  void _internal_set_type(::aapt::pb::Reference_Type value);
+  public:
+
+  // uint32 id = 2;
+  void clear_id();
+  ::uint32_t id() const;
+  void set_id(::uint32_t value);
+  private:
+  ::uint32_t _internal_id() const;
+  void _internal_set_id(::uint32_t value);
+  public:
+
+  // bool private = 4;
+  void clear_private_();
+  bool private_() const;
+  void set_private_(bool value);
+  private:
+  bool _internal_private_() const;
+  void _internal_set_private_(bool value);
+  public:
+
+  // bool allow_raw = 7;
+  void clear_allow_raw();
+  bool allow_raw() const;
+  void set_allow_raw(bool value);
+  private:
+  bool _internal_allow_raw() const;
+  void _internal_set_allow_raw(bool value);
+  public:
+
+  // uint32 type_flags = 6;
+  void clear_type_flags();
+  ::uint32_t type_flags() const;
+  void set_type_flags(::uint32_t value);
+  private:
+  ::uint32_t _internal_type_flags() const;
+  void _internal_set_type_flags(::uint32_t value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Reference)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
+    ::aapt::pb::Boolean* is_dynamic_;
+    int type_;
+    ::uint32_t id_;
+    bool private__;
+    bool allow_raw_;
+    ::uint32_t type_flags_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Id final :
+    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:aapt.pb.Id) */ {
+ public:
+  inline Id() : Id(nullptr) {}
+  explicit PROTOBUF_CONSTEXPR Id(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Id(const Id& from);
+  Id(Id&& from) noexcept
+    : Id() {
+    *this = ::std::move(from);
+  }
+
+  inline Id& operator=(const Id& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Id& operator=(Id&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Id& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Id* internal_default_instance() {
+    return reinterpret_cast<const Id*>(
+               &_Id_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    22;
+
+  friend void swap(Id& a, Id& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Id* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Id* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Id* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Id>(arena);
+  }
+  Id* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
+  inline void CopyFrom(const Id& from) {
+    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
+  void MergeFrom(const Id& from) {
+    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
+  }
+  public:
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Id";
+  }
+  protected:
+  explicit Id(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Id)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+  };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class String final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.String) */ {
+ public:
+  inline String() : String(nullptr) {}
+  ~String() override;
+  explicit PROTOBUF_CONSTEXPR String(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  String(const String& from);
+  String(String&& from) noexcept
+    : String() {
+    *this = ::std::move(from);
+  }
+
+  inline String& operator=(const String& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline String& operator=(String&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const String& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const String* internal_default_instance() {
+    return reinterpret_cast<const String*>(
+               &_String_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    23;
+
+  friend void swap(String& a, String& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(String* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(String* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  String* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<String>(arena);
+  }
+  String* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const String& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const String& from) {
+    String::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(String* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.String";
+  }
+  protected:
+  explicit String(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kValueFieldNumber = 1,
+  };
+  // string value = 1;
+  void clear_value();
+  const std::string& value() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_value(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_value();
+  PROTOBUF_NODISCARD std::string* release_value();
+  void set_allocated_value(std::string* value);
+  private:
+  const std::string& _internal_value() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
+  std::string* _internal_mutable_value();
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.String)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class RawString final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.RawString) */ {
+ public:
+  inline RawString() : RawString(nullptr) {}
+  ~RawString() override;
+  explicit PROTOBUF_CONSTEXPR RawString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  RawString(const RawString& from);
+  RawString(RawString&& from) noexcept
+    : RawString() {
+    *this = ::std::move(from);
+  }
+
+  inline RawString& operator=(const RawString& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline RawString& operator=(RawString&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const RawString& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const RawString* internal_default_instance() {
+    return reinterpret_cast<const RawString*>(
+               &_RawString_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    24;
+
+  friend void swap(RawString& a, RawString& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(RawString* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(RawString* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  RawString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<RawString>(arena);
+  }
+  RawString* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const RawString& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const RawString& from) {
+    RawString::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(RawString* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.RawString";
+  }
+  protected:
+  explicit RawString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kValueFieldNumber = 1,
+  };
+  // string value = 1;
+  void clear_value();
+  const std::string& value() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_value(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_value();
+  PROTOBUF_NODISCARD std::string* release_value();
+  void set_allocated_value(std::string* value);
+  private:
+  const std::string& _internal_value() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
+  std::string* _internal_mutable_value();
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.RawString)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class StyledString_Span final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.StyledString.Span) */ {
+ public:
+  inline StyledString_Span() : StyledString_Span(nullptr) {}
+  ~StyledString_Span() override;
+  explicit PROTOBUF_CONSTEXPR StyledString_Span(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  StyledString_Span(const StyledString_Span& from);
+  StyledString_Span(StyledString_Span&& from) noexcept
+    : StyledString_Span() {
+    *this = ::std::move(from);
+  }
+
+  inline StyledString_Span& operator=(const StyledString_Span& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline StyledString_Span& operator=(StyledString_Span&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const StyledString_Span& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const StyledString_Span* internal_default_instance() {
+    return reinterpret_cast<const StyledString_Span*>(
+               &_StyledString_Span_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    25;
+
+  friend void swap(StyledString_Span& a, StyledString_Span& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(StyledString_Span* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(StyledString_Span* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  StyledString_Span* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<StyledString_Span>(arena);
+  }
+  StyledString_Span* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const StyledString_Span& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const StyledString_Span& from) {
+    StyledString_Span::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(StyledString_Span* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.StyledString.Span";
+  }
+  protected:
+  explicit StyledString_Span(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kTagFieldNumber = 1,
+    kFirstCharFieldNumber = 2,
+    kLastCharFieldNumber = 3,
+  };
+  // string tag = 1;
+  void clear_tag();
+  const std::string& tag() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_tag(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_tag();
+  PROTOBUF_NODISCARD std::string* release_tag();
+  void set_allocated_tag(std::string* tag);
+  private:
+  const std::string& _internal_tag() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
+  std::string* _internal_mutable_tag();
+  public:
+
+  // uint32 first_char = 2;
+  void clear_first_char();
+  ::uint32_t first_char() const;
+  void set_first_char(::uint32_t value);
+  private:
+  ::uint32_t _internal_first_char() const;
+  void _internal_set_first_char(::uint32_t value);
+  public:
+
+  // uint32 last_char = 3;
+  void clear_last_char();
+  ::uint32_t last_char() const;
+  void set_last_char(::uint32_t value);
+  private:
+  ::uint32_t _internal_last_char() const;
+  void _internal_set_last_char(::uint32_t value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.StyledString.Span)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
+    ::uint32_t first_char_;
+    ::uint32_t last_char_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class StyledString final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.StyledString) */ {
+ public:
+  inline StyledString() : StyledString(nullptr) {}
+  ~StyledString() override;
+  explicit PROTOBUF_CONSTEXPR StyledString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  StyledString(const StyledString& from);
+  StyledString(StyledString&& from) noexcept
+    : StyledString() {
+    *this = ::std::move(from);
+  }
+
+  inline StyledString& operator=(const StyledString& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline StyledString& operator=(StyledString&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const StyledString& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const StyledString* internal_default_instance() {
+    return reinterpret_cast<const StyledString*>(
+               &_StyledString_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    26;
+
+  friend void swap(StyledString& a, StyledString& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(StyledString* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(StyledString* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  StyledString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<StyledString>(arena);
+  }
+  StyledString* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const StyledString& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const StyledString& from) {
+    StyledString::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(StyledString* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.StyledString";
+  }
+  protected:
+  explicit StyledString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  typedef StyledString_Span Span;
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kSpanFieldNumber = 2,
+    kValueFieldNumber = 1,
+  };
+  // repeated .aapt.pb.StyledString.Span span = 2;
+  int span_size() const;
+  private:
+  int _internal_span_size() const;
+  public:
+  void clear_span();
+  ::aapt::pb::StyledString_Span* mutable_span(int index);
+  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::StyledString_Span >*
+      mutable_span();
+  private:
+  const ::aapt::pb::StyledString_Span& _internal_span(int index) const;
+  ::aapt::pb::StyledString_Span* _internal_add_span();
+  public:
+  const ::aapt::pb::StyledString_Span& span(int index) const;
+  ::aapt::pb::StyledString_Span* add_span();
+  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::StyledString_Span >&
+      span() const;
+
+  // string value = 1;
+  void clear_value();
+  const std::string& value() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_value(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_value();
+  PROTOBUF_NODISCARD std::string* release_value();
+  void set_allocated_value(std::string* value);
+  private:
+  const std::string& _internal_value() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
+  std::string* _internal_mutable_value();
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.StyledString)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::StyledString_Span > span_;
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class FileReference final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.FileReference) */ {
+ public:
+  inline FileReference() : FileReference(nullptr) {}
+  ~FileReference() override;
+  explicit PROTOBUF_CONSTEXPR FileReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  FileReference(const FileReference& from);
+  FileReference(FileReference&& from) noexcept
+    : FileReference() {
+    *this = ::std::move(from);
+  }
+
+  inline FileReference& operator=(const FileReference& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline FileReference& operator=(FileReference&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const FileReference& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const FileReference* internal_default_instance() {
+    return reinterpret_cast<const FileReference*>(
+               &_FileReference_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    27;
+
+  friend void swap(FileReference& a, FileReference& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(FileReference* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(FileReference* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  FileReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<FileReference>(arena);
+  }
+  FileReference* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const FileReference& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const FileReference& from) {
+    FileReference::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(FileReference* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.FileReference";
+  }
+  protected:
+  explicit FileReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  typedef FileReference_Type Type;
+  static constexpr Type UNKNOWN =
+    FileReference_Type_UNKNOWN;
+  static constexpr Type PNG =
+    FileReference_Type_PNG;
+  static constexpr Type BINARY_XML =
+    FileReference_Type_BINARY_XML;
+  static constexpr Type PROTO_XML =
+    FileReference_Type_PROTO_XML;
+  static inline bool Type_IsValid(int value) {
+    return FileReference_Type_IsValid(value);
+  }
+  static constexpr Type Type_MIN =
+    FileReference_Type_Type_MIN;
+  static constexpr Type Type_MAX =
+    FileReference_Type_Type_MAX;
+  static constexpr int Type_ARRAYSIZE =
+    FileReference_Type_Type_ARRAYSIZE;
+  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
+  Type_descriptor() {
+    return FileReference_Type_descriptor();
+  }
+  template<typename T>
+  static inline const std::string& Type_Name(T enum_t_value) {
+    static_assert(::std::is_same<T, Type>::value ||
+      ::std::is_integral<T>::value,
+      "Incorrect type passed to function Type_Name.");
+    return FileReference_Type_Name(enum_t_value);
+  }
+  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
+      Type* value) {
+    return FileReference_Type_Parse(name, value);
+  }
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kPathFieldNumber = 1,
+    kTypeFieldNumber = 2,
+  };
+  // string path = 1;
+  void clear_path();
+  const std::string& path() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_path(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_path();
+  PROTOBUF_NODISCARD std::string* release_path();
+  void set_allocated_path(std::string* path);
+  private:
+  const std::string& _internal_path() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
+  std::string* _internal_mutable_path();
+  public:
+
+  // .aapt.pb.FileReference.Type type = 2;
+  void clear_type();
+  ::aapt::pb::FileReference_Type type() const;
+  void set_type(::aapt::pb::FileReference_Type value);
+  private:
+  ::aapt::pb::FileReference_Type _internal_type() const;
+  void _internal_set_type(::aapt::pb::FileReference_Type value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.FileReference)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
+    int type_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Primitive_NullType final :
+    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:aapt.pb.Primitive.NullType) */ {
+ public:
+  inline Primitive_NullType() : Primitive_NullType(nullptr) {}
+  explicit PROTOBUF_CONSTEXPR Primitive_NullType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Primitive_NullType(const Primitive_NullType& from);
+  Primitive_NullType(Primitive_NullType&& from) noexcept
+    : Primitive_NullType() {
+    *this = ::std::move(from);
+  }
+
+  inline Primitive_NullType& operator=(const Primitive_NullType& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Primitive_NullType& operator=(Primitive_NullType&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Primitive_NullType& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Primitive_NullType* internal_default_instance() {
+    return reinterpret_cast<const Primitive_NullType*>(
+               &_Primitive_NullType_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    28;
+
+  friend void swap(Primitive_NullType& a, Primitive_NullType& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Primitive_NullType* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Primitive_NullType* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Primitive_NullType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Primitive_NullType>(arena);
+  }
+  Primitive_NullType* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
+  inline void CopyFrom(const Primitive_NullType& from) {
+    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
+  void MergeFrom(const Primitive_NullType& from) {
+    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
+  }
+  public:
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Primitive.NullType";
+  }
+  protected:
+  explicit Primitive_NullType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Primitive.NullType)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+  };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Primitive_EmptyType final :
+    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:aapt.pb.Primitive.EmptyType) */ {
+ public:
+  inline Primitive_EmptyType() : Primitive_EmptyType(nullptr) {}
+  explicit PROTOBUF_CONSTEXPR Primitive_EmptyType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Primitive_EmptyType(const Primitive_EmptyType& from);
+  Primitive_EmptyType(Primitive_EmptyType&& from) noexcept
+    : Primitive_EmptyType() {
+    *this = ::std::move(from);
+  }
+
+  inline Primitive_EmptyType& operator=(const Primitive_EmptyType& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Primitive_EmptyType& operator=(Primitive_EmptyType&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Primitive_EmptyType& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Primitive_EmptyType* internal_default_instance() {
+    return reinterpret_cast<const Primitive_EmptyType*>(
+               &_Primitive_EmptyType_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    29;
+
+  friend void swap(Primitive_EmptyType& a, Primitive_EmptyType& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Primitive_EmptyType* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Primitive_EmptyType* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Primitive_EmptyType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Primitive_EmptyType>(arena);
+  }
+  Primitive_EmptyType* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
+  inline void CopyFrom(const Primitive_EmptyType& from) {
+    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
+  void MergeFrom(const Primitive_EmptyType& from) {
+    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
+  }
+  public:
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Primitive.EmptyType";
+  }
+  protected:
+  explicit Primitive_EmptyType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Primitive.EmptyType)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+  };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Primitive final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Primitive) */ {
+ public:
+  inline Primitive() : Primitive(nullptr) {}
+  ~Primitive() override;
+  explicit PROTOBUF_CONSTEXPR Primitive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Primitive(const Primitive& from);
+  Primitive(Primitive&& from) noexcept
+    : Primitive() {
+    *this = ::std::move(from);
+  }
+
+  inline Primitive& operator=(const Primitive& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Primitive& operator=(Primitive&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Primitive& default_instance() {
+    return *internal_default_instance();
+  }
+  enum OneofValueCase {
+    kNullValue = 1,
+    kEmptyValue = 2,
+    kFloatValue = 3,
+    kDimensionValue = 13,
+    kFractionValue = 14,
+    kIntDecimalValue = 6,
+    kIntHexadecimalValue = 7,
+    kBooleanValue = 8,
+    kColorArgb8Value = 9,
+    kColorRgb8Value = 10,
+    kColorArgb4Value = 11,
+    kColorRgb4Value = 12,
+    kDimensionValueDeprecated = 4,
+    kFractionValueDeprecated = 5,
+    ONEOF_VALUE_NOT_SET = 0,
+  };
+
+  static inline const Primitive* internal_default_instance() {
+    return reinterpret_cast<const Primitive*>(
+               &_Primitive_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    30;
+
+  friend void swap(Primitive& a, Primitive& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Primitive* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Primitive* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Primitive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Primitive>(arena);
+  }
+  Primitive* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Primitive& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Primitive& from) {
+    Primitive::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Primitive* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Primitive";
+  }
+  protected:
+  explicit Primitive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  typedef Primitive_NullType NullType;
+  typedef Primitive_EmptyType EmptyType;
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kNullValueFieldNumber = 1,
+    kEmptyValueFieldNumber = 2,
+    kFloatValueFieldNumber = 3,
+    kDimensionValueFieldNumber = 13,
+    kFractionValueFieldNumber = 14,
+    kIntDecimalValueFieldNumber = 6,
+    kIntHexadecimalValueFieldNumber = 7,
+    kBooleanValueFieldNumber = 8,
+    kColorArgb8ValueFieldNumber = 9,
+    kColorRgb8ValueFieldNumber = 10,
+    kColorArgb4ValueFieldNumber = 11,
+    kColorRgb4ValueFieldNumber = 12,
+    kDimensionValueDeprecatedFieldNumber = 4,
+    kFractionValueDeprecatedFieldNumber = 5,
+  };
+  // .aapt.pb.Primitive.NullType null_value = 1;
+  bool has_null_value() const;
+  private:
+  bool _internal_has_null_value() const;
+  public:
+  void clear_null_value();
+  const ::aapt::pb::Primitive_NullType& null_value() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Primitive_NullType* release_null_value();
+  ::aapt::pb::Primitive_NullType* mutable_null_value();
+  void set_allocated_null_value(::aapt::pb::Primitive_NullType* null_value);
+  private:
+  const ::aapt::pb::Primitive_NullType& _internal_null_value() const;
+  ::aapt::pb::Primitive_NullType* _internal_mutable_null_value();
+  public:
+  void unsafe_arena_set_allocated_null_value(
+      ::aapt::pb::Primitive_NullType* null_value);
+  ::aapt::pb::Primitive_NullType* unsafe_arena_release_null_value();
+
+  // .aapt.pb.Primitive.EmptyType empty_value = 2;
+  bool has_empty_value() const;
+  private:
+  bool _internal_has_empty_value() const;
+  public:
+  void clear_empty_value();
+  const ::aapt::pb::Primitive_EmptyType& empty_value() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Primitive_EmptyType* release_empty_value();
+  ::aapt::pb::Primitive_EmptyType* mutable_empty_value();
+  void set_allocated_empty_value(::aapt::pb::Primitive_EmptyType* empty_value);
+  private:
+  const ::aapt::pb::Primitive_EmptyType& _internal_empty_value() const;
+  ::aapt::pb::Primitive_EmptyType* _internal_mutable_empty_value();
+  public:
+  void unsafe_arena_set_allocated_empty_value(
+      ::aapt::pb::Primitive_EmptyType* empty_value);
+  ::aapt::pb::Primitive_EmptyType* unsafe_arena_release_empty_value();
+
+  // float float_value = 3;
+  bool has_float_value() const;
+  private:
+  bool _internal_has_float_value() const;
+  public:
+  void clear_float_value();
+  float float_value() const;
+  void set_float_value(float value);
+  private:
+  float _internal_float_value() const;
+  void _internal_set_float_value(float value);
+  public:
+
+  // uint32 dimension_value = 13;
+  bool has_dimension_value() const;
+  private:
+  bool _internal_has_dimension_value() const;
+  public:
+  void clear_dimension_value();
+  ::uint32_t dimension_value() const;
+  void set_dimension_value(::uint32_t value);
+  private:
+  ::uint32_t _internal_dimension_value() const;
+  void _internal_set_dimension_value(::uint32_t value);
+  public:
+
+  // uint32 fraction_value = 14;
+  bool has_fraction_value() const;
+  private:
+  bool _internal_has_fraction_value() const;
+  public:
+  void clear_fraction_value();
+  ::uint32_t fraction_value() const;
+  void set_fraction_value(::uint32_t value);
+  private:
+  ::uint32_t _internal_fraction_value() const;
+  void _internal_set_fraction_value(::uint32_t value);
+  public:
+
+  // int32 int_decimal_value = 6;
+  bool has_int_decimal_value() const;
+  private:
+  bool _internal_has_int_decimal_value() const;
+  public:
+  void clear_int_decimal_value();
+  ::int32_t int_decimal_value() const;
+  void set_int_decimal_value(::int32_t value);
+  private:
+  ::int32_t _internal_int_decimal_value() const;
+  void _internal_set_int_decimal_value(::int32_t value);
+  public:
+
+  // uint32 int_hexadecimal_value = 7;
+  bool has_int_hexadecimal_value() const;
+  private:
+  bool _internal_has_int_hexadecimal_value() const;
+  public:
+  void clear_int_hexadecimal_value();
+  ::uint32_t int_hexadecimal_value() const;
+  void set_int_hexadecimal_value(::uint32_t value);
+  private:
+  ::uint32_t _internal_int_hexadecimal_value() const;
+  void _internal_set_int_hexadecimal_value(::uint32_t value);
+  public:
+
+  // bool boolean_value = 8;
+  bool has_boolean_value() const;
+  private:
+  bool _internal_has_boolean_value() const;
+  public:
+  void clear_boolean_value();
+  bool boolean_value() const;
+  void set_boolean_value(bool value);
+  private:
+  bool _internal_boolean_value() const;
+  void _internal_set_boolean_value(bool value);
+  public:
+
+  // uint32 color_argb8_value = 9;
+  bool has_color_argb8_value() const;
+  private:
+  bool _internal_has_color_argb8_value() const;
+  public:
+  void clear_color_argb8_value();
+  ::uint32_t color_argb8_value() const;
+  void set_color_argb8_value(::uint32_t value);
+  private:
+  ::uint32_t _internal_color_argb8_value() const;
+  void _internal_set_color_argb8_value(::uint32_t value);
+  public:
+
+  // uint32 color_rgb8_value = 10;
+  bool has_color_rgb8_value() const;
+  private:
+  bool _internal_has_color_rgb8_value() const;
+  public:
+  void clear_color_rgb8_value();
+  ::uint32_t color_rgb8_value() const;
+  void set_color_rgb8_value(::uint32_t value);
+  private:
+  ::uint32_t _internal_color_rgb8_value() const;
+  void _internal_set_color_rgb8_value(::uint32_t value);
+  public:
+
+  // uint32 color_argb4_value = 11;
+  bool has_color_argb4_value() const;
+  private:
+  bool _internal_has_color_argb4_value() const;
+  public:
+  void clear_color_argb4_value();
+  ::uint32_t color_argb4_value() const;
+  void set_color_argb4_value(::uint32_t value);
+  private:
+  ::uint32_t _internal_color_argb4_value() const;
+  void _internal_set_color_argb4_value(::uint32_t value);
+  public:
+
+  // uint32 color_rgb4_value = 12;
+  bool has_color_rgb4_value() const;
+  private:
+  bool _internal_has_color_rgb4_value() const;
+  public:
+  void clear_color_rgb4_value();
+  ::uint32_t color_rgb4_value() const;
+  void set_color_rgb4_value(::uint32_t value);
+  private:
+  ::uint32_t _internal_color_rgb4_value() const;
+  void _internal_set_color_rgb4_value(::uint32_t value);
+  public:
+
+  // float dimension_value_deprecated = 4 [deprecated = true];
+  PROTOBUF_DEPRECATED bool has_dimension_value_deprecated() const;
+  private:
+  bool _internal_has_dimension_value_deprecated() const;
+  public:
+  PROTOBUF_DEPRECATED void clear_dimension_value_deprecated();
+  PROTOBUF_DEPRECATED float dimension_value_deprecated() const;
+  PROTOBUF_DEPRECATED void set_dimension_value_deprecated(float value);
+  private:
+  float _internal_dimension_value_deprecated() const;
+  void _internal_set_dimension_value_deprecated(float value);
+  public:
+
+  // float fraction_value_deprecated = 5 [deprecated = true];
+  PROTOBUF_DEPRECATED bool has_fraction_value_deprecated() const;
+  private:
+  bool _internal_has_fraction_value_deprecated() const;
+  public:
+  PROTOBUF_DEPRECATED void clear_fraction_value_deprecated();
+  PROTOBUF_DEPRECATED float fraction_value_deprecated() const;
+  PROTOBUF_DEPRECATED void set_fraction_value_deprecated(float value);
+  private:
+  float _internal_fraction_value_deprecated() const;
+  void _internal_set_fraction_value_deprecated(float value);
+  public:
+
+  void clear_oneof_value();
+  OneofValueCase oneof_value_case() const;
+  // @@protoc_insertion_point(class_scope:aapt.pb.Primitive)
+ private:
+  class _Internal;
+  void set_has_null_value();
+  void set_has_empty_value();
+  void set_has_float_value();
+  void set_has_dimension_value();
+  void set_has_fraction_value();
+  void set_has_int_decimal_value();
+  void set_has_int_hexadecimal_value();
+  void set_has_boolean_value();
+  void set_has_color_argb8_value();
+  void set_has_color_rgb8_value();
+  void set_has_color_argb4_value();
+  void set_has_color_rgb4_value();
+  void set_has_dimension_value_deprecated();
+  void set_has_fraction_value_deprecated();
+
+  inline bool has_oneof_value() const;
+  inline void clear_has_oneof_value();
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    union OneofValueUnion {
+      constexpr OneofValueUnion() : _constinit_{} {}
+        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
+      ::aapt::pb::Primitive_NullType* null_value_;
+      ::aapt::pb::Primitive_EmptyType* empty_value_;
+      float float_value_;
+      ::uint32_t dimension_value_;
+      ::uint32_t fraction_value_;
+      ::int32_t int_decimal_value_;
+      ::uint32_t int_hexadecimal_value_;
+      bool boolean_value_;
+      ::uint32_t color_argb8_value_;
+      ::uint32_t color_rgb8_value_;
+      ::uint32_t color_argb4_value_;
+      ::uint32_t color_rgb4_value_;
+      float dimension_value_deprecated_;
+      float fraction_value_deprecated_;
+    } oneof_value_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+    ::uint32_t _oneof_case_[1];
+
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Attribute_Symbol final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Attribute.Symbol) */ {
+ public:
+  inline Attribute_Symbol() : Attribute_Symbol(nullptr) {}
+  ~Attribute_Symbol() override;
+  explicit PROTOBUF_CONSTEXPR Attribute_Symbol(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Attribute_Symbol(const Attribute_Symbol& from);
+  Attribute_Symbol(Attribute_Symbol&& from) noexcept
+    : Attribute_Symbol() {
+    *this = ::std::move(from);
+  }
+
+  inline Attribute_Symbol& operator=(const Attribute_Symbol& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Attribute_Symbol& operator=(Attribute_Symbol&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Attribute_Symbol& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Attribute_Symbol* internal_default_instance() {
+    return reinterpret_cast<const Attribute_Symbol*>(
+               &_Attribute_Symbol_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    31;
+
+  friend void swap(Attribute_Symbol& a, Attribute_Symbol& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Attribute_Symbol* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Attribute_Symbol* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Attribute_Symbol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Attribute_Symbol>(arena);
+  }
+  Attribute_Symbol* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Attribute_Symbol& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Attribute_Symbol& from) {
+    Attribute_Symbol::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Attribute_Symbol* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Attribute.Symbol";
+  }
+  protected:
+  explicit Attribute_Symbol(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kCommentFieldNumber = 2,
+    kSourceFieldNumber = 1,
+    kNameFieldNumber = 3,
+    kValueFieldNumber = 4,
+    kTypeFieldNumber = 5,
+  };
+  // string comment = 2;
+  void clear_comment();
+  const std::string& comment() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_comment(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_comment();
+  PROTOBUF_NODISCARD std::string* release_comment();
+  void set_allocated_comment(std::string* comment);
+  private:
+  const std::string& _internal_comment() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
+  std::string* _internal_mutable_comment();
+  public:
+
+  // .aapt.pb.Source source = 1;
+  bool has_source() const;
+  private:
+  bool _internal_has_source() const;
+  public:
+  void clear_source();
+  const ::aapt::pb::Source& source() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
+  ::aapt::pb::Source* mutable_source();
+  void set_allocated_source(::aapt::pb::Source* source);
+  private:
+  const ::aapt::pb::Source& _internal_source() const;
+  ::aapt::pb::Source* _internal_mutable_source();
+  public:
+  void unsafe_arena_set_allocated_source(
+      ::aapt::pb::Source* source);
+  ::aapt::pb::Source* unsafe_arena_release_source();
+
+  // .aapt.pb.Reference name = 3;
+  bool has_name() const;
+  private:
+  bool _internal_has_name() const;
+  public:
+  void clear_name();
+  const ::aapt::pb::Reference& name() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Reference* release_name();
+  ::aapt::pb::Reference* mutable_name();
+  void set_allocated_name(::aapt::pb::Reference* name);
+  private:
+  const ::aapt::pb::Reference& _internal_name() const;
+  ::aapt::pb::Reference* _internal_mutable_name();
+  public:
+  void unsafe_arena_set_allocated_name(
+      ::aapt::pb::Reference* name);
+  ::aapt::pb::Reference* unsafe_arena_release_name();
+
+  // uint32 value = 4;
+  void clear_value();
+  ::uint32_t value() const;
+  void set_value(::uint32_t value);
+  private:
+  ::uint32_t _internal_value() const;
+  void _internal_set_value(::uint32_t value);
+  public:
+
+  // uint32 type = 5;
+  void clear_type();
+  ::uint32_t type() const;
+  void set_type(::uint32_t value);
+  private:
+  ::uint32_t _internal_type() const;
+  void _internal_set_type(::uint32_t value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Attribute.Symbol)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
+    ::aapt::pb::Source* source_;
+    ::aapt::pb::Reference* name_;
+    ::uint32_t value_;
+    ::uint32_t type_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Attribute final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Attribute) */ {
+ public:
+  inline Attribute() : Attribute(nullptr) {}
+  ~Attribute() override;
+  explicit PROTOBUF_CONSTEXPR Attribute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Attribute(const Attribute& from);
+  Attribute(Attribute&& from) noexcept
+    : Attribute() {
+    *this = ::std::move(from);
+  }
+
+  inline Attribute& operator=(const Attribute& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Attribute& operator=(Attribute&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Attribute& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Attribute* internal_default_instance() {
+    return reinterpret_cast<const Attribute*>(
+               &_Attribute_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    32;
+
+  friend void swap(Attribute& a, Attribute& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Attribute* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Attribute* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Attribute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Attribute>(arena);
+  }
+  Attribute* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Attribute& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Attribute& from) {
+    Attribute::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Attribute* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Attribute";
+  }
+  protected:
+  explicit Attribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  typedef Attribute_Symbol Symbol;
+
+  typedef Attribute_FormatFlags FormatFlags;
+  static constexpr FormatFlags NONE =
+    Attribute_FormatFlags_NONE;
+  static constexpr FormatFlags ANY =
+    Attribute_FormatFlags_ANY;
+  static constexpr FormatFlags REFERENCE =
+    Attribute_FormatFlags_REFERENCE;
+  static constexpr FormatFlags STRING =
+    Attribute_FormatFlags_STRING;
+  static constexpr FormatFlags INTEGER =
+    Attribute_FormatFlags_INTEGER;
+  static constexpr FormatFlags BOOLEAN =
+    Attribute_FormatFlags_BOOLEAN;
+  static constexpr FormatFlags COLOR =
+    Attribute_FormatFlags_COLOR;
+  static constexpr FormatFlags FLOAT =
+    Attribute_FormatFlags_FLOAT;
+  static constexpr FormatFlags DIMENSION =
+    Attribute_FormatFlags_DIMENSION;
+  static constexpr FormatFlags FRACTION =
+    Attribute_FormatFlags_FRACTION;
+  static constexpr FormatFlags ENUM =
+    Attribute_FormatFlags_ENUM;
+  static constexpr FormatFlags FLAGS =
+    Attribute_FormatFlags_FLAGS;
+  static inline bool FormatFlags_IsValid(int value) {
+    return Attribute_FormatFlags_IsValid(value);
+  }
+  static constexpr FormatFlags FormatFlags_MIN =
+    Attribute_FormatFlags_FormatFlags_MIN;
+  static constexpr FormatFlags FormatFlags_MAX =
+    Attribute_FormatFlags_FormatFlags_MAX;
+  static constexpr int FormatFlags_ARRAYSIZE =
+    Attribute_FormatFlags_FormatFlags_ARRAYSIZE;
+  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
+  FormatFlags_descriptor() {
+    return Attribute_FormatFlags_descriptor();
+  }
+  template<typename T>
+  static inline const std::string& FormatFlags_Name(T enum_t_value) {
+    static_assert(::std::is_same<T, FormatFlags>::value ||
+      ::std::is_integral<T>::value,
+      "Incorrect type passed to function FormatFlags_Name.");
+    return Attribute_FormatFlags_Name(enum_t_value);
+  }
+  static inline bool FormatFlags_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
+      FormatFlags* value) {
+    return Attribute_FormatFlags_Parse(name, value);
+  }
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kSymbolFieldNumber = 4,
+    kFormatFlagsFieldNumber = 1,
+    kMinIntFieldNumber = 2,
+    kMaxIntFieldNumber = 3,
+  };
+  // repeated .aapt.pb.Attribute.Symbol symbol = 4;
+  int symbol_size() const;
+  private:
+  int _internal_symbol_size() const;
+  public:
+  void clear_symbol();
+  ::aapt::pb::Attribute_Symbol* mutable_symbol(int index);
+  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Attribute_Symbol >*
+      mutable_symbol();
+  private:
+  const ::aapt::pb::Attribute_Symbol& _internal_symbol(int index) const;
+  ::aapt::pb::Attribute_Symbol* _internal_add_symbol();
+  public:
+  const ::aapt::pb::Attribute_Symbol& symbol(int index) const;
+  ::aapt::pb::Attribute_Symbol* add_symbol();
+  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Attribute_Symbol >&
+      symbol() const;
+
+  // uint32 format_flags = 1;
+  void clear_format_flags();
+  ::uint32_t format_flags() const;
+  void set_format_flags(::uint32_t value);
+  private:
+  ::uint32_t _internal_format_flags() const;
+  void _internal_set_format_flags(::uint32_t value);
+  public:
+
+  // int32 min_int = 2;
+  void clear_min_int();
+  ::int32_t min_int() const;
+  void set_min_int(::int32_t value);
+  private:
+  ::int32_t _internal_min_int() const;
+  void _internal_set_min_int(::int32_t value);
+  public:
+
+  // int32 max_int = 3;
+  void clear_max_int();
+  ::int32_t max_int() const;
+  void set_max_int(::int32_t value);
+  private:
+  ::int32_t _internal_max_int() const;
+  void _internal_set_max_int(::int32_t value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Attribute)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Attribute_Symbol > symbol_;
+    ::uint32_t format_flags_;
+    ::int32_t min_int_;
+    ::int32_t max_int_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Style_Entry final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Style.Entry) */ {
+ public:
+  inline Style_Entry() : Style_Entry(nullptr) {}
+  ~Style_Entry() override;
+  explicit PROTOBUF_CONSTEXPR Style_Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Style_Entry(const Style_Entry& from);
+  Style_Entry(Style_Entry&& from) noexcept
+    : Style_Entry() {
+    *this = ::std::move(from);
+  }
+
+  inline Style_Entry& operator=(const Style_Entry& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Style_Entry& operator=(Style_Entry&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Style_Entry& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Style_Entry* internal_default_instance() {
+    return reinterpret_cast<const Style_Entry*>(
+               &_Style_Entry_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    33;
+
+  friend void swap(Style_Entry& a, Style_Entry& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Style_Entry* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Style_Entry* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Style_Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Style_Entry>(arena);
+  }
+  Style_Entry* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Style_Entry& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Style_Entry& from) {
+    Style_Entry::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Style_Entry* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Style.Entry";
+  }
+  protected:
+  explicit Style_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kCommentFieldNumber = 2,
+    kSourceFieldNumber = 1,
+    kKeyFieldNumber = 3,
+    kItemFieldNumber = 4,
+  };
+  // string comment = 2;
+  void clear_comment();
+  const std::string& comment() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_comment(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_comment();
+  PROTOBUF_NODISCARD std::string* release_comment();
+  void set_allocated_comment(std::string* comment);
+  private:
+  const std::string& _internal_comment() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
+  std::string* _internal_mutable_comment();
+  public:
+
+  // .aapt.pb.Source source = 1;
+  bool has_source() const;
+  private:
+  bool _internal_has_source() const;
+  public:
+  void clear_source();
+  const ::aapt::pb::Source& source() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
+  ::aapt::pb::Source* mutable_source();
+  void set_allocated_source(::aapt::pb::Source* source);
+  private:
+  const ::aapt::pb::Source& _internal_source() const;
+  ::aapt::pb::Source* _internal_mutable_source();
+  public:
+  void unsafe_arena_set_allocated_source(
+      ::aapt::pb::Source* source);
+  ::aapt::pb::Source* unsafe_arena_release_source();
+
+  // .aapt.pb.Reference key = 3;
+  bool has_key() const;
+  private:
+  bool _internal_has_key() const;
+  public:
+  void clear_key();
+  const ::aapt::pb::Reference& key() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Reference* release_key();
+  ::aapt::pb::Reference* mutable_key();
+  void set_allocated_key(::aapt::pb::Reference* key);
+  private:
+  const ::aapt::pb::Reference& _internal_key() const;
+  ::aapt::pb::Reference* _internal_mutable_key();
+  public:
+  void unsafe_arena_set_allocated_key(
+      ::aapt::pb::Reference* key);
+  ::aapt::pb::Reference* unsafe_arena_release_key();
+
+  // .aapt.pb.Item item = 4;
+  bool has_item() const;
+  private:
+  bool _internal_has_item() const;
+  public:
+  void clear_item();
+  const ::aapt::pb::Item& item() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Item* release_item();
+  ::aapt::pb::Item* mutable_item();
+  void set_allocated_item(::aapt::pb::Item* item);
+  private:
+  const ::aapt::pb::Item& _internal_item() const;
+  ::aapt::pb::Item* _internal_mutable_item();
+  public:
+  void unsafe_arena_set_allocated_item(
+      ::aapt::pb::Item* item);
+  ::aapt::pb::Item* unsafe_arena_release_item();
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Style.Entry)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
+    ::aapt::pb::Source* source_;
+    ::aapt::pb::Reference* key_;
+    ::aapt::pb::Item* item_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Style final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Style) */ {
+ public:
+  inline Style() : Style(nullptr) {}
+  ~Style() override;
+  explicit PROTOBUF_CONSTEXPR Style(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Style(const Style& from);
+  Style(Style&& from) noexcept
+    : Style() {
+    *this = ::std::move(from);
+  }
+
+  inline Style& operator=(const Style& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Style& operator=(Style&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Style& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Style* internal_default_instance() {
+    return reinterpret_cast<const Style*>(
+               &_Style_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    34;
+
+  friend void swap(Style& a, Style& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Style* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Style* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Style* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Style>(arena);
+  }
+  Style* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Style& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Style& from) {
+    Style::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Style* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Style";
+  }
+  protected:
+  explicit Style(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  typedef Style_Entry Entry;
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kEntryFieldNumber = 3,
+    kParentFieldNumber = 1,
+    kParentSourceFieldNumber = 2,
+  };
+  // repeated .aapt.pb.Style.Entry entry = 3;
+  int entry_size() const;
+  private:
+  int _internal_entry_size() const;
+  public:
+  void clear_entry();
+  ::aapt::pb::Style_Entry* mutable_entry(int index);
+  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Style_Entry >*
+      mutable_entry();
+  private:
+  const ::aapt::pb::Style_Entry& _internal_entry(int index) const;
+  ::aapt::pb::Style_Entry* _internal_add_entry();
+  public:
+  const ::aapt::pb::Style_Entry& entry(int index) const;
+  ::aapt::pb::Style_Entry* add_entry();
+  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Style_Entry >&
+      entry() const;
+
+  // .aapt.pb.Reference parent = 1;
+  bool has_parent() const;
+  private:
+  bool _internal_has_parent() const;
+  public:
+  void clear_parent();
+  const ::aapt::pb::Reference& parent() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Reference* release_parent();
+  ::aapt::pb::Reference* mutable_parent();
+  void set_allocated_parent(::aapt::pb::Reference* parent);
+  private:
+  const ::aapt::pb::Reference& _internal_parent() const;
+  ::aapt::pb::Reference* _internal_mutable_parent();
+  public:
+  void unsafe_arena_set_allocated_parent(
+      ::aapt::pb::Reference* parent);
+  ::aapt::pb::Reference* unsafe_arena_release_parent();
+
+  // .aapt.pb.Source parent_source = 2;
+  bool has_parent_source() const;
+  private:
+  bool _internal_has_parent_source() const;
+  public:
+  void clear_parent_source();
+  const ::aapt::pb::Source& parent_source() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Source* release_parent_source();
+  ::aapt::pb::Source* mutable_parent_source();
+  void set_allocated_parent_source(::aapt::pb::Source* parent_source);
+  private:
+  const ::aapt::pb::Source& _internal_parent_source() const;
+  ::aapt::pb::Source* _internal_mutable_parent_source();
+  public:
+  void unsafe_arena_set_allocated_parent_source(
+      ::aapt::pb::Source* parent_source);
+  ::aapt::pb::Source* unsafe_arena_release_parent_source();
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Style)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Style_Entry > entry_;
+    ::aapt::pb::Reference* parent_;
+    ::aapt::pb::Source* parent_source_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Styleable_Entry final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Styleable.Entry) */ {
+ public:
+  inline Styleable_Entry() : Styleable_Entry(nullptr) {}
+  ~Styleable_Entry() override;
+  explicit PROTOBUF_CONSTEXPR Styleable_Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Styleable_Entry(const Styleable_Entry& from);
+  Styleable_Entry(Styleable_Entry&& from) noexcept
+    : Styleable_Entry() {
+    *this = ::std::move(from);
+  }
+
+  inline Styleable_Entry& operator=(const Styleable_Entry& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Styleable_Entry& operator=(Styleable_Entry&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Styleable_Entry& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Styleable_Entry* internal_default_instance() {
+    return reinterpret_cast<const Styleable_Entry*>(
+               &_Styleable_Entry_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    35;
+
+  friend void swap(Styleable_Entry& a, Styleable_Entry& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Styleable_Entry* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Styleable_Entry* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Styleable_Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Styleable_Entry>(arena);
+  }
+  Styleable_Entry* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Styleable_Entry& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Styleable_Entry& from) {
+    Styleable_Entry::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Styleable_Entry* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Styleable.Entry";
+  }
+  protected:
+  explicit Styleable_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kCommentFieldNumber = 2,
+    kSourceFieldNumber = 1,
+    kAttrFieldNumber = 3,
+  };
+  // string comment = 2;
+  void clear_comment();
+  const std::string& comment() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_comment(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_comment();
+  PROTOBUF_NODISCARD std::string* release_comment();
+  void set_allocated_comment(std::string* comment);
+  private:
+  const std::string& _internal_comment() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
+  std::string* _internal_mutable_comment();
+  public:
+
+  // .aapt.pb.Source source = 1;
+  bool has_source() const;
+  private:
+  bool _internal_has_source() const;
+  public:
+  void clear_source();
+  const ::aapt::pb::Source& source() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
+  ::aapt::pb::Source* mutable_source();
+  void set_allocated_source(::aapt::pb::Source* source);
+  private:
+  const ::aapt::pb::Source& _internal_source() const;
+  ::aapt::pb::Source* _internal_mutable_source();
+  public:
+  void unsafe_arena_set_allocated_source(
+      ::aapt::pb::Source* source);
+  ::aapt::pb::Source* unsafe_arena_release_source();
+
+  // .aapt.pb.Reference attr = 3;
+  bool has_attr() const;
+  private:
+  bool _internal_has_attr() const;
+  public:
+  void clear_attr();
+  const ::aapt::pb::Reference& attr() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Reference* release_attr();
+  ::aapt::pb::Reference* mutable_attr();
+  void set_allocated_attr(::aapt::pb::Reference* attr);
+  private:
+  const ::aapt::pb::Reference& _internal_attr() const;
+  ::aapt::pb::Reference* _internal_mutable_attr();
+  public:
+  void unsafe_arena_set_allocated_attr(
+      ::aapt::pb::Reference* attr);
+  ::aapt::pb::Reference* unsafe_arena_release_attr();
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Styleable.Entry)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
+    ::aapt::pb::Source* source_;
+    ::aapt::pb::Reference* attr_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Styleable final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Styleable) */ {
+ public:
+  inline Styleable() : Styleable(nullptr) {}
+  ~Styleable() override;
+  explicit PROTOBUF_CONSTEXPR Styleable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Styleable(const Styleable& from);
+  Styleable(Styleable&& from) noexcept
+    : Styleable() {
+    *this = ::std::move(from);
+  }
+
+  inline Styleable& operator=(const Styleable& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Styleable& operator=(Styleable&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Styleable& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Styleable* internal_default_instance() {
+    return reinterpret_cast<const Styleable*>(
+               &_Styleable_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    36;
+
+  friend void swap(Styleable& a, Styleable& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Styleable* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Styleable* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Styleable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Styleable>(arena);
+  }
+  Styleable* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Styleable& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Styleable& from) {
+    Styleable::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Styleable* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Styleable";
+  }
+  protected:
+  explicit Styleable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  typedef Styleable_Entry Entry;
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kEntryFieldNumber = 1,
+  };
+  // repeated .aapt.pb.Styleable.Entry entry = 1;
+  int entry_size() const;
+  private:
+  int _internal_entry_size() const;
+  public:
+  void clear_entry();
+  ::aapt::pb::Styleable_Entry* mutable_entry(int index);
+  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Styleable_Entry >*
+      mutable_entry();
+  private:
+  const ::aapt::pb::Styleable_Entry& _internal_entry(int index) const;
+  ::aapt::pb::Styleable_Entry* _internal_add_entry();
+  public:
+  const ::aapt::pb::Styleable_Entry& entry(int index) const;
+  ::aapt::pb::Styleable_Entry* add_entry();
+  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Styleable_Entry >&
+      entry() const;
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Styleable)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Styleable_Entry > entry_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Array_Element final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Array.Element) */ {
+ public:
+  inline Array_Element() : Array_Element(nullptr) {}
+  ~Array_Element() override;
+  explicit PROTOBUF_CONSTEXPR Array_Element(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Array_Element(const Array_Element& from);
+  Array_Element(Array_Element&& from) noexcept
+    : Array_Element() {
+    *this = ::std::move(from);
+  }
+
+  inline Array_Element& operator=(const Array_Element& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Array_Element& operator=(Array_Element&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Array_Element& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Array_Element* internal_default_instance() {
+    return reinterpret_cast<const Array_Element*>(
+               &_Array_Element_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    37;
+
+  friend void swap(Array_Element& a, Array_Element& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Array_Element* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Array_Element* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Array_Element* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Array_Element>(arena);
+  }
+  Array_Element* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Array_Element& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Array_Element& from) {
+    Array_Element::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Array_Element* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Array.Element";
+  }
+  protected:
+  explicit Array_Element(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kCommentFieldNumber = 2,
+    kSourceFieldNumber = 1,
+    kItemFieldNumber = 3,
+  };
+  // string comment = 2;
+  void clear_comment();
+  const std::string& comment() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_comment(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_comment();
+  PROTOBUF_NODISCARD std::string* release_comment();
+  void set_allocated_comment(std::string* comment);
+  private:
+  const std::string& _internal_comment() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
+  std::string* _internal_mutable_comment();
+  public:
+
+  // .aapt.pb.Source source = 1;
+  bool has_source() const;
+  private:
+  bool _internal_has_source() const;
+  public:
+  void clear_source();
+  const ::aapt::pb::Source& source() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
+  ::aapt::pb::Source* mutable_source();
+  void set_allocated_source(::aapt::pb::Source* source);
+  private:
+  const ::aapt::pb::Source& _internal_source() const;
+  ::aapt::pb::Source* _internal_mutable_source();
+  public:
+  void unsafe_arena_set_allocated_source(
+      ::aapt::pb::Source* source);
+  ::aapt::pb::Source* unsafe_arena_release_source();
+
+  // .aapt.pb.Item item = 3;
+  bool has_item() const;
+  private:
+  bool _internal_has_item() const;
+  public:
+  void clear_item();
+  const ::aapt::pb::Item& item() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Item* release_item();
+  ::aapt::pb::Item* mutable_item();
+  void set_allocated_item(::aapt::pb::Item* item);
+  private:
+  const ::aapt::pb::Item& _internal_item() const;
+  ::aapt::pb::Item* _internal_mutable_item();
+  public:
+  void unsafe_arena_set_allocated_item(
+      ::aapt::pb::Item* item);
+  ::aapt::pb::Item* unsafe_arena_release_item();
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Array.Element)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
+    ::aapt::pb::Source* source_;
+    ::aapt::pb::Item* item_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Array final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Array) */ {
+ public:
+  inline Array() : Array(nullptr) {}
+  ~Array() override;
+  explicit PROTOBUF_CONSTEXPR Array(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Array(const Array& from);
+  Array(Array&& from) noexcept
+    : Array() {
+    *this = ::std::move(from);
+  }
+
+  inline Array& operator=(const Array& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Array& operator=(Array&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Array& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Array* internal_default_instance() {
+    return reinterpret_cast<const Array*>(
+               &_Array_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    38;
+
+  friend void swap(Array& a, Array& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Array* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Array* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Array* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Array>(arena);
+  }
+  Array* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Array& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Array& from) {
+    Array::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Array* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Array";
+  }
+  protected:
+  explicit Array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  typedef Array_Element Element;
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kElementFieldNumber = 1,
+  };
+  // repeated .aapt.pb.Array.Element element = 1;
+  int element_size() const;
+  private:
+  int _internal_element_size() const;
+  public:
+  void clear_element();
+  ::aapt::pb::Array_Element* mutable_element(int index);
+  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Array_Element >*
+      mutable_element();
+  private:
+  const ::aapt::pb::Array_Element& _internal_element(int index) const;
+  ::aapt::pb::Array_Element* _internal_add_element();
+  public:
+  const ::aapt::pb::Array_Element& element(int index) const;
+  ::aapt::pb::Array_Element* add_element();
+  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Array_Element >&
+      element() const;
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Array)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Array_Element > element_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Plural_Entry final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Plural.Entry) */ {
+ public:
+  inline Plural_Entry() : Plural_Entry(nullptr) {}
+  ~Plural_Entry() override;
+  explicit PROTOBUF_CONSTEXPR Plural_Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Plural_Entry(const Plural_Entry& from);
+  Plural_Entry(Plural_Entry&& from) noexcept
+    : Plural_Entry() {
+    *this = ::std::move(from);
+  }
+
+  inline Plural_Entry& operator=(const Plural_Entry& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Plural_Entry& operator=(Plural_Entry&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Plural_Entry& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Plural_Entry* internal_default_instance() {
+    return reinterpret_cast<const Plural_Entry*>(
+               &_Plural_Entry_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    39;
+
+  friend void swap(Plural_Entry& a, Plural_Entry& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Plural_Entry* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Plural_Entry* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Plural_Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Plural_Entry>(arena);
+  }
+  Plural_Entry* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Plural_Entry& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Plural_Entry& from) {
+    Plural_Entry::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Plural_Entry* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Plural.Entry";
+  }
+  protected:
+  explicit Plural_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kCommentFieldNumber = 2,
+    kSourceFieldNumber = 1,
+    kItemFieldNumber = 4,
+    kArityFieldNumber = 3,
+  };
+  // string comment = 2;
+  void clear_comment();
+  const std::string& comment() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_comment(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_comment();
+  PROTOBUF_NODISCARD std::string* release_comment();
+  void set_allocated_comment(std::string* comment);
+  private:
+  const std::string& _internal_comment() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
+  std::string* _internal_mutable_comment();
+  public:
+
+  // .aapt.pb.Source source = 1;
+  bool has_source() const;
+  private:
+  bool _internal_has_source() const;
+  public:
+  void clear_source();
+  const ::aapt::pb::Source& source() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Source* release_source();
+  ::aapt::pb::Source* mutable_source();
+  void set_allocated_source(::aapt::pb::Source* source);
+  private:
+  const ::aapt::pb::Source& _internal_source() const;
+  ::aapt::pb::Source* _internal_mutable_source();
+  public:
+  void unsafe_arena_set_allocated_source(
+      ::aapt::pb::Source* source);
+  ::aapt::pb::Source* unsafe_arena_release_source();
+
+  // .aapt.pb.Item item = 4;
+  bool has_item() const;
+  private:
+  bool _internal_has_item() const;
+  public:
+  void clear_item();
+  const ::aapt::pb::Item& item() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Item* release_item();
+  ::aapt::pb::Item* mutable_item();
+  void set_allocated_item(::aapt::pb::Item* item);
+  private:
+  const ::aapt::pb::Item& _internal_item() const;
+  ::aapt::pb::Item* _internal_mutable_item();
+  public:
+  void unsafe_arena_set_allocated_item(
+      ::aapt::pb::Item* item);
+  ::aapt::pb::Item* unsafe_arena_release_item();
+
+  // .aapt.pb.Plural.Arity arity = 3;
+  void clear_arity();
+  ::aapt::pb::Plural_Arity arity() const;
+  void set_arity(::aapt::pb::Plural_Arity value);
+  private:
+  ::aapt::pb::Plural_Arity _internal_arity() const;
+  void _internal_set_arity(::aapt::pb::Plural_Arity value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Plural.Entry)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
+    ::aapt::pb::Source* source_;
+    ::aapt::pb::Item* item_;
+    int arity_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class Plural final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.Plural) */ {
+ public:
+  inline Plural() : Plural(nullptr) {}
+  ~Plural() override;
+  explicit PROTOBUF_CONSTEXPR Plural(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  Plural(const Plural& from);
+  Plural(Plural&& from) noexcept
+    : Plural() {
+    *this = ::std::move(from);
+  }
+
+  inline Plural& operator=(const Plural& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline Plural& operator=(Plural&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const Plural& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const Plural* internal_default_instance() {
+    return reinterpret_cast<const Plural*>(
+               &_Plural_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    40;
+
+  friend void swap(Plural& a, Plural& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(Plural* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(Plural* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  Plural* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<Plural>(arena);
+  }
+  Plural* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const Plural& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const Plural& from) {
+    Plural::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(Plural* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.Plural";
+  }
+  protected:
+  explicit Plural(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  typedef Plural_Entry Entry;
+
+  typedef Plural_Arity Arity;
+  static constexpr Arity ZERO =
+    Plural_Arity_ZERO;
+  static constexpr Arity ONE =
+    Plural_Arity_ONE;
+  static constexpr Arity TWO =
+    Plural_Arity_TWO;
+  static constexpr Arity FEW =
+    Plural_Arity_FEW;
+  static constexpr Arity MANY =
+    Plural_Arity_MANY;
+  static constexpr Arity OTHER =
+    Plural_Arity_OTHER;
+  static inline bool Arity_IsValid(int value) {
+    return Plural_Arity_IsValid(value);
+  }
+  static constexpr Arity Arity_MIN =
+    Plural_Arity_Arity_MIN;
+  static constexpr Arity Arity_MAX =
+    Plural_Arity_Arity_MAX;
+  static constexpr int Arity_ARRAYSIZE =
+    Plural_Arity_Arity_ARRAYSIZE;
+  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
+  Arity_descriptor() {
+    return Plural_Arity_descriptor();
+  }
+  template<typename T>
+  static inline const std::string& Arity_Name(T enum_t_value) {
+    static_assert(::std::is_same<T, Arity>::value ||
+      ::std::is_integral<T>::value,
+      "Incorrect type passed to function Arity_Name.");
+    return Plural_Arity_Name(enum_t_value);
+  }
+  static inline bool Arity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
+      Arity* value) {
+    return Plural_Arity_Parse(name, value);
+  }
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kEntryFieldNumber = 1,
+  };
+  // repeated .aapt.pb.Plural.Entry entry = 1;
+  int entry_size() const;
+  private:
+  int _internal_entry_size() const;
+  public:
+  void clear_entry();
+  ::aapt::pb::Plural_Entry* mutable_entry(int index);
+  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Plural_Entry >*
+      mutable_entry();
+  private:
+  const ::aapt::pb::Plural_Entry& _internal_entry(int index) const;
+  ::aapt::pb::Plural_Entry* _internal_add_entry();
+  public:
+  const ::aapt::pb::Plural_Entry& entry(int index) const;
+  ::aapt::pb::Plural_Entry* add_entry();
+  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Plural_Entry >&
+      entry() const;
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.Plural)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Plural_Entry > entry_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class XmlNode final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.XmlNode) */ {
+ public:
+  inline XmlNode() : XmlNode(nullptr) {}
+  ~XmlNode() override;
+  explicit PROTOBUF_CONSTEXPR XmlNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  XmlNode(const XmlNode& from);
+  XmlNode(XmlNode&& from) noexcept
+    : XmlNode() {
+    *this = ::std::move(from);
+  }
+
+  inline XmlNode& operator=(const XmlNode& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline XmlNode& operator=(XmlNode&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const XmlNode& default_instance() {
+    return *internal_default_instance();
+  }
+  enum NodeCase {
+    kElement = 1,
+    kText = 2,
+    NODE_NOT_SET = 0,
+  };
+
+  static inline const XmlNode* internal_default_instance() {
+    return reinterpret_cast<const XmlNode*>(
+               &_XmlNode_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    41;
+
+  friend void swap(XmlNode& a, XmlNode& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(XmlNode* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(XmlNode* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  XmlNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<XmlNode>(arena);
+  }
+  XmlNode* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const XmlNode& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const XmlNode& from) {
+    XmlNode::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(XmlNode* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.XmlNode";
+  }
+  protected:
+  explicit XmlNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kSourceFieldNumber = 3,
+    kElementFieldNumber = 1,
+    kTextFieldNumber = 2,
+  };
+  // .aapt.pb.SourcePosition source = 3;
+  bool has_source() const;
+  private:
+  bool _internal_has_source() const;
+  public:
+  void clear_source();
+  const ::aapt::pb::SourcePosition& source() const;
+  PROTOBUF_NODISCARD ::aapt::pb::SourcePosition* release_source();
+  ::aapt::pb::SourcePosition* mutable_source();
+  void set_allocated_source(::aapt::pb::SourcePosition* source);
+  private:
+  const ::aapt::pb::SourcePosition& _internal_source() const;
+  ::aapt::pb::SourcePosition* _internal_mutable_source();
+  public:
+  void unsafe_arena_set_allocated_source(
+      ::aapt::pb::SourcePosition* source);
+  ::aapt::pb::SourcePosition* unsafe_arena_release_source();
+
+  // .aapt.pb.XmlElement element = 1;
+  bool has_element() const;
+  private:
+  bool _internal_has_element() const;
+  public:
+  void clear_element();
+  const ::aapt::pb::XmlElement& element() const;
+  PROTOBUF_NODISCARD ::aapt::pb::XmlElement* release_element();
+  ::aapt::pb::XmlElement* mutable_element();
+  void set_allocated_element(::aapt::pb::XmlElement* element);
+  private:
+  const ::aapt::pb::XmlElement& _internal_element() const;
+  ::aapt::pb::XmlElement* _internal_mutable_element();
+  public:
+  void unsafe_arena_set_allocated_element(
+      ::aapt::pb::XmlElement* element);
+  ::aapt::pb::XmlElement* unsafe_arena_release_element();
+
+  // string text = 2;
+  bool has_text() const;
+  private:
+  bool _internal_has_text() const;
+  public:
+  void clear_text();
+  const std::string& text() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_text(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_text();
+  PROTOBUF_NODISCARD std::string* release_text();
+  void set_allocated_text(std::string* text);
+  private:
+  const std::string& _internal_text() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
+  std::string* _internal_mutable_text();
+  public:
+
+  void clear_node();
+  NodeCase node_case() const;
+  // @@protoc_insertion_point(class_scope:aapt.pb.XmlNode)
+ private:
+  class _Internal;
+  void set_has_element();
+  void set_has_text();
+
+  inline bool has_node() const;
+  inline void clear_has_node();
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::aapt::pb::SourcePosition* source_;
+    union NodeUnion {
+      constexpr NodeUnion() : _constinit_{} {}
+        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
+      ::aapt::pb::XmlElement* element_;
+      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
+    } node_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+    ::uint32_t _oneof_case_[1];
+
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class XmlElement final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.XmlElement) */ {
+ public:
+  inline XmlElement() : XmlElement(nullptr) {}
+  ~XmlElement() override;
+  explicit PROTOBUF_CONSTEXPR XmlElement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  XmlElement(const XmlElement& from);
+  XmlElement(XmlElement&& from) noexcept
+    : XmlElement() {
+    *this = ::std::move(from);
+  }
+
+  inline XmlElement& operator=(const XmlElement& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline XmlElement& operator=(XmlElement&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const XmlElement& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const XmlElement* internal_default_instance() {
+    return reinterpret_cast<const XmlElement*>(
+               &_XmlElement_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    42;
+
+  friend void swap(XmlElement& a, XmlElement& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(XmlElement* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(XmlElement* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  XmlElement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<XmlElement>(arena);
+  }
+  XmlElement* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const XmlElement& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const XmlElement& from) {
+    XmlElement::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(XmlElement* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.XmlElement";
+  }
+  protected:
+  explicit XmlElement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kNamespaceDeclarationFieldNumber = 1,
+    kAttributeFieldNumber = 4,
+    kChildFieldNumber = 5,
+    kNamespaceUriFieldNumber = 2,
+    kNameFieldNumber = 3,
+  };
+  // repeated .aapt.pb.XmlNamespace namespace_declaration = 1;
+  int namespace_declaration_size() const;
+  private:
+  int _internal_namespace_declaration_size() const;
+  public:
+  void clear_namespace_declaration();
+  ::aapt::pb::XmlNamespace* mutable_namespace_declaration(int index);
+  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlNamespace >*
+      mutable_namespace_declaration();
+  private:
+  const ::aapt::pb::XmlNamespace& _internal_namespace_declaration(int index) const;
+  ::aapt::pb::XmlNamespace* _internal_add_namespace_declaration();
+  public:
+  const ::aapt::pb::XmlNamespace& namespace_declaration(int index) const;
+  ::aapt::pb::XmlNamespace* add_namespace_declaration();
+  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlNamespace >&
+      namespace_declaration() const;
+
+  // repeated .aapt.pb.XmlAttribute attribute = 4;
+  int attribute_size() const;
+  private:
+  int _internal_attribute_size() const;
+  public:
+  void clear_attribute();
+  ::aapt::pb::XmlAttribute* mutable_attribute(int index);
+  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlAttribute >*
+      mutable_attribute();
+  private:
+  const ::aapt::pb::XmlAttribute& _internal_attribute(int index) const;
+  ::aapt::pb::XmlAttribute* _internal_add_attribute();
+  public:
+  const ::aapt::pb::XmlAttribute& attribute(int index) const;
+  ::aapt::pb::XmlAttribute* add_attribute();
+  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlAttribute >&
+      attribute() const;
+
+  // repeated .aapt.pb.XmlNode child = 5;
+  int child_size() const;
+  private:
+  int _internal_child_size() const;
+  public:
+  void clear_child();
+  ::aapt::pb::XmlNode* mutable_child(int index);
+  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlNode >*
+      mutable_child();
+  private:
+  const ::aapt::pb::XmlNode& _internal_child(int index) const;
+  ::aapt::pb::XmlNode* _internal_add_child();
+  public:
+  const ::aapt::pb::XmlNode& child(int index) const;
+  ::aapt::pb::XmlNode* add_child();
+  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlNode >&
+      child() const;
+
+  // string namespace_uri = 2;
+  void clear_namespace_uri();
+  const std::string& namespace_uri() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_namespace_uri(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_namespace_uri();
+  PROTOBUF_NODISCARD std::string* release_namespace_uri();
+  void set_allocated_namespace_uri(std::string* namespace_uri);
+  private:
+  const std::string& _internal_namespace_uri() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_uri(const std::string& value);
+  std::string* _internal_mutable_namespace_uri();
+  public:
+
+  // string name = 3;
+  void clear_name();
+  const std::string& name() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_name(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_name();
+  PROTOBUF_NODISCARD std::string* release_name();
+  void set_allocated_name(std::string* name);
+  private:
+  const std::string& _internal_name() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
+  std::string* _internal_mutable_name();
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.XmlElement)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlNamespace > namespace_declaration_;
+    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlAttribute > attribute_;
+    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlNode > child_;
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_uri_;
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class XmlNamespace final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.XmlNamespace) */ {
+ public:
+  inline XmlNamespace() : XmlNamespace(nullptr) {}
+  ~XmlNamespace() override;
+  explicit PROTOBUF_CONSTEXPR XmlNamespace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  XmlNamespace(const XmlNamespace& from);
+  XmlNamespace(XmlNamespace&& from) noexcept
+    : XmlNamespace() {
+    *this = ::std::move(from);
+  }
+
+  inline XmlNamespace& operator=(const XmlNamespace& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline XmlNamespace& operator=(XmlNamespace&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const XmlNamespace& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const XmlNamespace* internal_default_instance() {
+    return reinterpret_cast<const XmlNamespace*>(
+               &_XmlNamespace_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    43;
+
+  friend void swap(XmlNamespace& a, XmlNamespace& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(XmlNamespace* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(XmlNamespace* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  XmlNamespace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<XmlNamespace>(arena);
+  }
+  XmlNamespace* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const XmlNamespace& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const XmlNamespace& from) {
+    XmlNamespace::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(XmlNamespace* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.XmlNamespace";
+  }
+  protected:
+  explicit XmlNamespace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kPrefixFieldNumber = 1,
+    kUriFieldNumber = 2,
+    kSourceFieldNumber = 3,
+  };
+  // string prefix = 1;
+  void clear_prefix();
+  const std::string& prefix() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_prefix(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_prefix();
+  PROTOBUF_NODISCARD std::string* release_prefix();
+  void set_allocated_prefix(std::string* prefix);
+  private:
+  const std::string& _internal_prefix() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(const std::string& value);
+  std::string* _internal_mutable_prefix();
+  public:
+
+  // string uri = 2;
+  void clear_uri();
+  const std::string& uri() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_uri(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_uri();
+  PROTOBUF_NODISCARD std::string* release_uri();
+  void set_allocated_uri(std::string* uri);
+  private:
+  const std::string& _internal_uri() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
+  std::string* _internal_mutable_uri();
+  public:
+
+  // .aapt.pb.SourcePosition source = 3;
+  bool has_source() const;
+  private:
+  bool _internal_has_source() const;
+  public:
+  void clear_source();
+  const ::aapt::pb::SourcePosition& source() const;
+  PROTOBUF_NODISCARD ::aapt::pb::SourcePosition* release_source();
+  ::aapt::pb::SourcePosition* mutable_source();
+  void set_allocated_source(::aapt::pb::SourcePosition* source);
+  private:
+  const ::aapt::pb::SourcePosition& _internal_source() const;
+  ::aapt::pb::SourcePosition* _internal_mutable_source();
+  public:
+  void unsafe_arena_set_allocated_source(
+      ::aapt::pb::SourcePosition* source);
+  ::aapt::pb::SourcePosition* unsafe_arena_release_source();
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.XmlNamespace)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
+    ::aapt::pb::SourcePosition* source_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class XmlAttribute final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.XmlAttribute) */ {
+ public:
+  inline XmlAttribute() : XmlAttribute(nullptr) {}
+  ~XmlAttribute() override;
+  explicit PROTOBUF_CONSTEXPR XmlAttribute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  XmlAttribute(const XmlAttribute& from);
+  XmlAttribute(XmlAttribute&& from) noexcept
+    : XmlAttribute() {
+    *this = ::std::move(from);
+  }
+
+  inline XmlAttribute& operator=(const XmlAttribute& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline XmlAttribute& operator=(XmlAttribute&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const XmlAttribute& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const XmlAttribute* internal_default_instance() {
+    return reinterpret_cast<const XmlAttribute*>(
+               &_XmlAttribute_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    44;
+
+  friend void swap(XmlAttribute& a, XmlAttribute& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(XmlAttribute* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(XmlAttribute* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  XmlAttribute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<XmlAttribute>(arena);
+  }
+  XmlAttribute* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const XmlAttribute& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const XmlAttribute& from) {
+    XmlAttribute::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(XmlAttribute* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.XmlAttribute";
+  }
+  protected:
+  explicit XmlAttribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kNamespaceUriFieldNumber = 1,
+    kNameFieldNumber = 2,
+    kValueFieldNumber = 3,
+    kSourceFieldNumber = 4,
+    kCompiledItemFieldNumber = 6,
+    kResourceIdFieldNumber = 5,
+  };
+  // string namespace_uri = 1;
+  void clear_namespace_uri();
+  const std::string& namespace_uri() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_namespace_uri(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_namespace_uri();
+  PROTOBUF_NODISCARD std::string* release_namespace_uri();
+  void set_allocated_namespace_uri(std::string* namespace_uri);
+  private:
+  const std::string& _internal_namespace_uri() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_uri(const std::string& value);
+  std::string* _internal_mutable_namespace_uri();
+  public:
+
+  // string name = 2;
+  void clear_name();
+  const std::string& name() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_name(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_name();
+  PROTOBUF_NODISCARD std::string* release_name();
+  void set_allocated_name(std::string* name);
+  private:
+  const std::string& _internal_name() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
+  std::string* _internal_mutable_name();
+  public:
+
+  // string value = 3;
+  void clear_value();
+  const std::string& value() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_value(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_value();
+  PROTOBUF_NODISCARD std::string* release_value();
+  void set_allocated_value(std::string* value);
+  private:
+  const std::string& _internal_value() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
+  std::string* _internal_mutable_value();
+  public:
+
+  // .aapt.pb.SourcePosition source = 4;
+  bool has_source() const;
+  private:
+  bool _internal_has_source() const;
+  public:
+  void clear_source();
+  const ::aapt::pb::SourcePosition& source() const;
+  PROTOBUF_NODISCARD ::aapt::pb::SourcePosition* release_source();
+  ::aapt::pb::SourcePosition* mutable_source();
+  void set_allocated_source(::aapt::pb::SourcePosition* source);
+  private:
+  const ::aapt::pb::SourcePosition& _internal_source() const;
+  ::aapt::pb::SourcePosition* _internal_mutable_source();
+  public:
+  void unsafe_arena_set_allocated_source(
+      ::aapt::pb::SourcePosition* source);
+  ::aapt::pb::SourcePosition* unsafe_arena_release_source();
+
+  // .aapt.pb.Item compiled_item = 6;
+  bool has_compiled_item() const;
+  private:
+  bool _internal_has_compiled_item() const;
+  public:
+  void clear_compiled_item();
+  const ::aapt::pb::Item& compiled_item() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Item* release_compiled_item();
+  ::aapt::pb::Item* mutable_compiled_item();
+  void set_allocated_compiled_item(::aapt::pb::Item* compiled_item);
+  private:
+  const ::aapt::pb::Item& _internal_compiled_item() const;
+  ::aapt::pb::Item* _internal_mutable_compiled_item();
+  public:
+  void unsafe_arena_set_allocated_compiled_item(
+      ::aapt::pb::Item* compiled_item);
+  ::aapt::pb::Item* unsafe_arena_release_compiled_item();
+
+  // uint32 resource_id = 5;
+  void clear_resource_id();
+  ::uint32_t resource_id() const;
+  void set_resource_id(::uint32_t value);
+  private:
+  ::uint32_t _internal_resource_id() const;
+  void _internal_set_resource_id(::uint32_t value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.XmlAttribute)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_uri_;
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
+    ::aapt::pb::SourcePosition* source_;
+    ::aapt::pb::Item* compiled_item_;
+    ::uint32_t resource_id_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class MacroBody final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.MacroBody) */ {
+ public:
+  inline MacroBody() : MacroBody(nullptr) {}
+  ~MacroBody() override;
+  explicit PROTOBUF_CONSTEXPR MacroBody(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  MacroBody(const MacroBody& from);
+  MacroBody(MacroBody&& from) noexcept
+    : MacroBody() {
+    *this = ::std::move(from);
+  }
+
+  inline MacroBody& operator=(const MacroBody& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline MacroBody& operator=(MacroBody&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const MacroBody& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const MacroBody* internal_default_instance() {
+    return reinterpret_cast<const MacroBody*>(
+               &_MacroBody_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    45;
+
+  friend void swap(MacroBody& a, MacroBody& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(MacroBody* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(MacroBody* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  MacroBody* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<MacroBody>(arena);
+  }
+  MacroBody* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const MacroBody& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const MacroBody& from) {
+    MacroBody::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(MacroBody* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.MacroBody";
+  }
+  protected:
+  explicit MacroBody(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kUntranslatableSectionsFieldNumber = 3,
+    kNamespaceStackFieldNumber = 4,
+    kRawStringFieldNumber = 1,
+    kStyleStringFieldNumber = 2,
+    kSourceFieldNumber = 5,
+  };
+  // repeated .aapt.pb.UntranslatableSection untranslatable_sections = 3;
+  int untranslatable_sections_size() const;
+  private:
+  int _internal_untranslatable_sections_size() const;
+  public:
+  void clear_untranslatable_sections();
+  ::aapt::pb::UntranslatableSection* mutable_untranslatable_sections(int index);
+  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::UntranslatableSection >*
+      mutable_untranslatable_sections();
+  private:
+  const ::aapt::pb::UntranslatableSection& _internal_untranslatable_sections(int index) const;
+  ::aapt::pb::UntranslatableSection* _internal_add_untranslatable_sections();
+  public:
+  const ::aapt::pb::UntranslatableSection& untranslatable_sections(int index) const;
+  ::aapt::pb::UntranslatableSection* add_untranslatable_sections();
+  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::UntranslatableSection >&
+      untranslatable_sections() const;
+
+  // repeated .aapt.pb.NamespaceAlias namespace_stack = 4;
+  int namespace_stack_size() const;
+  private:
+  int _internal_namespace_stack_size() const;
+  public:
+  void clear_namespace_stack();
+  ::aapt::pb::NamespaceAlias* mutable_namespace_stack(int index);
+  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::NamespaceAlias >*
+      mutable_namespace_stack();
+  private:
+  const ::aapt::pb::NamespaceAlias& _internal_namespace_stack(int index) const;
+  ::aapt::pb::NamespaceAlias* _internal_add_namespace_stack();
+  public:
+  const ::aapt::pb::NamespaceAlias& namespace_stack(int index) const;
+  ::aapt::pb::NamespaceAlias* add_namespace_stack();
+  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::NamespaceAlias >&
+      namespace_stack() const;
+
+  // string raw_string = 1;
+  void clear_raw_string();
+  const std::string& raw_string() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_raw_string(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_raw_string();
+  PROTOBUF_NODISCARD std::string* release_raw_string();
+  void set_allocated_raw_string(std::string* raw_string);
+  private:
+  const std::string& _internal_raw_string() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_string(const std::string& value);
+  std::string* _internal_mutable_raw_string();
+  public:
+
+  // .aapt.pb.StyleString style_string = 2;
+  bool has_style_string() const;
+  private:
+  bool _internal_has_style_string() const;
+  public:
+  void clear_style_string();
+  const ::aapt::pb::StyleString& style_string() const;
+  PROTOBUF_NODISCARD ::aapt::pb::StyleString* release_style_string();
+  ::aapt::pb::StyleString* mutable_style_string();
+  void set_allocated_style_string(::aapt::pb::StyleString* style_string);
+  private:
+  const ::aapt::pb::StyleString& _internal_style_string() const;
+  ::aapt::pb::StyleString* _internal_mutable_style_string();
+  public:
+  void unsafe_arena_set_allocated_style_string(
+      ::aapt::pb::StyleString* style_string);
+  ::aapt::pb::StyleString* unsafe_arena_release_style_string();
+
+  // .aapt.pb.SourcePosition source = 5;
+  bool has_source() const;
+  private:
+  bool _internal_has_source() const;
+  public:
+  void clear_source();
+  const ::aapt::pb::SourcePosition& source() const;
+  PROTOBUF_NODISCARD ::aapt::pb::SourcePosition* release_source();
+  ::aapt::pb::SourcePosition* mutable_source();
+  void set_allocated_source(::aapt::pb::SourcePosition* source);
+  private:
+  const ::aapt::pb::SourcePosition& _internal_source() const;
+  ::aapt::pb::SourcePosition* _internal_mutable_source();
+  public:
+  void unsafe_arena_set_allocated_source(
+      ::aapt::pb::SourcePosition* source);
+  ::aapt::pb::SourcePosition* unsafe_arena_release_source();
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.MacroBody)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::UntranslatableSection > untranslatable_sections_;
+    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::NamespaceAlias > namespace_stack_;
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_string_;
+    ::aapt::pb::StyleString* style_string_;
+    ::aapt::pb::SourcePosition* source_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class NamespaceAlias final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.NamespaceAlias) */ {
+ public:
+  inline NamespaceAlias() : NamespaceAlias(nullptr) {}
+  ~NamespaceAlias() override;
+  explicit PROTOBUF_CONSTEXPR NamespaceAlias(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  NamespaceAlias(const NamespaceAlias& from);
+  NamespaceAlias(NamespaceAlias&& from) noexcept
+    : NamespaceAlias() {
+    *this = ::std::move(from);
+  }
+
+  inline NamespaceAlias& operator=(const NamespaceAlias& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline NamespaceAlias& operator=(NamespaceAlias&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const NamespaceAlias& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const NamespaceAlias* internal_default_instance() {
+    return reinterpret_cast<const NamespaceAlias*>(
+               &_NamespaceAlias_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    46;
+
+  friend void swap(NamespaceAlias& a, NamespaceAlias& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(NamespaceAlias* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(NamespaceAlias* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  NamespaceAlias* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<NamespaceAlias>(arena);
+  }
+  NamespaceAlias* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const NamespaceAlias& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const NamespaceAlias& from) {
+    NamespaceAlias::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(NamespaceAlias* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.NamespaceAlias";
+  }
+  protected:
+  explicit NamespaceAlias(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kPrefixFieldNumber = 1,
+    kPackageNameFieldNumber = 2,
+    kIsPrivateFieldNumber = 3,
+  };
+  // string prefix = 1;
+  void clear_prefix();
+  const std::string& prefix() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_prefix(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_prefix();
+  PROTOBUF_NODISCARD std::string* release_prefix();
+  void set_allocated_prefix(std::string* prefix);
+  private:
+  const std::string& _internal_prefix() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(const std::string& value);
+  std::string* _internal_mutable_prefix();
+  public:
+
+  // string package_name = 2;
+  void clear_package_name();
+  const std::string& package_name() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_package_name(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_package_name();
+  PROTOBUF_NODISCARD std::string* release_package_name();
+  void set_allocated_package_name(std::string* package_name);
+  private:
+  const std::string& _internal_package_name() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
+  std::string* _internal_mutable_package_name();
+  public:
+
+  // bool is_private = 3;
+  void clear_is_private();
+  bool is_private() const;
+  void set_is_private(bool value);
+  private:
+  bool _internal_is_private() const;
+  void _internal_set_is_private(bool value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.NamespaceAlias)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
+    bool is_private_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class StyleString_Span final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.StyleString.Span) */ {
+ public:
+  inline StyleString_Span() : StyleString_Span(nullptr) {}
+  ~StyleString_Span() override;
+  explicit PROTOBUF_CONSTEXPR StyleString_Span(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  StyleString_Span(const StyleString_Span& from);
+  StyleString_Span(StyleString_Span&& from) noexcept
+    : StyleString_Span() {
+    *this = ::std::move(from);
+  }
+
+  inline StyleString_Span& operator=(const StyleString_Span& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline StyleString_Span& operator=(StyleString_Span&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const StyleString_Span& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const StyleString_Span* internal_default_instance() {
+    return reinterpret_cast<const StyleString_Span*>(
+               &_StyleString_Span_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    47;
+
+  friend void swap(StyleString_Span& a, StyleString_Span& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(StyleString_Span* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(StyleString_Span* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  StyleString_Span* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<StyleString_Span>(arena);
+  }
+  StyleString_Span* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const StyleString_Span& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const StyleString_Span& from) {
+    StyleString_Span::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(StyleString_Span* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.StyleString.Span";
+  }
+  protected:
+  explicit StyleString_Span(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kNameFieldNumber = 1,
+    kStartIndexFieldNumber = 2,
+    kEndIndexFieldNumber = 3,
+  };
+  // string name = 1;
+  void clear_name();
+  const std::string& name() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_name(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_name();
+  PROTOBUF_NODISCARD std::string* release_name();
+  void set_allocated_name(std::string* name);
+  private:
+  const std::string& _internal_name() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
+  std::string* _internal_mutable_name();
+  public:
+
+  // uint32 start_index = 2;
+  void clear_start_index();
+  ::uint32_t start_index() const;
+  void set_start_index(::uint32_t value);
+  private:
+  ::uint32_t _internal_start_index() const;
+  void _internal_set_start_index(::uint32_t value);
+  public:
+
+  // uint32 end_index = 3;
+  void clear_end_index();
+  ::uint32_t end_index() const;
+  void set_end_index(::uint32_t value);
+  private:
+  ::uint32_t _internal_end_index() const;
+  void _internal_set_end_index(::uint32_t value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.StyleString.Span)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
+    ::uint32_t start_index_;
+    ::uint32_t end_index_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class StyleString final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.StyleString) */ {
+ public:
+  inline StyleString() : StyleString(nullptr) {}
+  ~StyleString() override;
+  explicit PROTOBUF_CONSTEXPR StyleString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  StyleString(const StyleString& from);
+  StyleString(StyleString&& from) noexcept
+    : StyleString() {
+    *this = ::std::move(from);
+  }
+
+  inline StyleString& operator=(const StyleString& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline StyleString& operator=(StyleString&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const StyleString& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const StyleString* internal_default_instance() {
+    return reinterpret_cast<const StyleString*>(
+               &_StyleString_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    48;
+
+  friend void swap(StyleString& a, StyleString& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(StyleString* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(StyleString* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  StyleString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<StyleString>(arena);
+  }
+  StyleString* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const StyleString& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const StyleString& from) {
+    StyleString::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(StyleString* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.StyleString";
+  }
+  protected:
+  explicit StyleString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  typedef StyleString_Span Span;
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kSpansFieldNumber = 2,
+    kStrFieldNumber = 1,
+  };
+  // repeated .aapt.pb.StyleString.Span spans = 2;
+  int spans_size() const;
+  private:
+  int _internal_spans_size() const;
+  public:
+  void clear_spans();
+  ::aapt::pb::StyleString_Span* mutable_spans(int index);
+  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::StyleString_Span >*
+      mutable_spans();
+  private:
+  const ::aapt::pb::StyleString_Span& _internal_spans(int index) const;
+  ::aapt::pb::StyleString_Span* _internal_add_spans();
+  public:
+  const ::aapt::pb::StyleString_Span& spans(int index) const;
+  ::aapt::pb::StyleString_Span* add_spans();
+  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::StyleString_Span >&
+      spans() const;
+
+  // string str = 1;
+  void clear_str();
+  const std::string& str() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_str(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_str();
+  PROTOBUF_NODISCARD std::string* release_str();
+  void set_allocated_str(std::string* str);
+  private:
+  const std::string& _internal_str() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str(const std::string& value);
+  std::string* _internal_mutable_str();
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.StyleString)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::StyleString_Span > spans_;
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// -------------------------------------------------------------------
+
+class UntranslatableSection final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.UntranslatableSection) */ {
+ public:
+  inline UntranslatableSection() : UntranslatableSection(nullptr) {}
+  ~UntranslatableSection() override;
+  explicit PROTOBUF_CONSTEXPR UntranslatableSection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  UntranslatableSection(const UntranslatableSection& from);
+  UntranslatableSection(UntranslatableSection&& from) noexcept
+    : UntranslatableSection() {
+    *this = ::std::move(from);
+  }
+
+  inline UntranslatableSection& operator=(const UntranslatableSection& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline UntranslatableSection& operator=(UntranslatableSection&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const UntranslatableSection& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const UntranslatableSection* internal_default_instance() {
+    return reinterpret_cast<const UntranslatableSection*>(
+               &_UntranslatableSection_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    49;
+
+  friend void swap(UntranslatableSection& a, UntranslatableSection& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(UntranslatableSection* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(UntranslatableSection* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  UntranslatableSection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<UntranslatableSection>(arena);
+  }
+  UntranslatableSection* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const UntranslatableSection& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const UntranslatableSection& from) {
+    UntranslatableSection::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(UntranslatableSection* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.UntranslatableSection";
+  }
+  protected:
+  explicit UntranslatableSection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kStartIndexFieldNumber = 1,
+    kEndIndexFieldNumber = 2,
+  };
+  // uint64 start_index = 1;
+  void clear_start_index();
+  ::uint64_t start_index() const;
+  void set_start_index(::uint64_t value);
+  private:
+  ::uint64_t _internal_start_index() const;
+  void _internal_set_start_index(::uint64_t value);
+  public:
+
+  // uint64 end_index = 2;
+  void clear_end_index();
+  ::uint64_t end_index() const;
+  void set_end_index(::uint64_t value);
+  private:
+  ::uint64_t _internal_end_index() const;
+  void _internal_set_end_index(::uint64_t value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.UntranslatableSection)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::uint64_t start_index_;
+    ::uint64_t end_index_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_Resources_2eproto;
+};
+// ===================================================================
+
+
+// ===================================================================
+
+#ifdef __GNUC__
+  #pragma GCC diagnostic push
+  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
+#endif  // __GNUC__
+// StringPool
+
+// bytes data = 1;
+inline void StringPool::clear_data() {
+  _impl_.data_.ClearToEmpty();
+}
+inline const std::string& StringPool::data() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.StringPool.data)
+  return _internal_data();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void StringPool::set_data(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.StringPool.data)
+}
+inline std::string* StringPool::mutable_data() {
+  std::string* _s = _internal_mutable_data();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.StringPool.data)
+  return _s;
+}
+inline const std::string& StringPool::_internal_data() const {
+  return _impl_.data_.Get();
+}
+inline void StringPool::_internal_set_data(const std::string& value) {
+  
+  _impl_.data_.Set(value, GetArenaForAllocation());
+}
+inline std::string* StringPool::_internal_mutable_data() {
+  
+  return _impl_.data_.Mutable(GetArenaForAllocation());
+}
+inline std::string* StringPool::release_data() {
+  // @@protoc_insertion_point(field_release:aapt.pb.StringPool.data)
+  return _impl_.data_.Release();
+}
+inline void StringPool::set_allocated_data(std::string* data) {
+  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.data_.IsDefault()) {
+    _impl_.data_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.StringPool.data)
+}
+
+// -------------------------------------------------------------------
+
+// SourcePosition
+
+// uint32 line_number = 1;
+inline void SourcePosition::clear_line_number() {
+  _impl_.line_number_ = 0u;
+}
+inline ::uint32_t SourcePosition::_internal_line_number() const {
+  return _impl_.line_number_;
+}
+inline ::uint32_t SourcePosition::line_number() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.SourcePosition.line_number)
+  return _internal_line_number();
+}
+inline void SourcePosition::_internal_set_line_number(::uint32_t value) {
+  
+  _impl_.line_number_ = value;
+}
+inline void SourcePosition::set_line_number(::uint32_t value) {
+  _internal_set_line_number(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.SourcePosition.line_number)
+}
+
+// uint32 column_number = 2;
+inline void SourcePosition::clear_column_number() {
+  _impl_.column_number_ = 0u;
+}
+inline ::uint32_t SourcePosition::_internal_column_number() const {
+  return _impl_.column_number_;
+}
+inline ::uint32_t SourcePosition::column_number() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.SourcePosition.column_number)
+  return _internal_column_number();
+}
+inline void SourcePosition::_internal_set_column_number(::uint32_t value) {
+  
+  _impl_.column_number_ = value;
+}
+inline void SourcePosition::set_column_number(::uint32_t value) {
+  _internal_set_column_number(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.SourcePosition.column_number)
+}
+
+// -------------------------------------------------------------------
+
+// Source
+
+// uint32 path_idx = 1;
+inline void Source::clear_path_idx() {
+  _impl_.path_idx_ = 0u;
+}
+inline ::uint32_t Source::_internal_path_idx() const {
+  return _impl_.path_idx_;
+}
+inline ::uint32_t Source::path_idx() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Source.path_idx)
+  return _internal_path_idx();
+}
+inline void Source::_internal_set_path_idx(::uint32_t value) {
+  
+  _impl_.path_idx_ = value;
+}
+inline void Source::set_path_idx(::uint32_t value) {
+  _internal_set_path_idx(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Source.path_idx)
+}
+
+// .aapt.pb.SourcePosition position = 2;
+inline bool Source::_internal_has_position() const {
+  return this != internal_default_instance() && _impl_.position_ != nullptr;
+}
+inline bool Source::has_position() const {
+  return _internal_has_position();
+}
+inline void Source::clear_position() {
+  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
+    delete _impl_.position_;
+  }
+  _impl_.position_ = nullptr;
+}
+inline const ::aapt::pb::SourcePosition& Source::_internal_position() const {
+  const ::aapt::pb::SourcePosition* p = _impl_.position_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::SourcePosition&>(
+      ::aapt::pb::_SourcePosition_default_instance_);
+}
+inline const ::aapt::pb::SourcePosition& Source::position() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Source.position)
+  return _internal_position();
+}
+inline void Source::unsafe_arena_set_allocated_position(
+    ::aapt::pb::SourcePosition* position) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
+  }
+  _impl_.position_ = position;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Source.position)
+}
+inline ::aapt::pb::SourcePosition* Source::release_position() {
+  
+  ::aapt::pb::SourcePosition* temp = _impl_.position_;
+  _impl_.position_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::SourcePosition* Source::unsafe_arena_release_position() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Source.position)
+  
+  ::aapt::pb::SourcePosition* temp = _impl_.position_;
+  _impl_.position_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::SourcePosition* Source::_internal_mutable_position() {
+  
+  if (_impl_.position_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::SourcePosition>(GetArenaForAllocation());
+    _impl_.position_ = p;
+  }
+  return _impl_.position_;
+}
+inline ::aapt::pb::SourcePosition* Source::mutable_position() {
+  ::aapt::pb::SourcePosition* _msg = _internal_mutable_position();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Source.position)
+  return _msg;
+}
+inline void Source::set_allocated_position(::aapt::pb::SourcePosition* position) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.position_;
+  }
+  if (position) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
+    if (message_arena != submessage_arena) {
+      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, position, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.position_ = position;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Source.position)
+}
+
+// -------------------------------------------------------------------
+
+// ToolFingerprint
+
+// string tool = 1;
+inline void ToolFingerprint::clear_tool() {
+  _impl_.tool_.ClearToEmpty();
+}
+inline const std::string& ToolFingerprint::tool() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.ToolFingerprint.tool)
+  return _internal_tool();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void ToolFingerprint::set_tool(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.tool_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.ToolFingerprint.tool)
+}
+inline std::string* ToolFingerprint::mutable_tool() {
+  std::string* _s = _internal_mutable_tool();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.ToolFingerprint.tool)
+  return _s;
+}
+inline const std::string& ToolFingerprint::_internal_tool() const {
+  return _impl_.tool_.Get();
+}
+inline void ToolFingerprint::_internal_set_tool(const std::string& value) {
+  
+  _impl_.tool_.Set(value, GetArenaForAllocation());
+}
+inline std::string* ToolFingerprint::_internal_mutable_tool() {
+  
+  return _impl_.tool_.Mutable(GetArenaForAllocation());
+}
+inline std::string* ToolFingerprint::release_tool() {
+  // @@protoc_insertion_point(field_release:aapt.pb.ToolFingerprint.tool)
+  return _impl_.tool_.Release();
+}
+inline void ToolFingerprint::set_allocated_tool(std::string* tool) {
+  _impl_.tool_.SetAllocated(tool, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.tool_.IsDefault()) {
+    _impl_.tool_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ToolFingerprint.tool)
+}
+
+// string version = 2;
+inline void ToolFingerprint::clear_version() {
+  _impl_.version_.ClearToEmpty();
+}
+inline const std::string& ToolFingerprint::version() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.ToolFingerprint.version)
+  return _internal_version();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void ToolFingerprint::set_version(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.ToolFingerprint.version)
+}
+inline std::string* ToolFingerprint::mutable_version() {
+  std::string* _s = _internal_mutable_version();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.ToolFingerprint.version)
+  return _s;
+}
+inline const std::string& ToolFingerprint::_internal_version() const {
+  return _impl_.version_.Get();
+}
+inline void ToolFingerprint::_internal_set_version(const std::string& value) {
+  
+  _impl_.version_.Set(value, GetArenaForAllocation());
+}
+inline std::string* ToolFingerprint::_internal_mutable_version() {
+  
+  return _impl_.version_.Mutable(GetArenaForAllocation());
+}
+inline std::string* ToolFingerprint::release_version() {
+  // @@protoc_insertion_point(field_release:aapt.pb.ToolFingerprint.version)
+  return _impl_.version_.Release();
+}
+inline void ToolFingerprint::set_allocated_version(std::string* version) {
+  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.version_.IsDefault()) {
+    _impl_.version_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ToolFingerprint.version)
+}
+
+// -------------------------------------------------------------------
+
+// ResourceTable
+
+// .aapt.pb.StringPool source_pool = 1;
+inline bool ResourceTable::_internal_has_source_pool() const {
+  return this != internal_default_instance() && _impl_.source_pool_ != nullptr;
+}
+inline bool ResourceTable::has_source_pool() const {
+  return _internal_has_source_pool();
+}
+inline void ResourceTable::clear_source_pool() {
+  if (GetArenaForAllocation() == nullptr && _impl_.source_pool_ != nullptr) {
+    delete _impl_.source_pool_;
+  }
+  _impl_.source_pool_ = nullptr;
+}
+inline const ::aapt::pb::StringPool& ResourceTable::_internal_source_pool() const {
+  const ::aapt::pb::StringPool* p = _impl_.source_pool_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::StringPool&>(
+      ::aapt::pb::_StringPool_default_instance_);
+}
+inline const ::aapt::pb::StringPool& ResourceTable::source_pool() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.ResourceTable.source_pool)
+  return _internal_source_pool();
+}
+inline void ResourceTable::unsafe_arena_set_allocated_source_pool(
+    ::aapt::pb::StringPool* source_pool) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_pool_);
+  }
+  _impl_.source_pool_ = source_pool;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.ResourceTable.source_pool)
+}
+inline ::aapt::pb::StringPool* ResourceTable::release_source_pool() {
+  
+  ::aapt::pb::StringPool* temp = _impl_.source_pool_;
+  _impl_.source_pool_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::StringPool* ResourceTable::unsafe_arena_release_source_pool() {
+  // @@protoc_insertion_point(field_release:aapt.pb.ResourceTable.source_pool)
+  
+  ::aapt::pb::StringPool* temp = _impl_.source_pool_;
+  _impl_.source_pool_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::StringPool* ResourceTable::_internal_mutable_source_pool() {
+  
+  if (_impl_.source_pool_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::StringPool>(GetArenaForAllocation());
+    _impl_.source_pool_ = p;
+  }
+  return _impl_.source_pool_;
+}
+inline ::aapt::pb::StringPool* ResourceTable::mutable_source_pool() {
+  ::aapt::pb::StringPool* _msg = _internal_mutable_source_pool();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.ResourceTable.source_pool)
+  return _msg;
+}
+inline void ResourceTable::set_allocated_source_pool(::aapt::pb::StringPool* source_pool) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.source_pool_;
+  }
+  if (source_pool) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_pool);
+    if (message_arena != submessage_arena) {
+      source_pool = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, source_pool, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.source_pool_ = source_pool;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ResourceTable.source_pool)
+}
+
+// repeated .aapt.pb.Package package = 2;
+inline int ResourceTable::_internal_package_size() const {
+  return _impl_.package_.size();
+}
+inline int ResourceTable::package_size() const {
+  return _internal_package_size();
+}
+inline void ResourceTable::clear_package() {
+  _impl_.package_.Clear();
+}
+inline ::aapt::pb::Package* ResourceTable::mutable_package(int index) {
+  // @@protoc_insertion_point(field_mutable:aapt.pb.ResourceTable.package)
+  return _impl_.package_.Mutable(index);
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Package >*
+ResourceTable::mutable_package() {
+  // @@protoc_insertion_point(field_mutable_list:aapt.pb.ResourceTable.package)
+  return &_impl_.package_;
+}
+inline const ::aapt::pb::Package& ResourceTable::_internal_package(int index) const {
+  return _impl_.package_.Get(index);
+}
+inline const ::aapt::pb::Package& ResourceTable::package(int index) const {
+  // @@protoc_insertion_point(field_get:aapt.pb.ResourceTable.package)
+  return _internal_package(index);
+}
+inline ::aapt::pb::Package* ResourceTable::_internal_add_package() {
+  return _impl_.package_.Add();
+}
+inline ::aapt::pb::Package* ResourceTable::add_package() {
+  ::aapt::pb::Package* _add = _internal_add_package();
+  // @@protoc_insertion_point(field_add:aapt.pb.ResourceTable.package)
+  return _add;
+}
+inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Package >&
+ResourceTable::package() const {
+  // @@protoc_insertion_point(field_list:aapt.pb.ResourceTable.package)
+  return _impl_.package_;
+}
+
+// repeated .aapt.pb.Overlayable overlayable = 3;
+inline int ResourceTable::_internal_overlayable_size() const {
+  return _impl_.overlayable_.size();
+}
+inline int ResourceTable::overlayable_size() const {
+  return _internal_overlayable_size();
+}
+inline void ResourceTable::clear_overlayable() {
+  _impl_.overlayable_.Clear();
+}
+inline ::aapt::pb::Overlayable* ResourceTable::mutable_overlayable(int index) {
+  // @@protoc_insertion_point(field_mutable:aapt.pb.ResourceTable.overlayable)
+  return _impl_.overlayable_.Mutable(index);
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Overlayable >*
+ResourceTable::mutable_overlayable() {
+  // @@protoc_insertion_point(field_mutable_list:aapt.pb.ResourceTable.overlayable)
+  return &_impl_.overlayable_;
+}
+inline const ::aapt::pb::Overlayable& ResourceTable::_internal_overlayable(int index) const {
+  return _impl_.overlayable_.Get(index);
+}
+inline const ::aapt::pb::Overlayable& ResourceTable::overlayable(int index) const {
+  // @@protoc_insertion_point(field_get:aapt.pb.ResourceTable.overlayable)
+  return _internal_overlayable(index);
+}
+inline ::aapt::pb::Overlayable* ResourceTable::_internal_add_overlayable() {
+  return _impl_.overlayable_.Add();
+}
+inline ::aapt::pb::Overlayable* ResourceTable::add_overlayable() {
+  ::aapt::pb::Overlayable* _add = _internal_add_overlayable();
+  // @@protoc_insertion_point(field_add:aapt.pb.ResourceTable.overlayable)
+  return _add;
+}
+inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Overlayable >&
+ResourceTable::overlayable() const {
+  // @@protoc_insertion_point(field_list:aapt.pb.ResourceTable.overlayable)
+  return _impl_.overlayable_;
+}
+
+// repeated .aapt.pb.ToolFingerprint tool_fingerprint = 4;
+inline int ResourceTable::_internal_tool_fingerprint_size() const {
+  return _impl_.tool_fingerprint_.size();
+}
+inline int ResourceTable::tool_fingerprint_size() const {
+  return _internal_tool_fingerprint_size();
+}
+inline void ResourceTable::clear_tool_fingerprint() {
+  _impl_.tool_fingerprint_.Clear();
+}
+inline ::aapt::pb::ToolFingerprint* ResourceTable::mutable_tool_fingerprint(int index) {
+  // @@protoc_insertion_point(field_mutable:aapt.pb.ResourceTable.tool_fingerprint)
+  return _impl_.tool_fingerprint_.Mutable(index);
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::ToolFingerprint >*
+ResourceTable::mutable_tool_fingerprint() {
+  // @@protoc_insertion_point(field_mutable_list:aapt.pb.ResourceTable.tool_fingerprint)
+  return &_impl_.tool_fingerprint_;
+}
+inline const ::aapt::pb::ToolFingerprint& ResourceTable::_internal_tool_fingerprint(int index) const {
+  return _impl_.tool_fingerprint_.Get(index);
+}
+inline const ::aapt::pb::ToolFingerprint& ResourceTable::tool_fingerprint(int index) const {
+  // @@protoc_insertion_point(field_get:aapt.pb.ResourceTable.tool_fingerprint)
+  return _internal_tool_fingerprint(index);
+}
+inline ::aapt::pb::ToolFingerprint* ResourceTable::_internal_add_tool_fingerprint() {
+  return _impl_.tool_fingerprint_.Add();
+}
+inline ::aapt::pb::ToolFingerprint* ResourceTable::add_tool_fingerprint() {
+  ::aapt::pb::ToolFingerprint* _add = _internal_add_tool_fingerprint();
+  // @@protoc_insertion_point(field_add:aapt.pb.ResourceTable.tool_fingerprint)
+  return _add;
+}
+inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::ToolFingerprint >&
+ResourceTable::tool_fingerprint() const {
+  // @@protoc_insertion_point(field_list:aapt.pb.ResourceTable.tool_fingerprint)
+  return _impl_.tool_fingerprint_;
+}
+
+// -------------------------------------------------------------------
+
+// PackageId
+
+// uint32 id = 1;
+inline void PackageId::clear_id() {
+  _impl_.id_ = 0u;
+}
+inline ::uint32_t PackageId::_internal_id() const {
+  return _impl_.id_;
+}
+inline ::uint32_t PackageId::id() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.PackageId.id)
+  return _internal_id();
+}
+inline void PackageId::_internal_set_id(::uint32_t value) {
+  
+  _impl_.id_ = value;
+}
+inline void PackageId::set_id(::uint32_t value) {
+  _internal_set_id(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.PackageId.id)
+}
+
+// -------------------------------------------------------------------
+
+// Package
+
+// .aapt.pb.PackageId package_id = 1;
+inline bool Package::_internal_has_package_id() const {
+  return this != internal_default_instance() && _impl_.package_id_ != nullptr;
+}
+inline bool Package::has_package_id() const {
+  return _internal_has_package_id();
+}
+inline void Package::clear_package_id() {
+  if (GetArenaForAllocation() == nullptr && _impl_.package_id_ != nullptr) {
+    delete _impl_.package_id_;
+  }
+  _impl_.package_id_ = nullptr;
+}
+inline const ::aapt::pb::PackageId& Package::_internal_package_id() const {
+  const ::aapt::pb::PackageId* p = _impl_.package_id_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::PackageId&>(
+      ::aapt::pb::_PackageId_default_instance_);
+}
+inline const ::aapt::pb::PackageId& Package::package_id() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Package.package_id)
+  return _internal_package_id();
+}
+inline void Package::unsafe_arena_set_allocated_package_id(
+    ::aapt::pb::PackageId* package_id) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.package_id_);
+  }
+  _impl_.package_id_ = package_id;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Package.package_id)
+}
+inline ::aapt::pb::PackageId* Package::release_package_id() {
+  
+  ::aapt::pb::PackageId* temp = _impl_.package_id_;
+  _impl_.package_id_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::PackageId* Package::unsafe_arena_release_package_id() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Package.package_id)
+  
+  ::aapt::pb::PackageId* temp = _impl_.package_id_;
+  _impl_.package_id_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::PackageId* Package::_internal_mutable_package_id() {
+  
+  if (_impl_.package_id_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::PackageId>(GetArenaForAllocation());
+    _impl_.package_id_ = p;
+  }
+  return _impl_.package_id_;
+}
+inline ::aapt::pb::PackageId* Package::mutable_package_id() {
+  ::aapt::pb::PackageId* _msg = _internal_mutable_package_id();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Package.package_id)
+  return _msg;
+}
+inline void Package::set_allocated_package_id(::aapt::pb::PackageId* package_id) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.package_id_;
+  }
+  if (package_id) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(package_id);
+    if (message_arena != submessage_arena) {
+      package_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, package_id, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.package_id_ = package_id;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Package.package_id)
+}
+
+// string package_name = 2;
+inline void Package::clear_package_name() {
+  _impl_.package_name_.ClearToEmpty();
+}
+inline const std::string& Package::package_name() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Package.package_name)
+  return _internal_package_name();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void Package::set_package_name(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.Package.package_name)
+}
+inline std::string* Package::mutable_package_name() {
+  std::string* _s = _internal_mutable_package_name();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Package.package_name)
+  return _s;
+}
+inline const std::string& Package::_internal_package_name() const {
+  return _impl_.package_name_.Get();
+}
+inline void Package::_internal_set_package_name(const std::string& value) {
+  
+  _impl_.package_name_.Set(value, GetArenaForAllocation());
+}
+inline std::string* Package::_internal_mutable_package_name() {
+  
+  return _impl_.package_name_.Mutable(GetArenaForAllocation());
+}
+inline std::string* Package::release_package_name() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Package.package_name)
+  return _impl_.package_name_.Release();
+}
+inline void Package::set_allocated_package_name(std::string* package_name) {
+  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.package_name_.IsDefault()) {
+    _impl_.package_name_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Package.package_name)
+}
+
+// repeated .aapt.pb.Type type = 3;
+inline int Package::_internal_type_size() const {
+  return _impl_.type_.size();
+}
+inline int Package::type_size() const {
+  return _internal_type_size();
+}
+inline void Package::clear_type() {
+  _impl_.type_.Clear();
+}
+inline ::aapt::pb::Type* Package::mutable_type(int index) {
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Package.type)
+  return _impl_.type_.Mutable(index);
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Type >*
+Package::mutable_type() {
+  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Package.type)
+  return &_impl_.type_;
+}
+inline const ::aapt::pb::Type& Package::_internal_type(int index) const {
+  return _impl_.type_.Get(index);
+}
+inline const ::aapt::pb::Type& Package::type(int index) const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Package.type)
+  return _internal_type(index);
+}
+inline ::aapt::pb::Type* Package::_internal_add_type() {
+  return _impl_.type_.Add();
+}
+inline ::aapt::pb::Type* Package::add_type() {
+  ::aapt::pb::Type* _add = _internal_add_type();
+  // @@protoc_insertion_point(field_add:aapt.pb.Package.type)
+  return _add;
+}
+inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Type >&
+Package::type() const {
+  // @@protoc_insertion_point(field_list:aapt.pb.Package.type)
+  return _impl_.type_;
+}
+
+// -------------------------------------------------------------------
+
+// TypeId
+
+// uint32 id = 1;
+inline void TypeId::clear_id() {
+  _impl_.id_ = 0u;
+}
+inline ::uint32_t TypeId::_internal_id() const {
+  return _impl_.id_;
+}
+inline ::uint32_t TypeId::id() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.TypeId.id)
+  return _internal_id();
+}
+inline void TypeId::_internal_set_id(::uint32_t value) {
+  
+  _impl_.id_ = value;
+}
+inline void TypeId::set_id(::uint32_t value) {
+  _internal_set_id(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.TypeId.id)
+}
+
+// -------------------------------------------------------------------
+
+// Type
+
+// .aapt.pb.TypeId type_id = 1;
+inline bool Type::_internal_has_type_id() const {
+  return this != internal_default_instance() && _impl_.type_id_ != nullptr;
+}
+inline bool Type::has_type_id() const {
+  return _internal_has_type_id();
+}
+inline void Type::clear_type_id() {
+  if (GetArenaForAllocation() == nullptr && _impl_.type_id_ != nullptr) {
+    delete _impl_.type_id_;
+  }
+  _impl_.type_id_ = nullptr;
+}
+inline const ::aapt::pb::TypeId& Type::_internal_type_id() const {
+  const ::aapt::pb::TypeId* p = _impl_.type_id_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::TypeId&>(
+      ::aapt::pb::_TypeId_default_instance_);
+}
+inline const ::aapt::pb::TypeId& Type::type_id() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Type.type_id)
+  return _internal_type_id();
+}
+inline void Type::unsafe_arena_set_allocated_type_id(
+    ::aapt::pb::TypeId* type_id) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.type_id_);
+  }
+  _impl_.type_id_ = type_id;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Type.type_id)
+}
+inline ::aapt::pb::TypeId* Type::release_type_id() {
+  
+  ::aapt::pb::TypeId* temp = _impl_.type_id_;
+  _impl_.type_id_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::TypeId* Type::unsafe_arena_release_type_id() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Type.type_id)
+  
+  ::aapt::pb::TypeId* temp = _impl_.type_id_;
+  _impl_.type_id_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::TypeId* Type::_internal_mutable_type_id() {
+  
+  if (_impl_.type_id_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::TypeId>(GetArenaForAllocation());
+    _impl_.type_id_ = p;
+  }
+  return _impl_.type_id_;
+}
+inline ::aapt::pb::TypeId* Type::mutable_type_id() {
+  ::aapt::pb::TypeId* _msg = _internal_mutable_type_id();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Type.type_id)
+  return _msg;
+}
+inline void Type::set_allocated_type_id(::aapt::pb::TypeId* type_id) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.type_id_;
+  }
+  if (type_id) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(type_id);
+    if (message_arena != submessage_arena) {
+      type_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, type_id, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.type_id_ = type_id;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Type.type_id)
+}
+
+// string name = 2;
+inline void Type::clear_name() {
+  _impl_.name_.ClearToEmpty();
+}
+inline const std::string& Type::name() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Type.name)
+  return _internal_name();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void Type::set_name(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.Type.name)
+}
+inline std::string* Type::mutable_name() {
+  std::string* _s = _internal_mutable_name();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Type.name)
+  return _s;
+}
+inline const std::string& Type::_internal_name() const {
+  return _impl_.name_.Get();
+}
+inline void Type::_internal_set_name(const std::string& value) {
+  
+  _impl_.name_.Set(value, GetArenaForAllocation());
+}
+inline std::string* Type::_internal_mutable_name() {
+  
+  return _impl_.name_.Mutable(GetArenaForAllocation());
+}
+inline std::string* Type::release_name() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Type.name)
+  return _impl_.name_.Release();
+}
+inline void Type::set_allocated_name(std::string* name) {
+  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.name_.IsDefault()) {
+    _impl_.name_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Type.name)
+}
+
+// repeated .aapt.pb.Entry entry = 3;
+inline int Type::_internal_entry_size() const {
+  return _impl_.entry_.size();
+}
+inline int Type::entry_size() const {
+  return _internal_entry_size();
+}
+inline void Type::clear_entry() {
+  _impl_.entry_.Clear();
+}
+inline ::aapt::pb::Entry* Type::mutable_entry(int index) {
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Type.entry)
+  return _impl_.entry_.Mutable(index);
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Entry >*
+Type::mutable_entry() {
+  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Type.entry)
+  return &_impl_.entry_;
+}
+inline const ::aapt::pb::Entry& Type::_internal_entry(int index) const {
+  return _impl_.entry_.Get(index);
+}
+inline const ::aapt::pb::Entry& Type::entry(int index) const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Type.entry)
+  return _internal_entry(index);
+}
+inline ::aapt::pb::Entry* Type::_internal_add_entry() {
+  return _impl_.entry_.Add();
+}
+inline ::aapt::pb::Entry* Type::add_entry() {
+  ::aapt::pb::Entry* _add = _internal_add_entry();
+  // @@protoc_insertion_point(field_add:aapt.pb.Type.entry)
+  return _add;
+}
+inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Entry >&
+Type::entry() const {
+  // @@protoc_insertion_point(field_list:aapt.pb.Type.entry)
+  return _impl_.entry_;
+}
+
+// -------------------------------------------------------------------
+
+// Visibility
+
+// .aapt.pb.Visibility.Level level = 1;
+inline void Visibility::clear_level() {
+  _impl_.level_ = 0;
+}
+inline ::aapt::pb::Visibility_Level Visibility::_internal_level() const {
+  return static_cast< ::aapt::pb::Visibility_Level >(_impl_.level_);
+}
+inline ::aapt::pb::Visibility_Level Visibility::level() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Visibility.level)
+  return _internal_level();
+}
+inline void Visibility::_internal_set_level(::aapt::pb::Visibility_Level value) {
+  
+  _impl_.level_ = value;
+}
+inline void Visibility::set_level(::aapt::pb::Visibility_Level value) {
+  _internal_set_level(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Visibility.level)
+}
+
+// .aapt.pb.Source source = 2;
+inline bool Visibility::_internal_has_source() const {
+  return this != internal_default_instance() && _impl_.source_ != nullptr;
+}
+inline bool Visibility::has_source() const {
+  return _internal_has_source();
+}
+inline void Visibility::clear_source() {
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+}
+inline const ::aapt::pb::Source& Visibility::_internal_source() const {
+  const ::aapt::pb::Source* p = _impl_.source_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
+      ::aapt::pb::_Source_default_instance_);
+}
+inline const ::aapt::pb::Source& Visibility::source() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Visibility.source)
+  return _internal_source();
+}
+inline void Visibility::unsafe_arena_set_allocated_source(
+    ::aapt::pb::Source* source) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Visibility.source)
+}
+inline ::aapt::pb::Source* Visibility::release_source() {
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Source* Visibility::unsafe_arena_release_source() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Visibility.source)
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Source* Visibility::_internal_mutable_source() {
+  
+  if (_impl_.source_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
+    _impl_.source_ = p;
+  }
+  return _impl_.source_;
+}
+inline ::aapt::pb::Source* Visibility::mutable_source() {
+  ::aapt::pb::Source* _msg = _internal_mutable_source();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Visibility.source)
+  return _msg;
+}
+inline void Visibility::set_allocated_source(::aapt::pb::Source* source) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.source_;
+  }
+  if (source) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
+    if (message_arena != submessage_arena) {
+      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, source, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Visibility.source)
+}
+
+// string comment = 3;
+inline void Visibility::clear_comment() {
+  _impl_.comment_.ClearToEmpty();
+}
+inline const std::string& Visibility::comment() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Visibility.comment)
+  return _internal_comment();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void Visibility::set_comment(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.Visibility.comment)
+}
+inline std::string* Visibility::mutable_comment() {
+  std::string* _s = _internal_mutable_comment();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Visibility.comment)
+  return _s;
+}
+inline const std::string& Visibility::_internal_comment() const {
+  return _impl_.comment_.Get();
+}
+inline void Visibility::_internal_set_comment(const std::string& value) {
+  
+  _impl_.comment_.Set(value, GetArenaForAllocation());
+}
+inline std::string* Visibility::_internal_mutable_comment() {
+  
+  return _impl_.comment_.Mutable(GetArenaForAllocation());
+}
+inline std::string* Visibility::release_comment() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Visibility.comment)
+  return _impl_.comment_.Release();
+}
+inline void Visibility::set_allocated_comment(std::string* comment) {
+  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.comment_.IsDefault()) {
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Visibility.comment)
+}
+
+// bool staged_api = 4;
+inline void Visibility::clear_staged_api() {
+  _impl_.staged_api_ = false;
+}
+inline bool Visibility::_internal_staged_api() const {
+  return _impl_.staged_api_;
+}
+inline bool Visibility::staged_api() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Visibility.staged_api)
+  return _internal_staged_api();
+}
+inline void Visibility::_internal_set_staged_api(bool value) {
+  
+  _impl_.staged_api_ = value;
+}
+inline void Visibility::set_staged_api(bool value) {
+  _internal_set_staged_api(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Visibility.staged_api)
+}
+
+// -------------------------------------------------------------------
+
+// AllowNew
+
+// .aapt.pb.Source source = 1;
+inline bool AllowNew::_internal_has_source() const {
+  return this != internal_default_instance() && _impl_.source_ != nullptr;
+}
+inline bool AllowNew::has_source() const {
+  return _internal_has_source();
+}
+inline void AllowNew::clear_source() {
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+}
+inline const ::aapt::pb::Source& AllowNew::_internal_source() const {
+  const ::aapt::pb::Source* p = _impl_.source_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
+      ::aapt::pb::_Source_default_instance_);
+}
+inline const ::aapt::pb::Source& AllowNew::source() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.AllowNew.source)
+  return _internal_source();
+}
+inline void AllowNew::unsafe_arena_set_allocated_source(
+    ::aapt::pb::Source* source) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.AllowNew.source)
+}
+inline ::aapt::pb::Source* AllowNew::release_source() {
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Source* AllowNew::unsafe_arena_release_source() {
+  // @@protoc_insertion_point(field_release:aapt.pb.AllowNew.source)
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Source* AllowNew::_internal_mutable_source() {
+  
+  if (_impl_.source_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
+    _impl_.source_ = p;
+  }
+  return _impl_.source_;
+}
+inline ::aapt::pb::Source* AllowNew::mutable_source() {
+  ::aapt::pb::Source* _msg = _internal_mutable_source();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.AllowNew.source)
+  return _msg;
+}
+inline void AllowNew::set_allocated_source(::aapt::pb::Source* source) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.source_;
+  }
+  if (source) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
+    if (message_arena != submessage_arena) {
+      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, source, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.AllowNew.source)
+}
+
+// string comment = 2;
+inline void AllowNew::clear_comment() {
+  _impl_.comment_.ClearToEmpty();
+}
+inline const std::string& AllowNew::comment() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.AllowNew.comment)
+  return _internal_comment();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void AllowNew::set_comment(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.AllowNew.comment)
+}
+inline std::string* AllowNew::mutable_comment() {
+  std::string* _s = _internal_mutable_comment();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.AllowNew.comment)
+  return _s;
+}
+inline const std::string& AllowNew::_internal_comment() const {
+  return _impl_.comment_.Get();
+}
+inline void AllowNew::_internal_set_comment(const std::string& value) {
+  
+  _impl_.comment_.Set(value, GetArenaForAllocation());
+}
+inline std::string* AllowNew::_internal_mutable_comment() {
+  
+  return _impl_.comment_.Mutable(GetArenaForAllocation());
+}
+inline std::string* AllowNew::release_comment() {
+  // @@protoc_insertion_point(field_release:aapt.pb.AllowNew.comment)
+  return _impl_.comment_.Release();
+}
+inline void AllowNew::set_allocated_comment(std::string* comment) {
+  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.comment_.IsDefault()) {
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.AllowNew.comment)
+}
+
+// -------------------------------------------------------------------
+
+// Overlayable
+
+// string name = 1;
+inline void Overlayable::clear_name() {
+  _impl_.name_.ClearToEmpty();
+}
+inline const std::string& Overlayable::name() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Overlayable.name)
+  return _internal_name();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void Overlayable::set_name(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.Overlayable.name)
+}
+inline std::string* Overlayable::mutable_name() {
+  std::string* _s = _internal_mutable_name();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Overlayable.name)
+  return _s;
+}
+inline const std::string& Overlayable::_internal_name() const {
+  return _impl_.name_.Get();
+}
+inline void Overlayable::_internal_set_name(const std::string& value) {
+  
+  _impl_.name_.Set(value, GetArenaForAllocation());
+}
+inline std::string* Overlayable::_internal_mutable_name() {
+  
+  return _impl_.name_.Mutable(GetArenaForAllocation());
+}
+inline std::string* Overlayable::release_name() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Overlayable.name)
+  return _impl_.name_.Release();
+}
+inline void Overlayable::set_allocated_name(std::string* name) {
+  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.name_.IsDefault()) {
+    _impl_.name_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Overlayable.name)
+}
+
+// .aapt.pb.Source source = 2;
+inline bool Overlayable::_internal_has_source() const {
+  return this != internal_default_instance() && _impl_.source_ != nullptr;
+}
+inline bool Overlayable::has_source() const {
+  return _internal_has_source();
+}
+inline void Overlayable::clear_source() {
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+}
+inline const ::aapt::pb::Source& Overlayable::_internal_source() const {
+  const ::aapt::pb::Source* p = _impl_.source_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
+      ::aapt::pb::_Source_default_instance_);
+}
+inline const ::aapt::pb::Source& Overlayable::source() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Overlayable.source)
+  return _internal_source();
+}
+inline void Overlayable::unsafe_arena_set_allocated_source(
+    ::aapt::pb::Source* source) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Overlayable.source)
+}
+inline ::aapt::pb::Source* Overlayable::release_source() {
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Source* Overlayable::unsafe_arena_release_source() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Overlayable.source)
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Source* Overlayable::_internal_mutable_source() {
+  
+  if (_impl_.source_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
+    _impl_.source_ = p;
+  }
+  return _impl_.source_;
+}
+inline ::aapt::pb::Source* Overlayable::mutable_source() {
+  ::aapt::pb::Source* _msg = _internal_mutable_source();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Overlayable.source)
+  return _msg;
+}
+inline void Overlayable::set_allocated_source(::aapt::pb::Source* source) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.source_;
+  }
+  if (source) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
+    if (message_arena != submessage_arena) {
+      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, source, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Overlayable.source)
+}
+
+// string actor = 3;
+inline void Overlayable::clear_actor() {
+  _impl_.actor_.ClearToEmpty();
+}
+inline const std::string& Overlayable::actor() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Overlayable.actor)
+  return _internal_actor();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void Overlayable::set_actor(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.actor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.Overlayable.actor)
+}
+inline std::string* Overlayable::mutable_actor() {
+  std::string* _s = _internal_mutable_actor();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Overlayable.actor)
+  return _s;
+}
+inline const std::string& Overlayable::_internal_actor() const {
+  return _impl_.actor_.Get();
+}
+inline void Overlayable::_internal_set_actor(const std::string& value) {
+  
+  _impl_.actor_.Set(value, GetArenaForAllocation());
+}
+inline std::string* Overlayable::_internal_mutable_actor() {
+  
+  return _impl_.actor_.Mutable(GetArenaForAllocation());
+}
+inline std::string* Overlayable::release_actor() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Overlayable.actor)
+  return _impl_.actor_.Release();
+}
+inline void Overlayable::set_allocated_actor(std::string* actor) {
+  _impl_.actor_.SetAllocated(actor, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.actor_.IsDefault()) {
+    _impl_.actor_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Overlayable.actor)
+}
+
+// -------------------------------------------------------------------
+
+// OverlayableItem
+
+// .aapt.pb.Source source = 1;
+inline bool OverlayableItem::_internal_has_source() const {
+  return this != internal_default_instance() && _impl_.source_ != nullptr;
+}
+inline bool OverlayableItem::has_source() const {
+  return _internal_has_source();
+}
+inline void OverlayableItem::clear_source() {
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+}
+inline const ::aapt::pb::Source& OverlayableItem::_internal_source() const {
+  const ::aapt::pb::Source* p = _impl_.source_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
+      ::aapt::pb::_Source_default_instance_);
+}
+inline const ::aapt::pb::Source& OverlayableItem::source() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.OverlayableItem.source)
+  return _internal_source();
+}
+inline void OverlayableItem::unsafe_arena_set_allocated_source(
+    ::aapt::pb::Source* source) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.OverlayableItem.source)
+}
+inline ::aapt::pb::Source* OverlayableItem::release_source() {
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Source* OverlayableItem::unsafe_arena_release_source() {
+  // @@protoc_insertion_point(field_release:aapt.pb.OverlayableItem.source)
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Source* OverlayableItem::_internal_mutable_source() {
+  
+  if (_impl_.source_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
+    _impl_.source_ = p;
+  }
+  return _impl_.source_;
+}
+inline ::aapt::pb::Source* OverlayableItem::mutable_source() {
+  ::aapt::pb::Source* _msg = _internal_mutable_source();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.OverlayableItem.source)
+  return _msg;
+}
+inline void OverlayableItem::set_allocated_source(::aapt::pb::Source* source) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.source_;
+  }
+  if (source) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
+    if (message_arena != submessage_arena) {
+      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, source, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.OverlayableItem.source)
+}
+
+// string comment = 2;
+inline void OverlayableItem::clear_comment() {
+  _impl_.comment_.ClearToEmpty();
+}
+inline const std::string& OverlayableItem::comment() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.OverlayableItem.comment)
+  return _internal_comment();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void OverlayableItem::set_comment(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.OverlayableItem.comment)
+}
+inline std::string* OverlayableItem::mutable_comment() {
+  std::string* _s = _internal_mutable_comment();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.OverlayableItem.comment)
+  return _s;
+}
+inline const std::string& OverlayableItem::_internal_comment() const {
+  return _impl_.comment_.Get();
+}
+inline void OverlayableItem::_internal_set_comment(const std::string& value) {
+  
+  _impl_.comment_.Set(value, GetArenaForAllocation());
+}
+inline std::string* OverlayableItem::_internal_mutable_comment() {
+  
+  return _impl_.comment_.Mutable(GetArenaForAllocation());
+}
+inline std::string* OverlayableItem::release_comment() {
+  // @@protoc_insertion_point(field_release:aapt.pb.OverlayableItem.comment)
+  return _impl_.comment_.Release();
+}
+inline void OverlayableItem::set_allocated_comment(std::string* comment) {
+  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.comment_.IsDefault()) {
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.OverlayableItem.comment)
+}
+
+// repeated .aapt.pb.OverlayableItem.Policy policy = 3;
+inline int OverlayableItem::_internal_policy_size() const {
+  return _impl_.policy_.size();
+}
+inline int OverlayableItem::policy_size() const {
+  return _internal_policy_size();
+}
+inline void OverlayableItem::clear_policy() {
+  _impl_.policy_.Clear();
+}
+inline ::aapt::pb::OverlayableItem_Policy OverlayableItem::_internal_policy(int index) const {
+  return static_cast< ::aapt::pb::OverlayableItem_Policy >(_impl_.policy_.Get(index));
+}
+inline ::aapt::pb::OverlayableItem_Policy OverlayableItem::policy(int index) const {
+  // @@protoc_insertion_point(field_get:aapt.pb.OverlayableItem.policy)
+  return _internal_policy(index);
+}
+inline void OverlayableItem::set_policy(int index, ::aapt::pb::OverlayableItem_Policy value) {
+  _impl_.policy_.Set(index, value);
+  // @@protoc_insertion_point(field_set:aapt.pb.OverlayableItem.policy)
+}
+inline void OverlayableItem::_internal_add_policy(::aapt::pb::OverlayableItem_Policy value) {
+  _impl_.policy_.Add(value);
+}
+inline void OverlayableItem::add_policy(::aapt::pb::OverlayableItem_Policy value) {
+  _internal_add_policy(value);
+  // @@protoc_insertion_point(field_add:aapt.pb.OverlayableItem.policy)
+}
+inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
+OverlayableItem::policy() const {
+  // @@protoc_insertion_point(field_list:aapt.pb.OverlayableItem.policy)
+  return _impl_.policy_;
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
+OverlayableItem::_internal_mutable_policy() {
+  return &_impl_.policy_;
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
+OverlayableItem::mutable_policy() {
+  // @@protoc_insertion_point(field_mutable_list:aapt.pb.OverlayableItem.policy)
+  return _internal_mutable_policy();
+}
+
+// uint32 overlayable_idx = 4;
+inline void OverlayableItem::clear_overlayable_idx() {
+  _impl_.overlayable_idx_ = 0u;
+}
+inline ::uint32_t OverlayableItem::_internal_overlayable_idx() const {
+  return _impl_.overlayable_idx_;
+}
+inline ::uint32_t OverlayableItem::overlayable_idx() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.OverlayableItem.overlayable_idx)
+  return _internal_overlayable_idx();
+}
+inline void OverlayableItem::_internal_set_overlayable_idx(::uint32_t value) {
+  
+  _impl_.overlayable_idx_ = value;
+}
+inline void OverlayableItem::set_overlayable_idx(::uint32_t value) {
+  _internal_set_overlayable_idx(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.OverlayableItem.overlayable_idx)
+}
+
+// -------------------------------------------------------------------
+
+// StagedId
+
+// .aapt.pb.Source source = 1;
+inline bool StagedId::_internal_has_source() const {
+  return this != internal_default_instance() && _impl_.source_ != nullptr;
+}
+inline bool StagedId::has_source() const {
+  return _internal_has_source();
+}
+inline void StagedId::clear_source() {
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+}
+inline const ::aapt::pb::Source& StagedId::_internal_source() const {
+  const ::aapt::pb::Source* p = _impl_.source_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
+      ::aapt::pb::_Source_default_instance_);
+}
+inline const ::aapt::pb::Source& StagedId::source() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.StagedId.source)
+  return _internal_source();
+}
+inline void StagedId::unsafe_arena_set_allocated_source(
+    ::aapt::pb::Source* source) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.StagedId.source)
+}
+inline ::aapt::pb::Source* StagedId::release_source() {
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Source* StagedId::unsafe_arena_release_source() {
+  // @@protoc_insertion_point(field_release:aapt.pb.StagedId.source)
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Source* StagedId::_internal_mutable_source() {
+  
+  if (_impl_.source_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
+    _impl_.source_ = p;
+  }
+  return _impl_.source_;
+}
+inline ::aapt::pb::Source* StagedId::mutable_source() {
+  ::aapt::pb::Source* _msg = _internal_mutable_source();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.StagedId.source)
+  return _msg;
+}
+inline void StagedId::set_allocated_source(::aapt::pb::Source* source) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.source_;
+  }
+  if (source) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
+    if (message_arena != submessage_arena) {
+      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, source, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.StagedId.source)
+}
+
+// uint32 staged_id = 2;
+inline void StagedId::clear_staged_id() {
+  _impl_.staged_id_ = 0u;
+}
+inline ::uint32_t StagedId::_internal_staged_id() const {
+  return _impl_.staged_id_;
+}
+inline ::uint32_t StagedId::staged_id() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.StagedId.staged_id)
+  return _internal_staged_id();
+}
+inline void StagedId::_internal_set_staged_id(::uint32_t value) {
+  
+  _impl_.staged_id_ = value;
+}
+inline void StagedId::set_staged_id(::uint32_t value) {
+  _internal_set_staged_id(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.StagedId.staged_id)
+}
+
+// -------------------------------------------------------------------
+
+// EntryId
+
+// uint32 id = 1;
+inline void EntryId::clear_id() {
+  _impl_.id_ = 0u;
+}
+inline ::uint32_t EntryId::_internal_id() const {
+  return _impl_.id_;
+}
+inline ::uint32_t EntryId::id() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.EntryId.id)
+  return _internal_id();
+}
+inline void EntryId::_internal_set_id(::uint32_t value) {
+  
+  _impl_.id_ = value;
+}
+inline void EntryId::set_id(::uint32_t value) {
+  _internal_set_id(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.EntryId.id)
+}
+
+// -------------------------------------------------------------------
+
+// Entry
+
+// .aapt.pb.EntryId entry_id = 1;
+inline bool Entry::_internal_has_entry_id() const {
+  return this != internal_default_instance() && _impl_.entry_id_ != nullptr;
+}
+inline bool Entry::has_entry_id() const {
+  return _internal_has_entry_id();
+}
+inline void Entry::clear_entry_id() {
+  if (GetArenaForAllocation() == nullptr && _impl_.entry_id_ != nullptr) {
+    delete _impl_.entry_id_;
+  }
+  _impl_.entry_id_ = nullptr;
+}
+inline const ::aapt::pb::EntryId& Entry::_internal_entry_id() const {
+  const ::aapt::pb::EntryId* p = _impl_.entry_id_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::EntryId&>(
+      ::aapt::pb::_EntryId_default_instance_);
+}
+inline const ::aapt::pb::EntryId& Entry::entry_id() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Entry.entry_id)
+  return _internal_entry_id();
+}
+inline void Entry::unsafe_arena_set_allocated_entry_id(
+    ::aapt::pb::EntryId* entry_id) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.entry_id_);
+  }
+  _impl_.entry_id_ = entry_id;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Entry.entry_id)
+}
+inline ::aapt::pb::EntryId* Entry::release_entry_id() {
+  
+  ::aapt::pb::EntryId* temp = _impl_.entry_id_;
+  _impl_.entry_id_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::EntryId* Entry::unsafe_arena_release_entry_id() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Entry.entry_id)
+  
+  ::aapt::pb::EntryId* temp = _impl_.entry_id_;
+  _impl_.entry_id_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::EntryId* Entry::_internal_mutable_entry_id() {
+  
+  if (_impl_.entry_id_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::EntryId>(GetArenaForAllocation());
+    _impl_.entry_id_ = p;
+  }
+  return _impl_.entry_id_;
+}
+inline ::aapt::pb::EntryId* Entry::mutable_entry_id() {
+  ::aapt::pb::EntryId* _msg = _internal_mutable_entry_id();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.entry_id)
+  return _msg;
+}
+inline void Entry::set_allocated_entry_id(::aapt::pb::EntryId* entry_id) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.entry_id_;
+  }
+  if (entry_id) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(entry_id);
+    if (message_arena != submessage_arena) {
+      entry_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, entry_id, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.entry_id_ = entry_id;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Entry.entry_id)
+}
+
+// string name = 2;
+inline void Entry::clear_name() {
+  _impl_.name_.ClearToEmpty();
+}
+inline const std::string& Entry::name() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Entry.name)
+  return _internal_name();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void Entry::set_name(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.Entry.name)
+}
+inline std::string* Entry::mutable_name() {
+  std::string* _s = _internal_mutable_name();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.name)
+  return _s;
+}
+inline const std::string& Entry::_internal_name() const {
+  return _impl_.name_.Get();
+}
+inline void Entry::_internal_set_name(const std::string& value) {
+  
+  _impl_.name_.Set(value, GetArenaForAllocation());
+}
+inline std::string* Entry::_internal_mutable_name() {
+  
+  return _impl_.name_.Mutable(GetArenaForAllocation());
+}
+inline std::string* Entry::release_name() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Entry.name)
+  return _impl_.name_.Release();
+}
+inline void Entry::set_allocated_name(std::string* name) {
+  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.name_.IsDefault()) {
+    _impl_.name_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Entry.name)
+}
+
+// .aapt.pb.Visibility visibility = 3;
+inline bool Entry::_internal_has_visibility() const {
+  return this != internal_default_instance() && _impl_.visibility_ != nullptr;
+}
+inline bool Entry::has_visibility() const {
+  return _internal_has_visibility();
+}
+inline void Entry::clear_visibility() {
+  if (GetArenaForAllocation() == nullptr && _impl_.visibility_ != nullptr) {
+    delete _impl_.visibility_;
+  }
+  _impl_.visibility_ = nullptr;
+}
+inline const ::aapt::pb::Visibility& Entry::_internal_visibility() const {
+  const ::aapt::pb::Visibility* p = _impl_.visibility_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Visibility&>(
+      ::aapt::pb::_Visibility_default_instance_);
+}
+inline const ::aapt::pb::Visibility& Entry::visibility() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Entry.visibility)
+  return _internal_visibility();
+}
+inline void Entry::unsafe_arena_set_allocated_visibility(
+    ::aapt::pb::Visibility* visibility) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_);
+  }
+  _impl_.visibility_ = visibility;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Entry.visibility)
+}
+inline ::aapt::pb::Visibility* Entry::release_visibility() {
+  
+  ::aapt::pb::Visibility* temp = _impl_.visibility_;
+  _impl_.visibility_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Visibility* Entry::unsafe_arena_release_visibility() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Entry.visibility)
+  
+  ::aapt::pb::Visibility* temp = _impl_.visibility_;
+  _impl_.visibility_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Visibility* Entry::_internal_mutable_visibility() {
+  
+  if (_impl_.visibility_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Visibility>(GetArenaForAllocation());
+    _impl_.visibility_ = p;
+  }
+  return _impl_.visibility_;
+}
+inline ::aapt::pb::Visibility* Entry::mutable_visibility() {
+  ::aapt::pb::Visibility* _msg = _internal_mutable_visibility();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.visibility)
+  return _msg;
+}
+inline void Entry::set_allocated_visibility(::aapt::pb::Visibility* visibility) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.visibility_;
+  }
+  if (visibility) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visibility);
+    if (message_arena != submessage_arena) {
+      visibility = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, visibility, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.visibility_ = visibility;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Entry.visibility)
+}
+
+// .aapt.pb.AllowNew allow_new = 4;
+inline bool Entry::_internal_has_allow_new() const {
+  return this != internal_default_instance() && _impl_.allow_new_ != nullptr;
+}
+inline bool Entry::has_allow_new() const {
+  return _internal_has_allow_new();
+}
+inline void Entry::clear_allow_new() {
+  if (GetArenaForAllocation() == nullptr && _impl_.allow_new_ != nullptr) {
+    delete _impl_.allow_new_;
+  }
+  _impl_.allow_new_ = nullptr;
+}
+inline const ::aapt::pb::AllowNew& Entry::_internal_allow_new() const {
+  const ::aapt::pb::AllowNew* p = _impl_.allow_new_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::AllowNew&>(
+      ::aapt::pb::_AllowNew_default_instance_);
+}
+inline const ::aapt::pb::AllowNew& Entry::allow_new() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Entry.allow_new)
+  return _internal_allow_new();
+}
+inline void Entry::unsafe_arena_set_allocated_allow_new(
+    ::aapt::pb::AllowNew* allow_new) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.allow_new_);
+  }
+  _impl_.allow_new_ = allow_new;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Entry.allow_new)
+}
+inline ::aapt::pb::AllowNew* Entry::release_allow_new() {
+  
+  ::aapt::pb::AllowNew* temp = _impl_.allow_new_;
+  _impl_.allow_new_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::AllowNew* Entry::unsafe_arena_release_allow_new() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Entry.allow_new)
+  
+  ::aapt::pb::AllowNew* temp = _impl_.allow_new_;
+  _impl_.allow_new_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::AllowNew* Entry::_internal_mutable_allow_new() {
+  
+  if (_impl_.allow_new_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::AllowNew>(GetArenaForAllocation());
+    _impl_.allow_new_ = p;
+  }
+  return _impl_.allow_new_;
+}
+inline ::aapt::pb::AllowNew* Entry::mutable_allow_new() {
+  ::aapt::pb::AllowNew* _msg = _internal_mutable_allow_new();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.allow_new)
+  return _msg;
+}
+inline void Entry::set_allocated_allow_new(::aapt::pb::AllowNew* allow_new) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.allow_new_;
+  }
+  if (allow_new) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(allow_new);
+    if (message_arena != submessage_arena) {
+      allow_new = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, allow_new, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.allow_new_ = allow_new;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Entry.allow_new)
+}
+
+// .aapt.pb.OverlayableItem overlayable_item = 5;
+inline bool Entry::_internal_has_overlayable_item() const {
+  return this != internal_default_instance() && _impl_.overlayable_item_ != nullptr;
+}
+inline bool Entry::has_overlayable_item() const {
+  return _internal_has_overlayable_item();
+}
+inline void Entry::clear_overlayable_item() {
+  if (GetArenaForAllocation() == nullptr && _impl_.overlayable_item_ != nullptr) {
+    delete _impl_.overlayable_item_;
+  }
+  _impl_.overlayable_item_ = nullptr;
+}
+inline const ::aapt::pb::OverlayableItem& Entry::_internal_overlayable_item() const {
+  const ::aapt::pb::OverlayableItem* p = _impl_.overlayable_item_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::OverlayableItem&>(
+      ::aapt::pb::_OverlayableItem_default_instance_);
+}
+inline const ::aapt::pb::OverlayableItem& Entry::overlayable_item() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Entry.overlayable_item)
+  return _internal_overlayable_item();
+}
+inline void Entry::unsafe_arena_set_allocated_overlayable_item(
+    ::aapt::pb::OverlayableItem* overlayable_item) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.overlayable_item_);
+  }
+  _impl_.overlayable_item_ = overlayable_item;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Entry.overlayable_item)
+}
+inline ::aapt::pb::OverlayableItem* Entry::release_overlayable_item() {
+  
+  ::aapt::pb::OverlayableItem* temp = _impl_.overlayable_item_;
+  _impl_.overlayable_item_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::OverlayableItem* Entry::unsafe_arena_release_overlayable_item() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Entry.overlayable_item)
+  
+  ::aapt::pb::OverlayableItem* temp = _impl_.overlayable_item_;
+  _impl_.overlayable_item_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::OverlayableItem* Entry::_internal_mutable_overlayable_item() {
+  
+  if (_impl_.overlayable_item_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::OverlayableItem>(GetArenaForAllocation());
+    _impl_.overlayable_item_ = p;
+  }
+  return _impl_.overlayable_item_;
+}
+inline ::aapt::pb::OverlayableItem* Entry::mutable_overlayable_item() {
+  ::aapt::pb::OverlayableItem* _msg = _internal_mutable_overlayable_item();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.overlayable_item)
+  return _msg;
+}
+inline void Entry::set_allocated_overlayable_item(::aapt::pb::OverlayableItem* overlayable_item) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.overlayable_item_;
+  }
+  if (overlayable_item) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(overlayable_item);
+    if (message_arena != submessage_arena) {
+      overlayable_item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, overlayable_item, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.overlayable_item_ = overlayable_item;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Entry.overlayable_item)
+}
+
+// repeated .aapt.pb.ConfigValue config_value = 6;
+inline int Entry::_internal_config_value_size() const {
+  return _impl_.config_value_.size();
+}
+inline int Entry::config_value_size() const {
+  return _internal_config_value_size();
+}
+inline void Entry::clear_config_value() {
+  _impl_.config_value_.Clear();
+}
+inline ::aapt::pb::ConfigValue* Entry::mutable_config_value(int index) {
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.config_value)
+  return _impl_.config_value_.Mutable(index);
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::ConfigValue >*
+Entry::mutable_config_value() {
+  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Entry.config_value)
+  return &_impl_.config_value_;
+}
+inline const ::aapt::pb::ConfigValue& Entry::_internal_config_value(int index) const {
+  return _impl_.config_value_.Get(index);
+}
+inline const ::aapt::pb::ConfigValue& Entry::config_value(int index) const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Entry.config_value)
+  return _internal_config_value(index);
+}
+inline ::aapt::pb::ConfigValue* Entry::_internal_add_config_value() {
+  return _impl_.config_value_.Add();
+}
+inline ::aapt::pb::ConfigValue* Entry::add_config_value() {
+  ::aapt::pb::ConfigValue* _add = _internal_add_config_value();
+  // @@protoc_insertion_point(field_add:aapt.pb.Entry.config_value)
+  return _add;
+}
+inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::ConfigValue >&
+Entry::config_value() const {
+  // @@protoc_insertion_point(field_list:aapt.pb.Entry.config_value)
+  return _impl_.config_value_;
+}
+
+// .aapt.pb.StagedId staged_id = 7;
+inline bool Entry::_internal_has_staged_id() const {
+  return this != internal_default_instance() && _impl_.staged_id_ != nullptr;
+}
+inline bool Entry::has_staged_id() const {
+  return _internal_has_staged_id();
+}
+inline void Entry::clear_staged_id() {
+  if (GetArenaForAllocation() == nullptr && _impl_.staged_id_ != nullptr) {
+    delete _impl_.staged_id_;
+  }
+  _impl_.staged_id_ = nullptr;
+}
+inline const ::aapt::pb::StagedId& Entry::_internal_staged_id() const {
+  const ::aapt::pb::StagedId* p = _impl_.staged_id_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::StagedId&>(
+      ::aapt::pb::_StagedId_default_instance_);
+}
+inline const ::aapt::pb::StagedId& Entry::staged_id() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Entry.staged_id)
+  return _internal_staged_id();
+}
+inline void Entry::unsafe_arena_set_allocated_staged_id(
+    ::aapt::pb::StagedId* staged_id) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.staged_id_);
+  }
+  _impl_.staged_id_ = staged_id;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Entry.staged_id)
+}
+inline ::aapt::pb::StagedId* Entry::release_staged_id() {
+  
+  ::aapt::pb::StagedId* temp = _impl_.staged_id_;
+  _impl_.staged_id_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::StagedId* Entry::unsafe_arena_release_staged_id() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Entry.staged_id)
+  
+  ::aapt::pb::StagedId* temp = _impl_.staged_id_;
+  _impl_.staged_id_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::StagedId* Entry::_internal_mutable_staged_id() {
+  
+  if (_impl_.staged_id_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::StagedId>(GetArenaForAllocation());
+    _impl_.staged_id_ = p;
+  }
+  return _impl_.staged_id_;
+}
+inline ::aapt::pb::StagedId* Entry::mutable_staged_id() {
+  ::aapt::pb::StagedId* _msg = _internal_mutable_staged_id();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.staged_id)
+  return _msg;
+}
+inline void Entry::set_allocated_staged_id(::aapt::pb::StagedId* staged_id) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.staged_id_;
+  }
+  if (staged_id) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(staged_id);
+    if (message_arena != submessage_arena) {
+      staged_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, staged_id, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.staged_id_ = staged_id;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Entry.staged_id)
+}
+
+// -------------------------------------------------------------------
+
+// ConfigValue
+
+// .aapt.pb.Configuration config = 1;
+inline bool ConfigValue::_internal_has_config() const {
+  return this != internal_default_instance() && _impl_.config_ != nullptr;
+}
+inline bool ConfigValue::has_config() const {
+  return _internal_has_config();
+}
+inline const ::aapt::pb::Configuration& ConfigValue::_internal_config() const {
+  const ::aapt::pb::Configuration* p = _impl_.config_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Configuration&>(
+      ::aapt::pb::_Configuration_default_instance_);
+}
+inline const ::aapt::pb::Configuration& ConfigValue::config() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.ConfigValue.config)
+  return _internal_config();
+}
+inline void ConfigValue::unsafe_arena_set_allocated_config(
+    ::aapt::pb::Configuration* config) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
+  }
+  _impl_.config_ = config;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.ConfigValue.config)
+}
+inline ::aapt::pb::Configuration* ConfigValue::release_config() {
+  
+  ::aapt::pb::Configuration* temp = _impl_.config_;
+  _impl_.config_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Configuration* ConfigValue::unsafe_arena_release_config() {
+  // @@protoc_insertion_point(field_release:aapt.pb.ConfigValue.config)
+  
+  ::aapt::pb::Configuration* temp = _impl_.config_;
+  _impl_.config_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Configuration* ConfigValue::_internal_mutable_config() {
+  
+  if (_impl_.config_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Configuration>(GetArenaForAllocation());
+    _impl_.config_ = p;
+  }
+  return _impl_.config_;
+}
+inline ::aapt::pb::Configuration* ConfigValue::mutable_config() {
+  ::aapt::pb::Configuration* _msg = _internal_mutable_config();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.ConfigValue.config)
+  return _msg;
+}
+inline void ConfigValue::set_allocated_config(::aapt::pb::Configuration* config) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
+  }
+  if (config) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
+                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config));
+    if (message_arena != submessage_arena) {
+      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, config, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.config_ = config;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ConfigValue.config)
+}
+
+// .aapt.pb.Value value = 2;
+inline bool ConfigValue::_internal_has_value() const {
+  return this != internal_default_instance() && _impl_.value_ != nullptr;
+}
+inline bool ConfigValue::has_value() const {
+  return _internal_has_value();
+}
+inline void ConfigValue::clear_value() {
+  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
+    delete _impl_.value_;
+  }
+  _impl_.value_ = nullptr;
+}
+inline const ::aapt::pb::Value& ConfigValue::_internal_value() const {
+  const ::aapt::pb::Value* p = _impl_.value_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Value&>(
+      ::aapt::pb::_Value_default_instance_);
+}
+inline const ::aapt::pb::Value& ConfigValue::value() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.ConfigValue.value)
+  return _internal_value();
+}
+inline void ConfigValue::unsafe_arena_set_allocated_value(
+    ::aapt::pb::Value* value) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
+  }
+  _impl_.value_ = value;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.ConfigValue.value)
+}
+inline ::aapt::pb::Value* ConfigValue::release_value() {
+  
+  ::aapt::pb::Value* temp = _impl_.value_;
+  _impl_.value_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Value* ConfigValue::unsafe_arena_release_value() {
+  // @@protoc_insertion_point(field_release:aapt.pb.ConfigValue.value)
+  
+  ::aapt::pb::Value* temp = _impl_.value_;
+  _impl_.value_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Value* ConfigValue::_internal_mutable_value() {
+  
+  if (_impl_.value_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Value>(GetArenaForAllocation());
+    _impl_.value_ = p;
+  }
+  return _impl_.value_;
+}
+inline ::aapt::pb::Value* ConfigValue::mutable_value() {
+  ::aapt::pb::Value* _msg = _internal_mutable_value();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.ConfigValue.value)
+  return _msg;
+}
+inline void ConfigValue::set_allocated_value(::aapt::pb::Value* value) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.value_;
+  }
+  if (value) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
+    if (message_arena != submessage_arena) {
+      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, value, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.value_ = value;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ConfigValue.value)
+}
+
+// -------------------------------------------------------------------
+
+// Value
+
+// .aapt.pb.Source source = 1;
+inline bool Value::_internal_has_source() const {
+  return this != internal_default_instance() && _impl_.source_ != nullptr;
+}
+inline bool Value::has_source() const {
+  return _internal_has_source();
+}
+inline void Value::clear_source() {
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+}
+inline const ::aapt::pb::Source& Value::_internal_source() const {
+  const ::aapt::pb::Source* p = _impl_.source_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
+      ::aapt::pb::_Source_default_instance_);
+}
+inline const ::aapt::pb::Source& Value::source() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Value.source)
+  return _internal_source();
+}
+inline void Value::unsafe_arena_set_allocated_source(
+    ::aapt::pb::Source* source) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Value.source)
+}
+inline ::aapt::pb::Source* Value::release_source() {
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Source* Value::unsafe_arena_release_source() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Value.source)
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Source* Value::_internal_mutable_source() {
+  
+  if (_impl_.source_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
+    _impl_.source_ = p;
+  }
+  return _impl_.source_;
+}
+inline ::aapt::pb::Source* Value::mutable_source() {
+  ::aapt::pb::Source* _msg = _internal_mutable_source();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Value.source)
+  return _msg;
+}
+inline void Value::set_allocated_source(::aapt::pb::Source* source) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.source_;
+  }
+  if (source) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
+    if (message_arena != submessage_arena) {
+      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, source, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Value.source)
+}
+
+// string comment = 2;
+inline void Value::clear_comment() {
+  _impl_.comment_.ClearToEmpty();
+}
+inline const std::string& Value::comment() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Value.comment)
+  return _internal_comment();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void Value::set_comment(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.Value.comment)
+}
+inline std::string* Value::mutable_comment() {
+  std::string* _s = _internal_mutable_comment();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Value.comment)
+  return _s;
+}
+inline const std::string& Value::_internal_comment() const {
+  return _impl_.comment_.Get();
+}
+inline void Value::_internal_set_comment(const std::string& value) {
+  
+  _impl_.comment_.Set(value, GetArenaForAllocation());
+}
+inline std::string* Value::_internal_mutable_comment() {
+  
+  return _impl_.comment_.Mutable(GetArenaForAllocation());
+}
+inline std::string* Value::release_comment() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Value.comment)
+  return _impl_.comment_.Release();
+}
+inline void Value::set_allocated_comment(std::string* comment) {
+  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.comment_.IsDefault()) {
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Value.comment)
+}
+
+// bool weak = 3;
+inline void Value::clear_weak() {
+  _impl_.weak_ = false;
+}
+inline bool Value::_internal_weak() const {
+  return _impl_.weak_;
+}
+inline bool Value::weak() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Value.weak)
+  return _internal_weak();
+}
+inline void Value::_internal_set_weak(bool value) {
+  
+  _impl_.weak_ = value;
+}
+inline void Value::set_weak(bool value) {
+  _internal_set_weak(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Value.weak)
+}
+
+// .aapt.pb.Item item = 4;
+inline bool Value::_internal_has_item() const {
+  return value_case() == kItem;
+}
+inline bool Value::has_item() const {
+  return _internal_has_item();
+}
+inline void Value::set_has_item() {
+  _impl_._oneof_case_[0] = kItem;
+}
+inline void Value::clear_item() {
+  if (_internal_has_item()) {
+    if (GetArenaForAllocation() == nullptr) {
+      delete _impl_.value_.item_;
+    }
+    clear_has_value();
+  }
+}
+inline ::aapt::pb::Item* Value::release_item() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Value.item)
+  if (_internal_has_item()) {
+    clear_has_value();
+    ::aapt::pb::Item* temp = _impl_.value_.item_;
+    if (GetArenaForAllocation() != nullptr) {
+      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+    }
+    _impl_.value_.item_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline const ::aapt::pb::Item& Value::_internal_item() const {
+  return _internal_has_item()
+      ? *_impl_.value_.item_
+      : reinterpret_cast< ::aapt::pb::Item&>(::aapt::pb::_Item_default_instance_);
+}
+inline const ::aapt::pb::Item& Value::item() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Value.item)
+  return _internal_item();
+}
+inline ::aapt::pb::Item* Value::unsafe_arena_release_item() {
+  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Value.item)
+  if (_internal_has_item()) {
+    clear_has_value();
+    ::aapt::pb::Item* temp = _impl_.value_.item_;
+    _impl_.value_.item_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline void Value::unsafe_arena_set_allocated_item(::aapt::pb::Item* item) {
+  clear_value();
+  if (item) {
+    set_has_item();
+    _impl_.value_.item_ = item;
+  }
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Value.item)
+}
+inline ::aapt::pb::Item* Value::_internal_mutable_item() {
+  if (!_internal_has_item()) {
+    clear_value();
+    set_has_item();
+    _impl_.value_.item_ = CreateMaybeMessage< ::aapt::pb::Item >(GetArenaForAllocation());
+  }
+  return _impl_.value_.item_;
+}
+inline ::aapt::pb::Item* Value::mutable_item() {
+  ::aapt::pb::Item* _msg = _internal_mutable_item();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Value.item)
+  return _msg;
+}
+
+// .aapt.pb.CompoundValue compound_value = 5;
+inline bool Value::_internal_has_compound_value() const {
+  return value_case() == kCompoundValue;
+}
+inline bool Value::has_compound_value() const {
+  return _internal_has_compound_value();
+}
+inline void Value::set_has_compound_value() {
+  _impl_._oneof_case_[0] = kCompoundValue;
+}
+inline void Value::clear_compound_value() {
+  if (_internal_has_compound_value()) {
+    if (GetArenaForAllocation() == nullptr) {
+      delete _impl_.value_.compound_value_;
+    }
+    clear_has_value();
+  }
+}
+inline ::aapt::pb::CompoundValue* Value::release_compound_value() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Value.compound_value)
+  if (_internal_has_compound_value()) {
+    clear_has_value();
+    ::aapt::pb::CompoundValue* temp = _impl_.value_.compound_value_;
+    if (GetArenaForAllocation() != nullptr) {
+      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+    }
+    _impl_.value_.compound_value_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline const ::aapt::pb::CompoundValue& Value::_internal_compound_value() const {
+  return _internal_has_compound_value()
+      ? *_impl_.value_.compound_value_
+      : reinterpret_cast< ::aapt::pb::CompoundValue&>(::aapt::pb::_CompoundValue_default_instance_);
+}
+inline const ::aapt::pb::CompoundValue& Value::compound_value() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Value.compound_value)
+  return _internal_compound_value();
+}
+inline ::aapt::pb::CompoundValue* Value::unsafe_arena_release_compound_value() {
+  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Value.compound_value)
+  if (_internal_has_compound_value()) {
+    clear_has_value();
+    ::aapt::pb::CompoundValue* temp = _impl_.value_.compound_value_;
+    _impl_.value_.compound_value_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline void Value::unsafe_arena_set_allocated_compound_value(::aapt::pb::CompoundValue* compound_value) {
+  clear_value();
+  if (compound_value) {
+    set_has_compound_value();
+    _impl_.value_.compound_value_ = compound_value;
+  }
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Value.compound_value)
+}
+inline ::aapt::pb::CompoundValue* Value::_internal_mutable_compound_value() {
+  if (!_internal_has_compound_value()) {
+    clear_value();
+    set_has_compound_value();
+    _impl_.value_.compound_value_ = CreateMaybeMessage< ::aapt::pb::CompoundValue >(GetArenaForAllocation());
+  }
+  return _impl_.value_.compound_value_;
+}
+inline ::aapt::pb::CompoundValue* Value::mutable_compound_value() {
+  ::aapt::pb::CompoundValue* _msg = _internal_mutable_compound_value();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Value.compound_value)
+  return _msg;
+}
+
+inline bool Value::has_value() const {
+  return value_case() != VALUE_NOT_SET;
+}
+inline void Value::clear_has_value() {
+  _impl_._oneof_case_[0] = VALUE_NOT_SET;
+}
+inline Value::ValueCase Value::value_case() const {
+  return Value::ValueCase(_impl_._oneof_case_[0]);
+}
+// -------------------------------------------------------------------
+
+// Item
+
+// .aapt.pb.Reference ref = 1;
+inline bool Item::_internal_has_ref() const {
+  return value_case() == kRef;
+}
+inline bool Item::has_ref() const {
+  return _internal_has_ref();
+}
+inline void Item::set_has_ref() {
+  _impl_._oneof_case_[0] = kRef;
+}
+inline void Item::clear_ref() {
+  if (_internal_has_ref()) {
+    if (GetArenaForAllocation() == nullptr) {
+      delete _impl_.value_.ref_;
+    }
+    clear_has_value();
+  }
+}
+inline ::aapt::pb::Reference* Item::release_ref() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Item.ref)
+  if (_internal_has_ref()) {
+    clear_has_value();
+    ::aapt::pb::Reference* temp = _impl_.value_.ref_;
+    if (GetArenaForAllocation() != nullptr) {
+      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+    }
+    _impl_.value_.ref_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline const ::aapt::pb::Reference& Item::_internal_ref() const {
+  return _internal_has_ref()
+      ? *_impl_.value_.ref_
+      : reinterpret_cast< ::aapt::pb::Reference&>(::aapt::pb::_Reference_default_instance_);
+}
+inline const ::aapt::pb::Reference& Item::ref() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Item.ref)
+  return _internal_ref();
+}
+inline ::aapt::pb::Reference* Item::unsafe_arena_release_ref() {
+  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Item.ref)
+  if (_internal_has_ref()) {
+    clear_has_value();
+    ::aapt::pb::Reference* temp = _impl_.value_.ref_;
+    _impl_.value_.ref_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline void Item::unsafe_arena_set_allocated_ref(::aapt::pb::Reference* ref) {
+  clear_value();
+  if (ref) {
+    set_has_ref();
+    _impl_.value_.ref_ = ref;
+  }
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Item.ref)
+}
+inline ::aapt::pb::Reference* Item::_internal_mutable_ref() {
+  if (!_internal_has_ref()) {
+    clear_value();
+    set_has_ref();
+    _impl_.value_.ref_ = CreateMaybeMessage< ::aapt::pb::Reference >(GetArenaForAllocation());
+  }
+  return _impl_.value_.ref_;
+}
+inline ::aapt::pb::Reference* Item::mutable_ref() {
+  ::aapt::pb::Reference* _msg = _internal_mutable_ref();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.ref)
+  return _msg;
+}
+
+// .aapt.pb.String str = 2;
+inline bool Item::_internal_has_str() const {
+  return value_case() == kStr;
+}
+inline bool Item::has_str() const {
+  return _internal_has_str();
+}
+inline void Item::set_has_str() {
+  _impl_._oneof_case_[0] = kStr;
+}
+inline void Item::clear_str() {
+  if (_internal_has_str()) {
+    if (GetArenaForAllocation() == nullptr) {
+      delete _impl_.value_.str_;
+    }
+    clear_has_value();
+  }
+}
+inline ::aapt::pb::String* Item::release_str() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Item.str)
+  if (_internal_has_str()) {
+    clear_has_value();
+    ::aapt::pb::String* temp = _impl_.value_.str_;
+    if (GetArenaForAllocation() != nullptr) {
+      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+    }
+    _impl_.value_.str_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline const ::aapt::pb::String& Item::_internal_str() const {
+  return _internal_has_str()
+      ? *_impl_.value_.str_
+      : reinterpret_cast< ::aapt::pb::String&>(::aapt::pb::_String_default_instance_);
+}
+inline const ::aapt::pb::String& Item::str() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Item.str)
+  return _internal_str();
+}
+inline ::aapt::pb::String* Item::unsafe_arena_release_str() {
+  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Item.str)
+  if (_internal_has_str()) {
+    clear_has_value();
+    ::aapt::pb::String* temp = _impl_.value_.str_;
+    _impl_.value_.str_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline void Item::unsafe_arena_set_allocated_str(::aapt::pb::String* str) {
+  clear_value();
+  if (str) {
+    set_has_str();
+    _impl_.value_.str_ = str;
+  }
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Item.str)
+}
+inline ::aapt::pb::String* Item::_internal_mutable_str() {
+  if (!_internal_has_str()) {
+    clear_value();
+    set_has_str();
+    _impl_.value_.str_ = CreateMaybeMessage< ::aapt::pb::String >(GetArenaForAllocation());
+  }
+  return _impl_.value_.str_;
+}
+inline ::aapt::pb::String* Item::mutable_str() {
+  ::aapt::pb::String* _msg = _internal_mutable_str();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.str)
+  return _msg;
+}
+
+// .aapt.pb.RawString raw_str = 3;
+inline bool Item::_internal_has_raw_str() const {
+  return value_case() == kRawStr;
+}
+inline bool Item::has_raw_str() const {
+  return _internal_has_raw_str();
+}
+inline void Item::set_has_raw_str() {
+  _impl_._oneof_case_[0] = kRawStr;
+}
+inline void Item::clear_raw_str() {
+  if (_internal_has_raw_str()) {
+    if (GetArenaForAllocation() == nullptr) {
+      delete _impl_.value_.raw_str_;
+    }
+    clear_has_value();
+  }
+}
+inline ::aapt::pb::RawString* Item::release_raw_str() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Item.raw_str)
+  if (_internal_has_raw_str()) {
+    clear_has_value();
+    ::aapt::pb::RawString* temp = _impl_.value_.raw_str_;
+    if (GetArenaForAllocation() != nullptr) {
+      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+    }
+    _impl_.value_.raw_str_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline const ::aapt::pb::RawString& Item::_internal_raw_str() const {
+  return _internal_has_raw_str()
+      ? *_impl_.value_.raw_str_
+      : reinterpret_cast< ::aapt::pb::RawString&>(::aapt::pb::_RawString_default_instance_);
+}
+inline const ::aapt::pb::RawString& Item::raw_str() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Item.raw_str)
+  return _internal_raw_str();
+}
+inline ::aapt::pb::RawString* Item::unsafe_arena_release_raw_str() {
+  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Item.raw_str)
+  if (_internal_has_raw_str()) {
+    clear_has_value();
+    ::aapt::pb::RawString* temp = _impl_.value_.raw_str_;
+    _impl_.value_.raw_str_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline void Item::unsafe_arena_set_allocated_raw_str(::aapt::pb::RawString* raw_str) {
+  clear_value();
+  if (raw_str) {
+    set_has_raw_str();
+    _impl_.value_.raw_str_ = raw_str;
+  }
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Item.raw_str)
+}
+inline ::aapt::pb::RawString* Item::_internal_mutable_raw_str() {
+  if (!_internal_has_raw_str()) {
+    clear_value();
+    set_has_raw_str();
+    _impl_.value_.raw_str_ = CreateMaybeMessage< ::aapt::pb::RawString >(GetArenaForAllocation());
+  }
+  return _impl_.value_.raw_str_;
+}
+inline ::aapt::pb::RawString* Item::mutable_raw_str() {
+  ::aapt::pb::RawString* _msg = _internal_mutable_raw_str();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.raw_str)
+  return _msg;
+}
+
+// .aapt.pb.StyledString styled_str = 4;
+inline bool Item::_internal_has_styled_str() const {
+  return value_case() == kStyledStr;
+}
+inline bool Item::has_styled_str() const {
+  return _internal_has_styled_str();
+}
+inline void Item::set_has_styled_str() {
+  _impl_._oneof_case_[0] = kStyledStr;
+}
+inline void Item::clear_styled_str() {
+  if (_internal_has_styled_str()) {
+    if (GetArenaForAllocation() == nullptr) {
+      delete _impl_.value_.styled_str_;
+    }
+    clear_has_value();
+  }
+}
+inline ::aapt::pb::StyledString* Item::release_styled_str() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Item.styled_str)
+  if (_internal_has_styled_str()) {
+    clear_has_value();
+    ::aapt::pb::StyledString* temp = _impl_.value_.styled_str_;
+    if (GetArenaForAllocation() != nullptr) {
+      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+    }
+    _impl_.value_.styled_str_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline const ::aapt::pb::StyledString& Item::_internal_styled_str() const {
+  return _internal_has_styled_str()
+      ? *_impl_.value_.styled_str_
+      : reinterpret_cast< ::aapt::pb::StyledString&>(::aapt::pb::_StyledString_default_instance_);
+}
+inline const ::aapt::pb::StyledString& Item::styled_str() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Item.styled_str)
+  return _internal_styled_str();
+}
+inline ::aapt::pb::StyledString* Item::unsafe_arena_release_styled_str() {
+  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Item.styled_str)
+  if (_internal_has_styled_str()) {
+    clear_has_value();
+    ::aapt::pb::StyledString* temp = _impl_.value_.styled_str_;
+    _impl_.value_.styled_str_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline void Item::unsafe_arena_set_allocated_styled_str(::aapt::pb::StyledString* styled_str) {
+  clear_value();
+  if (styled_str) {
+    set_has_styled_str();
+    _impl_.value_.styled_str_ = styled_str;
+  }
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Item.styled_str)
+}
+inline ::aapt::pb::StyledString* Item::_internal_mutable_styled_str() {
+  if (!_internal_has_styled_str()) {
+    clear_value();
+    set_has_styled_str();
+    _impl_.value_.styled_str_ = CreateMaybeMessage< ::aapt::pb::StyledString >(GetArenaForAllocation());
+  }
+  return _impl_.value_.styled_str_;
+}
+inline ::aapt::pb::StyledString* Item::mutable_styled_str() {
+  ::aapt::pb::StyledString* _msg = _internal_mutable_styled_str();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.styled_str)
+  return _msg;
+}
+
+// .aapt.pb.FileReference file = 5;
+inline bool Item::_internal_has_file() const {
+  return value_case() == kFile;
+}
+inline bool Item::has_file() const {
+  return _internal_has_file();
+}
+inline void Item::set_has_file() {
+  _impl_._oneof_case_[0] = kFile;
+}
+inline void Item::clear_file() {
+  if (_internal_has_file()) {
+    if (GetArenaForAllocation() == nullptr) {
+      delete _impl_.value_.file_;
+    }
+    clear_has_value();
+  }
+}
+inline ::aapt::pb::FileReference* Item::release_file() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Item.file)
+  if (_internal_has_file()) {
+    clear_has_value();
+    ::aapt::pb::FileReference* temp = _impl_.value_.file_;
+    if (GetArenaForAllocation() != nullptr) {
+      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+    }
+    _impl_.value_.file_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline const ::aapt::pb::FileReference& Item::_internal_file() const {
+  return _internal_has_file()
+      ? *_impl_.value_.file_
+      : reinterpret_cast< ::aapt::pb::FileReference&>(::aapt::pb::_FileReference_default_instance_);
+}
+inline const ::aapt::pb::FileReference& Item::file() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Item.file)
+  return _internal_file();
+}
+inline ::aapt::pb::FileReference* Item::unsafe_arena_release_file() {
+  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Item.file)
+  if (_internal_has_file()) {
+    clear_has_value();
+    ::aapt::pb::FileReference* temp = _impl_.value_.file_;
+    _impl_.value_.file_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline void Item::unsafe_arena_set_allocated_file(::aapt::pb::FileReference* file) {
+  clear_value();
+  if (file) {
+    set_has_file();
+    _impl_.value_.file_ = file;
+  }
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Item.file)
+}
+inline ::aapt::pb::FileReference* Item::_internal_mutable_file() {
+  if (!_internal_has_file()) {
+    clear_value();
+    set_has_file();
+    _impl_.value_.file_ = CreateMaybeMessage< ::aapt::pb::FileReference >(GetArenaForAllocation());
+  }
+  return _impl_.value_.file_;
+}
+inline ::aapt::pb::FileReference* Item::mutable_file() {
+  ::aapt::pb::FileReference* _msg = _internal_mutable_file();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.file)
+  return _msg;
+}
+
+// .aapt.pb.Id id = 6;
+inline bool Item::_internal_has_id() const {
+  return value_case() == kId;
+}
+inline bool Item::has_id() const {
+  return _internal_has_id();
+}
+inline void Item::set_has_id() {
+  _impl_._oneof_case_[0] = kId;
+}
+inline void Item::clear_id() {
+  if (_internal_has_id()) {
+    if (GetArenaForAllocation() == nullptr) {
+      delete _impl_.value_.id_;
+    }
+    clear_has_value();
+  }
+}
+inline ::aapt::pb::Id* Item::release_id() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Item.id)
+  if (_internal_has_id()) {
+    clear_has_value();
+    ::aapt::pb::Id* temp = _impl_.value_.id_;
+    if (GetArenaForAllocation() != nullptr) {
+      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+    }
+    _impl_.value_.id_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline const ::aapt::pb::Id& Item::_internal_id() const {
+  return _internal_has_id()
+      ? *_impl_.value_.id_
+      : reinterpret_cast< ::aapt::pb::Id&>(::aapt::pb::_Id_default_instance_);
+}
+inline const ::aapt::pb::Id& Item::id() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Item.id)
+  return _internal_id();
+}
+inline ::aapt::pb::Id* Item::unsafe_arena_release_id() {
+  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Item.id)
+  if (_internal_has_id()) {
+    clear_has_value();
+    ::aapt::pb::Id* temp = _impl_.value_.id_;
+    _impl_.value_.id_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline void Item::unsafe_arena_set_allocated_id(::aapt::pb::Id* id) {
+  clear_value();
+  if (id) {
+    set_has_id();
+    _impl_.value_.id_ = id;
+  }
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Item.id)
+}
+inline ::aapt::pb::Id* Item::_internal_mutable_id() {
+  if (!_internal_has_id()) {
+    clear_value();
+    set_has_id();
+    _impl_.value_.id_ = CreateMaybeMessage< ::aapt::pb::Id >(GetArenaForAllocation());
+  }
+  return _impl_.value_.id_;
+}
+inline ::aapt::pb::Id* Item::mutable_id() {
+  ::aapt::pb::Id* _msg = _internal_mutable_id();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.id)
+  return _msg;
+}
+
+// .aapt.pb.Primitive prim = 7;
+inline bool Item::_internal_has_prim() const {
+  return value_case() == kPrim;
+}
+inline bool Item::has_prim() const {
+  return _internal_has_prim();
+}
+inline void Item::set_has_prim() {
+  _impl_._oneof_case_[0] = kPrim;
+}
+inline void Item::clear_prim() {
+  if (_internal_has_prim()) {
+    if (GetArenaForAllocation() == nullptr) {
+      delete _impl_.value_.prim_;
+    }
+    clear_has_value();
+  }
+}
+inline ::aapt::pb::Primitive* Item::release_prim() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Item.prim)
+  if (_internal_has_prim()) {
+    clear_has_value();
+    ::aapt::pb::Primitive* temp = _impl_.value_.prim_;
+    if (GetArenaForAllocation() != nullptr) {
+      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+    }
+    _impl_.value_.prim_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline const ::aapt::pb::Primitive& Item::_internal_prim() const {
+  return _internal_has_prim()
+      ? *_impl_.value_.prim_
+      : reinterpret_cast< ::aapt::pb::Primitive&>(::aapt::pb::_Primitive_default_instance_);
+}
+inline const ::aapt::pb::Primitive& Item::prim() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Item.prim)
+  return _internal_prim();
+}
+inline ::aapt::pb::Primitive* Item::unsafe_arena_release_prim() {
+  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Item.prim)
+  if (_internal_has_prim()) {
+    clear_has_value();
+    ::aapt::pb::Primitive* temp = _impl_.value_.prim_;
+    _impl_.value_.prim_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline void Item::unsafe_arena_set_allocated_prim(::aapt::pb::Primitive* prim) {
+  clear_value();
+  if (prim) {
+    set_has_prim();
+    _impl_.value_.prim_ = prim;
+  }
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Item.prim)
+}
+inline ::aapt::pb::Primitive* Item::_internal_mutable_prim() {
+  if (!_internal_has_prim()) {
+    clear_value();
+    set_has_prim();
+    _impl_.value_.prim_ = CreateMaybeMessage< ::aapt::pb::Primitive >(GetArenaForAllocation());
+  }
+  return _impl_.value_.prim_;
+}
+inline ::aapt::pb::Primitive* Item::mutable_prim() {
+  ::aapt::pb::Primitive* _msg = _internal_mutable_prim();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.prim)
+  return _msg;
+}
+
+inline bool Item::has_value() const {
+  return value_case() != VALUE_NOT_SET;
+}
+inline void Item::clear_has_value() {
+  _impl_._oneof_case_[0] = VALUE_NOT_SET;
+}
+inline Item::ValueCase Item::value_case() const {
+  return Item::ValueCase(_impl_._oneof_case_[0]);
+}
+// -------------------------------------------------------------------
+
+// CompoundValue
+
+// .aapt.pb.Attribute attr = 1;
+inline bool CompoundValue::_internal_has_attr() const {
+  return value_case() == kAttr;
+}
+inline bool CompoundValue::has_attr() const {
+  return _internal_has_attr();
+}
+inline void CompoundValue::set_has_attr() {
+  _impl_._oneof_case_[0] = kAttr;
+}
+inline void CompoundValue::clear_attr() {
+  if (_internal_has_attr()) {
+    if (GetArenaForAllocation() == nullptr) {
+      delete _impl_.value_.attr_;
+    }
+    clear_has_value();
+  }
+}
+inline ::aapt::pb::Attribute* CompoundValue::release_attr() {
+  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.attr)
+  if (_internal_has_attr()) {
+    clear_has_value();
+    ::aapt::pb::Attribute* temp = _impl_.value_.attr_;
+    if (GetArenaForAllocation() != nullptr) {
+      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+    }
+    _impl_.value_.attr_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline const ::aapt::pb::Attribute& CompoundValue::_internal_attr() const {
+  return _internal_has_attr()
+      ? *_impl_.value_.attr_
+      : reinterpret_cast< ::aapt::pb::Attribute&>(::aapt::pb::_Attribute_default_instance_);
+}
+inline const ::aapt::pb::Attribute& CompoundValue::attr() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.attr)
+  return _internal_attr();
+}
+inline ::aapt::pb::Attribute* CompoundValue::unsafe_arena_release_attr() {
+  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.CompoundValue.attr)
+  if (_internal_has_attr()) {
+    clear_has_value();
+    ::aapt::pb::Attribute* temp = _impl_.value_.attr_;
+    _impl_.value_.attr_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline void CompoundValue::unsafe_arena_set_allocated_attr(::aapt::pb::Attribute* attr) {
+  clear_value();
+  if (attr) {
+    set_has_attr();
+    _impl_.value_.attr_ = attr;
+  }
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.CompoundValue.attr)
+}
+inline ::aapt::pb::Attribute* CompoundValue::_internal_mutable_attr() {
+  if (!_internal_has_attr()) {
+    clear_value();
+    set_has_attr();
+    _impl_.value_.attr_ = CreateMaybeMessage< ::aapt::pb::Attribute >(GetArenaForAllocation());
+  }
+  return _impl_.value_.attr_;
+}
+inline ::aapt::pb::Attribute* CompoundValue::mutable_attr() {
+  ::aapt::pb::Attribute* _msg = _internal_mutable_attr();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.attr)
+  return _msg;
+}
+
+// .aapt.pb.Style style = 2;
+inline bool CompoundValue::_internal_has_style() const {
+  return value_case() == kStyle;
+}
+inline bool CompoundValue::has_style() const {
+  return _internal_has_style();
+}
+inline void CompoundValue::set_has_style() {
+  _impl_._oneof_case_[0] = kStyle;
+}
+inline void CompoundValue::clear_style() {
+  if (_internal_has_style()) {
+    if (GetArenaForAllocation() == nullptr) {
+      delete _impl_.value_.style_;
+    }
+    clear_has_value();
+  }
+}
+inline ::aapt::pb::Style* CompoundValue::release_style() {
+  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.style)
+  if (_internal_has_style()) {
+    clear_has_value();
+    ::aapt::pb::Style* temp = _impl_.value_.style_;
+    if (GetArenaForAllocation() != nullptr) {
+      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+    }
+    _impl_.value_.style_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline const ::aapt::pb::Style& CompoundValue::_internal_style() const {
+  return _internal_has_style()
+      ? *_impl_.value_.style_
+      : reinterpret_cast< ::aapt::pb::Style&>(::aapt::pb::_Style_default_instance_);
+}
+inline const ::aapt::pb::Style& CompoundValue::style() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.style)
+  return _internal_style();
+}
+inline ::aapt::pb::Style* CompoundValue::unsafe_arena_release_style() {
+  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.CompoundValue.style)
+  if (_internal_has_style()) {
+    clear_has_value();
+    ::aapt::pb::Style* temp = _impl_.value_.style_;
+    _impl_.value_.style_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline void CompoundValue::unsafe_arena_set_allocated_style(::aapt::pb::Style* style) {
+  clear_value();
+  if (style) {
+    set_has_style();
+    _impl_.value_.style_ = style;
+  }
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.CompoundValue.style)
+}
+inline ::aapt::pb::Style* CompoundValue::_internal_mutable_style() {
+  if (!_internal_has_style()) {
+    clear_value();
+    set_has_style();
+    _impl_.value_.style_ = CreateMaybeMessage< ::aapt::pb::Style >(GetArenaForAllocation());
+  }
+  return _impl_.value_.style_;
+}
+inline ::aapt::pb::Style* CompoundValue::mutable_style() {
+  ::aapt::pb::Style* _msg = _internal_mutable_style();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.style)
+  return _msg;
+}
+
+// .aapt.pb.Styleable styleable = 3;
+inline bool CompoundValue::_internal_has_styleable() const {
+  return value_case() == kStyleable;
+}
+inline bool CompoundValue::has_styleable() const {
+  return _internal_has_styleable();
+}
+inline void CompoundValue::set_has_styleable() {
+  _impl_._oneof_case_[0] = kStyleable;
+}
+inline void CompoundValue::clear_styleable() {
+  if (_internal_has_styleable()) {
+    if (GetArenaForAllocation() == nullptr) {
+      delete _impl_.value_.styleable_;
+    }
+    clear_has_value();
+  }
+}
+inline ::aapt::pb::Styleable* CompoundValue::release_styleable() {
+  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.styleable)
+  if (_internal_has_styleable()) {
+    clear_has_value();
+    ::aapt::pb::Styleable* temp = _impl_.value_.styleable_;
+    if (GetArenaForAllocation() != nullptr) {
+      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+    }
+    _impl_.value_.styleable_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline const ::aapt::pb::Styleable& CompoundValue::_internal_styleable() const {
+  return _internal_has_styleable()
+      ? *_impl_.value_.styleable_
+      : reinterpret_cast< ::aapt::pb::Styleable&>(::aapt::pb::_Styleable_default_instance_);
+}
+inline const ::aapt::pb::Styleable& CompoundValue::styleable() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.styleable)
+  return _internal_styleable();
+}
+inline ::aapt::pb::Styleable* CompoundValue::unsafe_arena_release_styleable() {
+  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.CompoundValue.styleable)
+  if (_internal_has_styleable()) {
+    clear_has_value();
+    ::aapt::pb::Styleable* temp = _impl_.value_.styleable_;
+    _impl_.value_.styleable_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline void CompoundValue::unsafe_arena_set_allocated_styleable(::aapt::pb::Styleable* styleable) {
+  clear_value();
+  if (styleable) {
+    set_has_styleable();
+    _impl_.value_.styleable_ = styleable;
+  }
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.CompoundValue.styleable)
+}
+inline ::aapt::pb::Styleable* CompoundValue::_internal_mutable_styleable() {
+  if (!_internal_has_styleable()) {
+    clear_value();
+    set_has_styleable();
+    _impl_.value_.styleable_ = CreateMaybeMessage< ::aapt::pb::Styleable >(GetArenaForAllocation());
+  }
+  return _impl_.value_.styleable_;
+}
+inline ::aapt::pb::Styleable* CompoundValue::mutable_styleable() {
+  ::aapt::pb::Styleable* _msg = _internal_mutable_styleable();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.styleable)
+  return _msg;
+}
+
+// .aapt.pb.Array array = 4;
+inline bool CompoundValue::_internal_has_array() const {
+  return value_case() == kArray;
+}
+inline bool CompoundValue::has_array() const {
+  return _internal_has_array();
+}
+inline void CompoundValue::set_has_array() {
+  _impl_._oneof_case_[0] = kArray;
+}
+inline void CompoundValue::clear_array() {
+  if (_internal_has_array()) {
+    if (GetArenaForAllocation() == nullptr) {
+      delete _impl_.value_.array_;
+    }
+    clear_has_value();
+  }
+}
+inline ::aapt::pb::Array* CompoundValue::release_array() {
+  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.array)
+  if (_internal_has_array()) {
+    clear_has_value();
+    ::aapt::pb::Array* temp = _impl_.value_.array_;
+    if (GetArenaForAllocation() != nullptr) {
+      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+    }
+    _impl_.value_.array_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline const ::aapt::pb::Array& CompoundValue::_internal_array() const {
+  return _internal_has_array()
+      ? *_impl_.value_.array_
+      : reinterpret_cast< ::aapt::pb::Array&>(::aapt::pb::_Array_default_instance_);
+}
+inline const ::aapt::pb::Array& CompoundValue::array() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.array)
+  return _internal_array();
+}
+inline ::aapt::pb::Array* CompoundValue::unsafe_arena_release_array() {
+  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.CompoundValue.array)
+  if (_internal_has_array()) {
+    clear_has_value();
+    ::aapt::pb::Array* temp = _impl_.value_.array_;
+    _impl_.value_.array_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline void CompoundValue::unsafe_arena_set_allocated_array(::aapt::pb::Array* array) {
+  clear_value();
+  if (array) {
+    set_has_array();
+    _impl_.value_.array_ = array;
+  }
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.CompoundValue.array)
+}
+inline ::aapt::pb::Array* CompoundValue::_internal_mutable_array() {
+  if (!_internal_has_array()) {
+    clear_value();
+    set_has_array();
+    _impl_.value_.array_ = CreateMaybeMessage< ::aapt::pb::Array >(GetArenaForAllocation());
+  }
+  return _impl_.value_.array_;
+}
+inline ::aapt::pb::Array* CompoundValue::mutable_array() {
+  ::aapt::pb::Array* _msg = _internal_mutable_array();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.array)
+  return _msg;
+}
+
+// .aapt.pb.Plural plural = 5;
+inline bool CompoundValue::_internal_has_plural() const {
+  return value_case() == kPlural;
+}
+inline bool CompoundValue::has_plural() const {
+  return _internal_has_plural();
+}
+inline void CompoundValue::set_has_plural() {
+  _impl_._oneof_case_[0] = kPlural;
+}
+inline void CompoundValue::clear_plural() {
+  if (_internal_has_plural()) {
+    if (GetArenaForAllocation() == nullptr) {
+      delete _impl_.value_.plural_;
+    }
+    clear_has_value();
+  }
+}
+inline ::aapt::pb::Plural* CompoundValue::release_plural() {
+  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.plural)
+  if (_internal_has_plural()) {
+    clear_has_value();
+    ::aapt::pb::Plural* temp = _impl_.value_.plural_;
+    if (GetArenaForAllocation() != nullptr) {
+      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+    }
+    _impl_.value_.plural_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline const ::aapt::pb::Plural& CompoundValue::_internal_plural() const {
+  return _internal_has_plural()
+      ? *_impl_.value_.plural_
+      : reinterpret_cast< ::aapt::pb::Plural&>(::aapt::pb::_Plural_default_instance_);
+}
+inline const ::aapt::pb::Plural& CompoundValue::plural() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.plural)
+  return _internal_plural();
+}
+inline ::aapt::pb::Plural* CompoundValue::unsafe_arena_release_plural() {
+  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.CompoundValue.plural)
+  if (_internal_has_plural()) {
+    clear_has_value();
+    ::aapt::pb::Plural* temp = _impl_.value_.plural_;
+    _impl_.value_.plural_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline void CompoundValue::unsafe_arena_set_allocated_plural(::aapt::pb::Plural* plural) {
+  clear_value();
+  if (plural) {
+    set_has_plural();
+    _impl_.value_.plural_ = plural;
+  }
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.CompoundValue.plural)
+}
+inline ::aapt::pb::Plural* CompoundValue::_internal_mutable_plural() {
+  if (!_internal_has_plural()) {
+    clear_value();
+    set_has_plural();
+    _impl_.value_.plural_ = CreateMaybeMessage< ::aapt::pb::Plural >(GetArenaForAllocation());
+  }
+  return _impl_.value_.plural_;
+}
+inline ::aapt::pb::Plural* CompoundValue::mutable_plural() {
+  ::aapt::pb::Plural* _msg = _internal_mutable_plural();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.plural)
+  return _msg;
+}
+
+// .aapt.pb.MacroBody macro = 6;
+inline bool CompoundValue::_internal_has_macro() const {
+  return value_case() == kMacro;
+}
+inline bool CompoundValue::has_macro() const {
+  return _internal_has_macro();
+}
+inline void CompoundValue::set_has_macro() {
+  _impl_._oneof_case_[0] = kMacro;
+}
+inline void CompoundValue::clear_macro() {
+  if (_internal_has_macro()) {
+    if (GetArenaForAllocation() == nullptr) {
+      delete _impl_.value_.macro_;
+    }
+    clear_has_value();
+  }
+}
+inline ::aapt::pb::MacroBody* CompoundValue::release_macro() {
+  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.macro)
+  if (_internal_has_macro()) {
+    clear_has_value();
+    ::aapt::pb::MacroBody* temp = _impl_.value_.macro_;
+    if (GetArenaForAllocation() != nullptr) {
+      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+    }
+    _impl_.value_.macro_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline const ::aapt::pb::MacroBody& CompoundValue::_internal_macro() const {
+  return _internal_has_macro()
+      ? *_impl_.value_.macro_
+      : reinterpret_cast< ::aapt::pb::MacroBody&>(::aapt::pb::_MacroBody_default_instance_);
+}
+inline const ::aapt::pb::MacroBody& CompoundValue::macro() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.macro)
+  return _internal_macro();
+}
+inline ::aapt::pb::MacroBody* CompoundValue::unsafe_arena_release_macro() {
+  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.CompoundValue.macro)
+  if (_internal_has_macro()) {
+    clear_has_value();
+    ::aapt::pb::MacroBody* temp = _impl_.value_.macro_;
+    _impl_.value_.macro_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline void CompoundValue::unsafe_arena_set_allocated_macro(::aapt::pb::MacroBody* macro) {
+  clear_value();
+  if (macro) {
+    set_has_macro();
+    _impl_.value_.macro_ = macro;
+  }
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.CompoundValue.macro)
+}
+inline ::aapt::pb::MacroBody* CompoundValue::_internal_mutable_macro() {
+  if (!_internal_has_macro()) {
+    clear_value();
+    set_has_macro();
+    _impl_.value_.macro_ = CreateMaybeMessage< ::aapt::pb::MacroBody >(GetArenaForAllocation());
+  }
+  return _impl_.value_.macro_;
+}
+inline ::aapt::pb::MacroBody* CompoundValue::mutable_macro() {
+  ::aapt::pb::MacroBody* _msg = _internal_mutable_macro();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.macro)
+  return _msg;
+}
+
+inline bool CompoundValue::has_value() const {
+  return value_case() != VALUE_NOT_SET;
+}
+inline void CompoundValue::clear_has_value() {
+  _impl_._oneof_case_[0] = VALUE_NOT_SET;
+}
+inline CompoundValue::ValueCase CompoundValue::value_case() const {
+  return CompoundValue::ValueCase(_impl_._oneof_case_[0]);
+}
+// -------------------------------------------------------------------
+
+// Boolean
+
+// bool value = 1;
+inline void Boolean::clear_value() {
+  _impl_.value_ = false;
+}
+inline bool Boolean::_internal_value() const {
+  return _impl_.value_;
+}
+inline bool Boolean::value() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Boolean.value)
+  return _internal_value();
+}
+inline void Boolean::_internal_set_value(bool value) {
+  
+  _impl_.value_ = value;
+}
+inline void Boolean::set_value(bool value) {
+  _internal_set_value(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Boolean.value)
+}
+
+// -------------------------------------------------------------------
+
+// Reference
+
+// .aapt.pb.Reference.Type type = 1;
+inline void Reference::clear_type() {
+  _impl_.type_ = 0;
+}
+inline ::aapt::pb::Reference_Type Reference::_internal_type() const {
+  return static_cast< ::aapt::pb::Reference_Type >(_impl_.type_);
+}
+inline ::aapt::pb::Reference_Type Reference::type() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Reference.type)
+  return _internal_type();
+}
+inline void Reference::_internal_set_type(::aapt::pb::Reference_Type value) {
+  
+  _impl_.type_ = value;
+}
+inline void Reference::set_type(::aapt::pb::Reference_Type value) {
+  _internal_set_type(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Reference.type)
+}
+
+// uint32 id = 2;
+inline void Reference::clear_id() {
+  _impl_.id_ = 0u;
+}
+inline ::uint32_t Reference::_internal_id() const {
+  return _impl_.id_;
+}
+inline ::uint32_t Reference::id() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Reference.id)
+  return _internal_id();
+}
+inline void Reference::_internal_set_id(::uint32_t value) {
+  
+  _impl_.id_ = value;
+}
+inline void Reference::set_id(::uint32_t value) {
+  _internal_set_id(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Reference.id)
+}
+
+// string name = 3;
+inline void Reference::clear_name() {
+  _impl_.name_.ClearToEmpty();
+}
+inline const std::string& Reference::name() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Reference.name)
+  return _internal_name();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void Reference::set_name(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.Reference.name)
+}
+inline std::string* Reference::mutable_name() {
+  std::string* _s = _internal_mutable_name();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Reference.name)
+  return _s;
+}
+inline const std::string& Reference::_internal_name() const {
+  return _impl_.name_.Get();
+}
+inline void Reference::_internal_set_name(const std::string& value) {
+  
+  _impl_.name_.Set(value, GetArenaForAllocation());
+}
+inline std::string* Reference::_internal_mutable_name() {
+  
+  return _impl_.name_.Mutable(GetArenaForAllocation());
+}
+inline std::string* Reference::release_name() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Reference.name)
+  return _impl_.name_.Release();
+}
+inline void Reference::set_allocated_name(std::string* name) {
+  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.name_.IsDefault()) {
+    _impl_.name_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Reference.name)
+}
+
+// bool private = 4;
+inline void Reference::clear_private_() {
+  _impl_.private__ = false;
+}
+inline bool Reference::_internal_private_() const {
+  return _impl_.private__;
+}
+inline bool Reference::private_() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Reference.private)
+  return _internal_private_();
+}
+inline void Reference::_internal_set_private_(bool value) {
+  
+  _impl_.private__ = value;
+}
+inline void Reference::set_private_(bool value) {
+  _internal_set_private_(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Reference.private)
+}
+
+// .aapt.pb.Boolean is_dynamic = 5;
+inline bool Reference::_internal_has_is_dynamic() const {
+  return this != internal_default_instance() && _impl_.is_dynamic_ != nullptr;
+}
+inline bool Reference::has_is_dynamic() const {
+  return _internal_has_is_dynamic();
+}
+inline void Reference::clear_is_dynamic() {
+  if (GetArenaForAllocation() == nullptr && _impl_.is_dynamic_ != nullptr) {
+    delete _impl_.is_dynamic_;
+  }
+  _impl_.is_dynamic_ = nullptr;
+}
+inline const ::aapt::pb::Boolean& Reference::_internal_is_dynamic() const {
+  const ::aapt::pb::Boolean* p = _impl_.is_dynamic_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Boolean&>(
+      ::aapt::pb::_Boolean_default_instance_);
+}
+inline const ::aapt::pb::Boolean& Reference::is_dynamic() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Reference.is_dynamic)
+  return _internal_is_dynamic();
+}
+inline void Reference::unsafe_arena_set_allocated_is_dynamic(
+    ::aapt::pb::Boolean* is_dynamic) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.is_dynamic_);
+  }
+  _impl_.is_dynamic_ = is_dynamic;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Reference.is_dynamic)
+}
+inline ::aapt::pb::Boolean* Reference::release_is_dynamic() {
+  
+  ::aapt::pb::Boolean* temp = _impl_.is_dynamic_;
+  _impl_.is_dynamic_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Boolean* Reference::unsafe_arena_release_is_dynamic() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Reference.is_dynamic)
+  
+  ::aapt::pb::Boolean* temp = _impl_.is_dynamic_;
+  _impl_.is_dynamic_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Boolean* Reference::_internal_mutable_is_dynamic() {
+  
+  if (_impl_.is_dynamic_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Boolean>(GetArenaForAllocation());
+    _impl_.is_dynamic_ = p;
+  }
+  return _impl_.is_dynamic_;
+}
+inline ::aapt::pb::Boolean* Reference::mutable_is_dynamic() {
+  ::aapt::pb::Boolean* _msg = _internal_mutable_is_dynamic();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Reference.is_dynamic)
+  return _msg;
+}
+inline void Reference::set_allocated_is_dynamic(::aapt::pb::Boolean* is_dynamic) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.is_dynamic_;
+  }
+  if (is_dynamic) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(is_dynamic);
+    if (message_arena != submessage_arena) {
+      is_dynamic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, is_dynamic, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.is_dynamic_ = is_dynamic;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Reference.is_dynamic)
+}
+
+// uint32 type_flags = 6;
+inline void Reference::clear_type_flags() {
+  _impl_.type_flags_ = 0u;
+}
+inline ::uint32_t Reference::_internal_type_flags() const {
+  return _impl_.type_flags_;
+}
+inline ::uint32_t Reference::type_flags() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Reference.type_flags)
+  return _internal_type_flags();
+}
+inline void Reference::_internal_set_type_flags(::uint32_t value) {
+  
+  _impl_.type_flags_ = value;
+}
+inline void Reference::set_type_flags(::uint32_t value) {
+  _internal_set_type_flags(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Reference.type_flags)
+}
+
+// bool allow_raw = 7;
+inline void Reference::clear_allow_raw() {
+  _impl_.allow_raw_ = false;
+}
+inline bool Reference::_internal_allow_raw() const {
+  return _impl_.allow_raw_;
+}
+inline bool Reference::allow_raw() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Reference.allow_raw)
+  return _internal_allow_raw();
+}
+inline void Reference::_internal_set_allow_raw(bool value) {
+  
+  _impl_.allow_raw_ = value;
+}
+inline void Reference::set_allow_raw(bool value) {
+  _internal_set_allow_raw(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Reference.allow_raw)
+}
+
+// -------------------------------------------------------------------
+
+// Id
+
+// -------------------------------------------------------------------
+
+// String
+
+// string value = 1;
+inline void String::clear_value() {
+  _impl_.value_.ClearToEmpty();
+}
+inline const std::string& String::value() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.String.value)
+  return _internal_value();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void String::set_value(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.String.value)
+}
+inline std::string* String::mutable_value() {
+  std::string* _s = _internal_mutable_value();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.String.value)
+  return _s;
+}
+inline const std::string& String::_internal_value() const {
+  return _impl_.value_.Get();
+}
+inline void String::_internal_set_value(const std::string& value) {
+  
+  _impl_.value_.Set(value, GetArenaForAllocation());
+}
+inline std::string* String::_internal_mutable_value() {
+  
+  return _impl_.value_.Mutable(GetArenaForAllocation());
+}
+inline std::string* String::release_value() {
+  // @@protoc_insertion_point(field_release:aapt.pb.String.value)
+  return _impl_.value_.Release();
+}
+inline void String::set_allocated_value(std::string* value) {
+  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.value_.IsDefault()) {
+    _impl_.value_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.String.value)
+}
+
+// -------------------------------------------------------------------
+
+// RawString
+
+// string value = 1;
+inline void RawString::clear_value() {
+  _impl_.value_.ClearToEmpty();
+}
+inline const std::string& RawString::value() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.RawString.value)
+  return _internal_value();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void RawString::set_value(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.RawString.value)
+}
+inline std::string* RawString::mutable_value() {
+  std::string* _s = _internal_mutable_value();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.RawString.value)
+  return _s;
+}
+inline const std::string& RawString::_internal_value() const {
+  return _impl_.value_.Get();
+}
+inline void RawString::_internal_set_value(const std::string& value) {
+  
+  _impl_.value_.Set(value, GetArenaForAllocation());
+}
+inline std::string* RawString::_internal_mutable_value() {
+  
+  return _impl_.value_.Mutable(GetArenaForAllocation());
+}
+inline std::string* RawString::release_value() {
+  // @@protoc_insertion_point(field_release:aapt.pb.RawString.value)
+  return _impl_.value_.Release();
+}
+inline void RawString::set_allocated_value(std::string* value) {
+  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.value_.IsDefault()) {
+    _impl_.value_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.RawString.value)
+}
+
+// -------------------------------------------------------------------
+
+// StyledString_Span
+
+// string tag = 1;
+inline void StyledString_Span::clear_tag() {
+  _impl_.tag_.ClearToEmpty();
+}
+inline const std::string& StyledString_Span::tag() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.StyledString.Span.tag)
+  return _internal_tag();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void StyledString_Span::set_tag(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.StyledString.Span.tag)
+}
+inline std::string* StyledString_Span::mutable_tag() {
+  std::string* _s = _internal_mutable_tag();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.StyledString.Span.tag)
+  return _s;
+}
+inline const std::string& StyledString_Span::_internal_tag() const {
+  return _impl_.tag_.Get();
+}
+inline void StyledString_Span::_internal_set_tag(const std::string& value) {
+  
+  _impl_.tag_.Set(value, GetArenaForAllocation());
+}
+inline std::string* StyledString_Span::_internal_mutable_tag() {
+  
+  return _impl_.tag_.Mutable(GetArenaForAllocation());
+}
+inline std::string* StyledString_Span::release_tag() {
+  // @@protoc_insertion_point(field_release:aapt.pb.StyledString.Span.tag)
+  return _impl_.tag_.Release();
+}
+inline void StyledString_Span::set_allocated_tag(std::string* tag) {
+  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.tag_.IsDefault()) {
+    _impl_.tag_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.StyledString.Span.tag)
+}
+
+// uint32 first_char = 2;
+inline void StyledString_Span::clear_first_char() {
+  _impl_.first_char_ = 0u;
+}
+inline ::uint32_t StyledString_Span::_internal_first_char() const {
+  return _impl_.first_char_;
+}
+inline ::uint32_t StyledString_Span::first_char() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.StyledString.Span.first_char)
+  return _internal_first_char();
+}
+inline void StyledString_Span::_internal_set_first_char(::uint32_t value) {
+  
+  _impl_.first_char_ = value;
+}
+inline void StyledString_Span::set_first_char(::uint32_t value) {
+  _internal_set_first_char(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.StyledString.Span.first_char)
+}
+
+// uint32 last_char = 3;
+inline void StyledString_Span::clear_last_char() {
+  _impl_.last_char_ = 0u;
+}
+inline ::uint32_t StyledString_Span::_internal_last_char() const {
+  return _impl_.last_char_;
+}
+inline ::uint32_t StyledString_Span::last_char() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.StyledString.Span.last_char)
+  return _internal_last_char();
+}
+inline void StyledString_Span::_internal_set_last_char(::uint32_t value) {
+  
+  _impl_.last_char_ = value;
+}
+inline void StyledString_Span::set_last_char(::uint32_t value) {
+  _internal_set_last_char(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.StyledString.Span.last_char)
+}
+
+// -------------------------------------------------------------------
+
+// StyledString
+
+// string value = 1;
+inline void StyledString::clear_value() {
+  _impl_.value_.ClearToEmpty();
+}
+inline const std::string& StyledString::value() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.StyledString.value)
+  return _internal_value();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void StyledString::set_value(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.StyledString.value)
+}
+inline std::string* StyledString::mutable_value() {
+  std::string* _s = _internal_mutable_value();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.StyledString.value)
+  return _s;
+}
+inline const std::string& StyledString::_internal_value() const {
+  return _impl_.value_.Get();
+}
+inline void StyledString::_internal_set_value(const std::string& value) {
+  
+  _impl_.value_.Set(value, GetArenaForAllocation());
+}
+inline std::string* StyledString::_internal_mutable_value() {
+  
+  return _impl_.value_.Mutable(GetArenaForAllocation());
+}
+inline std::string* StyledString::release_value() {
+  // @@protoc_insertion_point(field_release:aapt.pb.StyledString.value)
+  return _impl_.value_.Release();
+}
+inline void StyledString::set_allocated_value(std::string* value) {
+  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.value_.IsDefault()) {
+    _impl_.value_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.StyledString.value)
+}
+
+// repeated .aapt.pb.StyledString.Span span = 2;
+inline int StyledString::_internal_span_size() const {
+  return _impl_.span_.size();
+}
+inline int StyledString::span_size() const {
+  return _internal_span_size();
+}
+inline void StyledString::clear_span() {
+  _impl_.span_.Clear();
+}
+inline ::aapt::pb::StyledString_Span* StyledString::mutable_span(int index) {
+  // @@protoc_insertion_point(field_mutable:aapt.pb.StyledString.span)
+  return _impl_.span_.Mutable(index);
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::StyledString_Span >*
+StyledString::mutable_span() {
+  // @@protoc_insertion_point(field_mutable_list:aapt.pb.StyledString.span)
+  return &_impl_.span_;
+}
+inline const ::aapt::pb::StyledString_Span& StyledString::_internal_span(int index) const {
+  return _impl_.span_.Get(index);
+}
+inline const ::aapt::pb::StyledString_Span& StyledString::span(int index) const {
+  // @@protoc_insertion_point(field_get:aapt.pb.StyledString.span)
+  return _internal_span(index);
+}
+inline ::aapt::pb::StyledString_Span* StyledString::_internal_add_span() {
+  return _impl_.span_.Add();
+}
+inline ::aapt::pb::StyledString_Span* StyledString::add_span() {
+  ::aapt::pb::StyledString_Span* _add = _internal_add_span();
+  // @@protoc_insertion_point(field_add:aapt.pb.StyledString.span)
+  return _add;
+}
+inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::StyledString_Span >&
+StyledString::span() const {
+  // @@protoc_insertion_point(field_list:aapt.pb.StyledString.span)
+  return _impl_.span_;
+}
+
+// -------------------------------------------------------------------
+
+// FileReference
+
+// string path = 1;
+inline void FileReference::clear_path() {
+  _impl_.path_.ClearToEmpty();
+}
+inline const std::string& FileReference::path() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.FileReference.path)
+  return _internal_path();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void FileReference::set_path(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.FileReference.path)
+}
+inline std::string* FileReference::mutable_path() {
+  std::string* _s = _internal_mutable_path();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.FileReference.path)
+  return _s;
+}
+inline const std::string& FileReference::_internal_path() const {
+  return _impl_.path_.Get();
+}
+inline void FileReference::_internal_set_path(const std::string& value) {
+  
+  _impl_.path_.Set(value, GetArenaForAllocation());
+}
+inline std::string* FileReference::_internal_mutable_path() {
+  
+  return _impl_.path_.Mutable(GetArenaForAllocation());
+}
+inline std::string* FileReference::release_path() {
+  // @@protoc_insertion_point(field_release:aapt.pb.FileReference.path)
+  return _impl_.path_.Release();
+}
+inline void FileReference::set_allocated_path(std::string* path) {
+  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.path_.IsDefault()) {
+    _impl_.path_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.FileReference.path)
+}
+
+// .aapt.pb.FileReference.Type type = 2;
+inline void FileReference::clear_type() {
+  _impl_.type_ = 0;
+}
+inline ::aapt::pb::FileReference_Type FileReference::_internal_type() const {
+  return static_cast< ::aapt::pb::FileReference_Type >(_impl_.type_);
+}
+inline ::aapt::pb::FileReference_Type FileReference::type() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.FileReference.type)
+  return _internal_type();
+}
+inline void FileReference::_internal_set_type(::aapt::pb::FileReference_Type value) {
+  
+  _impl_.type_ = value;
+}
+inline void FileReference::set_type(::aapt::pb::FileReference_Type value) {
+  _internal_set_type(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.FileReference.type)
+}
+
+// -------------------------------------------------------------------
+
+// Primitive_NullType
+
+// -------------------------------------------------------------------
+
+// Primitive_EmptyType
+
+// -------------------------------------------------------------------
+
+// Primitive
+
+// .aapt.pb.Primitive.NullType null_value = 1;
+inline bool Primitive::_internal_has_null_value() const {
+  return oneof_value_case() == kNullValue;
+}
+inline bool Primitive::has_null_value() const {
+  return _internal_has_null_value();
+}
+inline void Primitive::set_has_null_value() {
+  _impl_._oneof_case_[0] = kNullValue;
+}
+inline void Primitive::clear_null_value() {
+  if (_internal_has_null_value()) {
+    if (GetArenaForAllocation() == nullptr) {
+      delete _impl_.oneof_value_.null_value_;
+    }
+    clear_has_oneof_value();
+  }
+}
+inline ::aapt::pb::Primitive_NullType* Primitive::release_null_value() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Primitive.null_value)
+  if (_internal_has_null_value()) {
+    clear_has_oneof_value();
+    ::aapt::pb::Primitive_NullType* temp = _impl_.oneof_value_.null_value_;
+    if (GetArenaForAllocation() != nullptr) {
+      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+    }
+    _impl_.oneof_value_.null_value_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline const ::aapt::pb::Primitive_NullType& Primitive::_internal_null_value() const {
+  return _internal_has_null_value()
+      ? *_impl_.oneof_value_.null_value_
+      : reinterpret_cast< ::aapt::pb::Primitive_NullType&>(::aapt::pb::_Primitive_NullType_default_instance_);
+}
+inline const ::aapt::pb::Primitive_NullType& Primitive::null_value() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.null_value)
+  return _internal_null_value();
+}
+inline ::aapt::pb::Primitive_NullType* Primitive::unsafe_arena_release_null_value() {
+  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Primitive.null_value)
+  if (_internal_has_null_value()) {
+    clear_has_oneof_value();
+    ::aapt::pb::Primitive_NullType* temp = _impl_.oneof_value_.null_value_;
+    _impl_.oneof_value_.null_value_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline void Primitive::unsafe_arena_set_allocated_null_value(::aapt::pb::Primitive_NullType* null_value) {
+  clear_oneof_value();
+  if (null_value) {
+    set_has_null_value();
+    _impl_.oneof_value_.null_value_ = null_value;
+  }
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Primitive.null_value)
+}
+inline ::aapt::pb::Primitive_NullType* Primitive::_internal_mutable_null_value() {
+  if (!_internal_has_null_value()) {
+    clear_oneof_value();
+    set_has_null_value();
+    _impl_.oneof_value_.null_value_ = CreateMaybeMessage< ::aapt::pb::Primitive_NullType >(GetArenaForAllocation());
+  }
+  return _impl_.oneof_value_.null_value_;
+}
+inline ::aapt::pb::Primitive_NullType* Primitive::mutable_null_value() {
+  ::aapt::pb::Primitive_NullType* _msg = _internal_mutable_null_value();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Primitive.null_value)
+  return _msg;
+}
+
+// .aapt.pb.Primitive.EmptyType empty_value = 2;
+inline bool Primitive::_internal_has_empty_value() const {
+  return oneof_value_case() == kEmptyValue;
+}
+inline bool Primitive::has_empty_value() const {
+  return _internal_has_empty_value();
+}
+inline void Primitive::set_has_empty_value() {
+  _impl_._oneof_case_[0] = kEmptyValue;
+}
+inline void Primitive::clear_empty_value() {
+  if (_internal_has_empty_value()) {
+    if (GetArenaForAllocation() == nullptr) {
+      delete _impl_.oneof_value_.empty_value_;
+    }
+    clear_has_oneof_value();
+  }
+}
+inline ::aapt::pb::Primitive_EmptyType* Primitive::release_empty_value() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Primitive.empty_value)
+  if (_internal_has_empty_value()) {
+    clear_has_oneof_value();
+    ::aapt::pb::Primitive_EmptyType* temp = _impl_.oneof_value_.empty_value_;
+    if (GetArenaForAllocation() != nullptr) {
+      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+    }
+    _impl_.oneof_value_.empty_value_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline const ::aapt::pb::Primitive_EmptyType& Primitive::_internal_empty_value() const {
+  return _internal_has_empty_value()
+      ? *_impl_.oneof_value_.empty_value_
+      : reinterpret_cast< ::aapt::pb::Primitive_EmptyType&>(::aapt::pb::_Primitive_EmptyType_default_instance_);
+}
+inline const ::aapt::pb::Primitive_EmptyType& Primitive::empty_value() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.empty_value)
+  return _internal_empty_value();
+}
+inline ::aapt::pb::Primitive_EmptyType* Primitive::unsafe_arena_release_empty_value() {
+  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.Primitive.empty_value)
+  if (_internal_has_empty_value()) {
+    clear_has_oneof_value();
+    ::aapt::pb::Primitive_EmptyType* temp = _impl_.oneof_value_.empty_value_;
+    _impl_.oneof_value_.empty_value_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline void Primitive::unsafe_arena_set_allocated_empty_value(::aapt::pb::Primitive_EmptyType* empty_value) {
+  clear_oneof_value();
+  if (empty_value) {
+    set_has_empty_value();
+    _impl_.oneof_value_.empty_value_ = empty_value;
+  }
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Primitive.empty_value)
+}
+inline ::aapt::pb::Primitive_EmptyType* Primitive::_internal_mutable_empty_value() {
+  if (!_internal_has_empty_value()) {
+    clear_oneof_value();
+    set_has_empty_value();
+    _impl_.oneof_value_.empty_value_ = CreateMaybeMessage< ::aapt::pb::Primitive_EmptyType >(GetArenaForAllocation());
+  }
+  return _impl_.oneof_value_.empty_value_;
+}
+inline ::aapt::pb::Primitive_EmptyType* Primitive::mutable_empty_value() {
+  ::aapt::pb::Primitive_EmptyType* _msg = _internal_mutable_empty_value();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Primitive.empty_value)
+  return _msg;
+}
+
+// float float_value = 3;
+inline bool Primitive::_internal_has_float_value() const {
+  return oneof_value_case() == kFloatValue;
+}
+inline bool Primitive::has_float_value() const {
+  return _internal_has_float_value();
+}
+inline void Primitive::set_has_float_value() {
+  _impl_._oneof_case_[0] = kFloatValue;
+}
+inline void Primitive::clear_float_value() {
+  if (_internal_has_float_value()) {
+    _impl_.oneof_value_.float_value_ = 0;
+    clear_has_oneof_value();
+  }
+}
+inline float Primitive::_internal_float_value() const {
+  if (_internal_has_float_value()) {
+    return _impl_.oneof_value_.float_value_;
+  }
+  return 0;
+}
+inline void Primitive::_internal_set_float_value(float value) {
+  if (!_internal_has_float_value()) {
+    clear_oneof_value();
+    set_has_float_value();
+  }
+  _impl_.oneof_value_.float_value_ = value;
+}
+inline float Primitive::float_value() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.float_value)
+  return _internal_float_value();
+}
+inline void Primitive::set_float_value(float value) {
+  _internal_set_float_value(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.float_value)
+}
+
+// uint32 dimension_value = 13;
+inline bool Primitive::_internal_has_dimension_value() const {
+  return oneof_value_case() == kDimensionValue;
+}
+inline bool Primitive::has_dimension_value() const {
+  return _internal_has_dimension_value();
+}
+inline void Primitive::set_has_dimension_value() {
+  _impl_._oneof_case_[0] = kDimensionValue;
+}
+inline void Primitive::clear_dimension_value() {
+  if (_internal_has_dimension_value()) {
+    _impl_.oneof_value_.dimension_value_ = 0u;
+    clear_has_oneof_value();
+  }
+}
+inline ::uint32_t Primitive::_internal_dimension_value() const {
+  if (_internal_has_dimension_value()) {
+    return _impl_.oneof_value_.dimension_value_;
+  }
+  return 0u;
+}
+inline void Primitive::_internal_set_dimension_value(::uint32_t value) {
+  if (!_internal_has_dimension_value()) {
+    clear_oneof_value();
+    set_has_dimension_value();
+  }
+  _impl_.oneof_value_.dimension_value_ = value;
+}
+inline ::uint32_t Primitive::dimension_value() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.dimension_value)
+  return _internal_dimension_value();
+}
+inline void Primitive::set_dimension_value(::uint32_t value) {
+  _internal_set_dimension_value(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.dimension_value)
+}
+
+// uint32 fraction_value = 14;
+inline bool Primitive::_internal_has_fraction_value() const {
+  return oneof_value_case() == kFractionValue;
+}
+inline bool Primitive::has_fraction_value() const {
+  return _internal_has_fraction_value();
+}
+inline void Primitive::set_has_fraction_value() {
+  _impl_._oneof_case_[0] = kFractionValue;
+}
+inline void Primitive::clear_fraction_value() {
+  if (_internal_has_fraction_value()) {
+    _impl_.oneof_value_.fraction_value_ = 0u;
+    clear_has_oneof_value();
+  }
+}
+inline ::uint32_t Primitive::_internal_fraction_value() const {
+  if (_internal_has_fraction_value()) {
+    return _impl_.oneof_value_.fraction_value_;
+  }
+  return 0u;
+}
+inline void Primitive::_internal_set_fraction_value(::uint32_t value) {
+  if (!_internal_has_fraction_value()) {
+    clear_oneof_value();
+    set_has_fraction_value();
+  }
+  _impl_.oneof_value_.fraction_value_ = value;
+}
+inline ::uint32_t Primitive::fraction_value() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.fraction_value)
+  return _internal_fraction_value();
+}
+inline void Primitive::set_fraction_value(::uint32_t value) {
+  _internal_set_fraction_value(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.fraction_value)
+}
+
+// int32 int_decimal_value = 6;
+inline bool Primitive::_internal_has_int_decimal_value() const {
+  return oneof_value_case() == kIntDecimalValue;
+}
+inline bool Primitive::has_int_decimal_value() const {
+  return _internal_has_int_decimal_value();
+}
+inline void Primitive::set_has_int_decimal_value() {
+  _impl_._oneof_case_[0] = kIntDecimalValue;
+}
+inline void Primitive::clear_int_decimal_value() {
+  if (_internal_has_int_decimal_value()) {
+    _impl_.oneof_value_.int_decimal_value_ = 0;
+    clear_has_oneof_value();
+  }
+}
+inline ::int32_t Primitive::_internal_int_decimal_value() const {
+  if (_internal_has_int_decimal_value()) {
+    return _impl_.oneof_value_.int_decimal_value_;
+  }
+  return 0;
+}
+inline void Primitive::_internal_set_int_decimal_value(::int32_t value) {
+  if (!_internal_has_int_decimal_value()) {
+    clear_oneof_value();
+    set_has_int_decimal_value();
+  }
+  _impl_.oneof_value_.int_decimal_value_ = value;
+}
+inline ::int32_t Primitive::int_decimal_value() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.int_decimal_value)
+  return _internal_int_decimal_value();
+}
+inline void Primitive::set_int_decimal_value(::int32_t value) {
+  _internal_set_int_decimal_value(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.int_decimal_value)
+}
+
+// uint32 int_hexadecimal_value = 7;
+inline bool Primitive::_internal_has_int_hexadecimal_value() const {
+  return oneof_value_case() == kIntHexadecimalValue;
+}
+inline bool Primitive::has_int_hexadecimal_value() const {
+  return _internal_has_int_hexadecimal_value();
+}
+inline void Primitive::set_has_int_hexadecimal_value() {
+  _impl_._oneof_case_[0] = kIntHexadecimalValue;
+}
+inline void Primitive::clear_int_hexadecimal_value() {
+  if (_internal_has_int_hexadecimal_value()) {
+    _impl_.oneof_value_.int_hexadecimal_value_ = 0u;
+    clear_has_oneof_value();
+  }
+}
+inline ::uint32_t Primitive::_internal_int_hexadecimal_value() const {
+  if (_internal_has_int_hexadecimal_value()) {
+    return _impl_.oneof_value_.int_hexadecimal_value_;
+  }
+  return 0u;
+}
+inline void Primitive::_internal_set_int_hexadecimal_value(::uint32_t value) {
+  if (!_internal_has_int_hexadecimal_value()) {
+    clear_oneof_value();
+    set_has_int_hexadecimal_value();
+  }
+  _impl_.oneof_value_.int_hexadecimal_value_ = value;
+}
+inline ::uint32_t Primitive::int_hexadecimal_value() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.int_hexadecimal_value)
+  return _internal_int_hexadecimal_value();
+}
+inline void Primitive::set_int_hexadecimal_value(::uint32_t value) {
+  _internal_set_int_hexadecimal_value(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.int_hexadecimal_value)
+}
+
+// bool boolean_value = 8;
+inline bool Primitive::_internal_has_boolean_value() const {
+  return oneof_value_case() == kBooleanValue;
+}
+inline bool Primitive::has_boolean_value() const {
+  return _internal_has_boolean_value();
+}
+inline void Primitive::set_has_boolean_value() {
+  _impl_._oneof_case_[0] = kBooleanValue;
+}
+inline void Primitive::clear_boolean_value() {
+  if (_internal_has_boolean_value()) {
+    _impl_.oneof_value_.boolean_value_ = false;
+    clear_has_oneof_value();
+  }
+}
+inline bool Primitive::_internal_boolean_value() const {
+  if (_internal_has_boolean_value()) {
+    return _impl_.oneof_value_.boolean_value_;
+  }
+  return false;
+}
+inline void Primitive::_internal_set_boolean_value(bool value) {
+  if (!_internal_has_boolean_value()) {
+    clear_oneof_value();
+    set_has_boolean_value();
+  }
+  _impl_.oneof_value_.boolean_value_ = value;
+}
+inline bool Primitive::boolean_value() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.boolean_value)
+  return _internal_boolean_value();
+}
+inline void Primitive::set_boolean_value(bool value) {
+  _internal_set_boolean_value(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.boolean_value)
+}
+
+// uint32 color_argb8_value = 9;
+inline bool Primitive::_internal_has_color_argb8_value() const {
+  return oneof_value_case() == kColorArgb8Value;
+}
+inline bool Primitive::has_color_argb8_value() const {
+  return _internal_has_color_argb8_value();
+}
+inline void Primitive::set_has_color_argb8_value() {
+  _impl_._oneof_case_[0] = kColorArgb8Value;
+}
+inline void Primitive::clear_color_argb8_value() {
+  if (_internal_has_color_argb8_value()) {
+    _impl_.oneof_value_.color_argb8_value_ = 0u;
+    clear_has_oneof_value();
+  }
+}
+inline ::uint32_t Primitive::_internal_color_argb8_value() const {
+  if (_internal_has_color_argb8_value()) {
+    return _impl_.oneof_value_.color_argb8_value_;
+  }
+  return 0u;
+}
+inline void Primitive::_internal_set_color_argb8_value(::uint32_t value) {
+  if (!_internal_has_color_argb8_value()) {
+    clear_oneof_value();
+    set_has_color_argb8_value();
+  }
+  _impl_.oneof_value_.color_argb8_value_ = value;
+}
+inline ::uint32_t Primitive::color_argb8_value() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.color_argb8_value)
+  return _internal_color_argb8_value();
+}
+inline void Primitive::set_color_argb8_value(::uint32_t value) {
+  _internal_set_color_argb8_value(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.color_argb8_value)
+}
+
+// uint32 color_rgb8_value = 10;
+inline bool Primitive::_internal_has_color_rgb8_value() const {
+  return oneof_value_case() == kColorRgb8Value;
+}
+inline bool Primitive::has_color_rgb8_value() const {
+  return _internal_has_color_rgb8_value();
+}
+inline void Primitive::set_has_color_rgb8_value() {
+  _impl_._oneof_case_[0] = kColorRgb8Value;
+}
+inline void Primitive::clear_color_rgb8_value() {
+  if (_internal_has_color_rgb8_value()) {
+    _impl_.oneof_value_.color_rgb8_value_ = 0u;
+    clear_has_oneof_value();
+  }
+}
+inline ::uint32_t Primitive::_internal_color_rgb8_value() const {
+  if (_internal_has_color_rgb8_value()) {
+    return _impl_.oneof_value_.color_rgb8_value_;
+  }
+  return 0u;
+}
+inline void Primitive::_internal_set_color_rgb8_value(::uint32_t value) {
+  if (!_internal_has_color_rgb8_value()) {
+    clear_oneof_value();
+    set_has_color_rgb8_value();
+  }
+  _impl_.oneof_value_.color_rgb8_value_ = value;
+}
+inline ::uint32_t Primitive::color_rgb8_value() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.color_rgb8_value)
+  return _internal_color_rgb8_value();
+}
+inline void Primitive::set_color_rgb8_value(::uint32_t value) {
+  _internal_set_color_rgb8_value(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.color_rgb8_value)
+}
+
+// uint32 color_argb4_value = 11;
+inline bool Primitive::_internal_has_color_argb4_value() const {
+  return oneof_value_case() == kColorArgb4Value;
+}
+inline bool Primitive::has_color_argb4_value() const {
+  return _internal_has_color_argb4_value();
+}
+inline void Primitive::set_has_color_argb4_value() {
+  _impl_._oneof_case_[0] = kColorArgb4Value;
+}
+inline void Primitive::clear_color_argb4_value() {
+  if (_internal_has_color_argb4_value()) {
+    _impl_.oneof_value_.color_argb4_value_ = 0u;
+    clear_has_oneof_value();
+  }
+}
+inline ::uint32_t Primitive::_internal_color_argb4_value() const {
+  if (_internal_has_color_argb4_value()) {
+    return _impl_.oneof_value_.color_argb4_value_;
+  }
+  return 0u;
+}
+inline void Primitive::_internal_set_color_argb4_value(::uint32_t value) {
+  if (!_internal_has_color_argb4_value()) {
+    clear_oneof_value();
+    set_has_color_argb4_value();
+  }
+  _impl_.oneof_value_.color_argb4_value_ = value;
+}
+inline ::uint32_t Primitive::color_argb4_value() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.color_argb4_value)
+  return _internal_color_argb4_value();
+}
+inline void Primitive::set_color_argb4_value(::uint32_t value) {
+  _internal_set_color_argb4_value(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.color_argb4_value)
+}
+
+// uint32 color_rgb4_value = 12;
+inline bool Primitive::_internal_has_color_rgb4_value() const {
+  return oneof_value_case() == kColorRgb4Value;
+}
+inline bool Primitive::has_color_rgb4_value() const {
+  return _internal_has_color_rgb4_value();
+}
+inline void Primitive::set_has_color_rgb4_value() {
+  _impl_._oneof_case_[0] = kColorRgb4Value;
+}
+inline void Primitive::clear_color_rgb4_value() {
+  if (_internal_has_color_rgb4_value()) {
+    _impl_.oneof_value_.color_rgb4_value_ = 0u;
+    clear_has_oneof_value();
+  }
+}
+inline ::uint32_t Primitive::_internal_color_rgb4_value() const {
+  if (_internal_has_color_rgb4_value()) {
+    return _impl_.oneof_value_.color_rgb4_value_;
+  }
+  return 0u;
+}
+inline void Primitive::_internal_set_color_rgb4_value(::uint32_t value) {
+  if (!_internal_has_color_rgb4_value()) {
+    clear_oneof_value();
+    set_has_color_rgb4_value();
+  }
+  _impl_.oneof_value_.color_rgb4_value_ = value;
+}
+inline ::uint32_t Primitive::color_rgb4_value() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.color_rgb4_value)
+  return _internal_color_rgb4_value();
+}
+inline void Primitive::set_color_rgb4_value(::uint32_t value) {
+  _internal_set_color_rgb4_value(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.color_rgb4_value)
+}
+
+// float dimension_value_deprecated = 4 [deprecated = true];
+inline bool Primitive::_internal_has_dimension_value_deprecated() const {
+  return oneof_value_case() == kDimensionValueDeprecated;
+}
+inline bool Primitive::has_dimension_value_deprecated() const {
+  return _internal_has_dimension_value_deprecated();
+}
+inline void Primitive::set_has_dimension_value_deprecated() {
+  _impl_._oneof_case_[0] = kDimensionValueDeprecated;
+}
+inline void Primitive::clear_dimension_value_deprecated() {
+  if (_internal_has_dimension_value_deprecated()) {
+    _impl_.oneof_value_.dimension_value_deprecated_ = 0;
+    clear_has_oneof_value();
+  }
+}
+inline float Primitive::_internal_dimension_value_deprecated() const {
+  if (_internal_has_dimension_value_deprecated()) {
+    return _impl_.oneof_value_.dimension_value_deprecated_;
+  }
+  return 0;
+}
+inline void Primitive::_internal_set_dimension_value_deprecated(float value) {
+  if (!_internal_has_dimension_value_deprecated()) {
+    clear_oneof_value();
+    set_has_dimension_value_deprecated();
+  }
+  _impl_.oneof_value_.dimension_value_deprecated_ = value;
+}
+inline float Primitive::dimension_value_deprecated() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.dimension_value_deprecated)
+  return _internal_dimension_value_deprecated();
+}
+inline void Primitive::set_dimension_value_deprecated(float value) {
+  _internal_set_dimension_value_deprecated(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.dimension_value_deprecated)
+}
+
+// float fraction_value_deprecated = 5 [deprecated = true];
+inline bool Primitive::_internal_has_fraction_value_deprecated() const {
+  return oneof_value_case() == kFractionValueDeprecated;
+}
+inline bool Primitive::has_fraction_value_deprecated() const {
+  return _internal_has_fraction_value_deprecated();
+}
+inline void Primitive::set_has_fraction_value_deprecated() {
+  _impl_._oneof_case_[0] = kFractionValueDeprecated;
+}
+inline void Primitive::clear_fraction_value_deprecated() {
+  if (_internal_has_fraction_value_deprecated()) {
+    _impl_.oneof_value_.fraction_value_deprecated_ = 0;
+    clear_has_oneof_value();
+  }
+}
+inline float Primitive::_internal_fraction_value_deprecated() const {
+  if (_internal_has_fraction_value_deprecated()) {
+    return _impl_.oneof_value_.fraction_value_deprecated_;
+  }
+  return 0;
+}
+inline void Primitive::_internal_set_fraction_value_deprecated(float value) {
+  if (!_internal_has_fraction_value_deprecated()) {
+    clear_oneof_value();
+    set_has_fraction_value_deprecated();
+  }
+  _impl_.oneof_value_.fraction_value_deprecated_ = value;
+}
+inline float Primitive::fraction_value_deprecated() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.fraction_value_deprecated)
+  return _internal_fraction_value_deprecated();
+}
+inline void Primitive::set_fraction_value_deprecated(float value) {
+  _internal_set_fraction_value_deprecated(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.fraction_value_deprecated)
+}
+
+inline bool Primitive::has_oneof_value() const {
+  return oneof_value_case() != ONEOF_VALUE_NOT_SET;
+}
+inline void Primitive::clear_has_oneof_value() {
+  _impl_._oneof_case_[0] = ONEOF_VALUE_NOT_SET;
+}
+inline Primitive::OneofValueCase Primitive::oneof_value_case() const {
+  return Primitive::OneofValueCase(_impl_._oneof_case_[0]);
+}
+// -------------------------------------------------------------------
+
+// Attribute_Symbol
+
+// .aapt.pb.Source source = 1;
+inline bool Attribute_Symbol::_internal_has_source() const {
+  return this != internal_default_instance() && _impl_.source_ != nullptr;
+}
+inline bool Attribute_Symbol::has_source() const {
+  return _internal_has_source();
+}
+inline void Attribute_Symbol::clear_source() {
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+}
+inline const ::aapt::pb::Source& Attribute_Symbol::_internal_source() const {
+  const ::aapt::pb::Source* p = _impl_.source_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
+      ::aapt::pb::_Source_default_instance_);
+}
+inline const ::aapt::pb::Source& Attribute_Symbol::source() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.source)
+  return _internal_source();
+}
+inline void Attribute_Symbol::unsafe_arena_set_allocated_source(
+    ::aapt::pb::Source* source) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Attribute.Symbol.source)
+}
+inline ::aapt::pb::Source* Attribute_Symbol::release_source() {
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Source* Attribute_Symbol::unsafe_arena_release_source() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Attribute.Symbol.source)
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Source* Attribute_Symbol::_internal_mutable_source() {
+  
+  if (_impl_.source_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
+    _impl_.source_ = p;
+  }
+  return _impl_.source_;
+}
+inline ::aapt::pb::Source* Attribute_Symbol::mutable_source() {
+  ::aapt::pb::Source* _msg = _internal_mutable_source();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Attribute.Symbol.source)
+  return _msg;
+}
+inline void Attribute_Symbol::set_allocated_source(::aapt::pb::Source* source) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.source_;
+  }
+  if (source) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
+    if (message_arena != submessage_arena) {
+      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, source, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Attribute.Symbol.source)
+}
+
+// string comment = 2;
+inline void Attribute_Symbol::clear_comment() {
+  _impl_.comment_.ClearToEmpty();
+}
+inline const std::string& Attribute_Symbol::comment() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.comment)
+  return _internal_comment();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void Attribute_Symbol::set_comment(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.Symbol.comment)
+}
+inline std::string* Attribute_Symbol::mutable_comment() {
+  std::string* _s = _internal_mutable_comment();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Attribute.Symbol.comment)
+  return _s;
+}
+inline const std::string& Attribute_Symbol::_internal_comment() const {
+  return _impl_.comment_.Get();
+}
+inline void Attribute_Symbol::_internal_set_comment(const std::string& value) {
+  
+  _impl_.comment_.Set(value, GetArenaForAllocation());
+}
+inline std::string* Attribute_Symbol::_internal_mutable_comment() {
+  
+  return _impl_.comment_.Mutable(GetArenaForAllocation());
+}
+inline std::string* Attribute_Symbol::release_comment() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Attribute.Symbol.comment)
+  return _impl_.comment_.Release();
+}
+inline void Attribute_Symbol::set_allocated_comment(std::string* comment) {
+  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.comment_.IsDefault()) {
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Attribute.Symbol.comment)
+}
+
+// .aapt.pb.Reference name = 3;
+inline bool Attribute_Symbol::_internal_has_name() const {
+  return this != internal_default_instance() && _impl_.name_ != nullptr;
+}
+inline bool Attribute_Symbol::has_name() const {
+  return _internal_has_name();
+}
+inline void Attribute_Symbol::clear_name() {
+  if (GetArenaForAllocation() == nullptr && _impl_.name_ != nullptr) {
+    delete _impl_.name_;
+  }
+  _impl_.name_ = nullptr;
+}
+inline const ::aapt::pb::Reference& Attribute_Symbol::_internal_name() const {
+  const ::aapt::pb::Reference* p = _impl_.name_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Reference&>(
+      ::aapt::pb::_Reference_default_instance_);
+}
+inline const ::aapt::pb::Reference& Attribute_Symbol::name() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.name)
+  return _internal_name();
+}
+inline void Attribute_Symbol::unsafe_arena_set_allocated_name(
+    ::aapt::pb::Reference* name) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.name_);
+  }
+  _impl_.name_ = name;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Attribute.Symbol.name)
+}
+inline ::aapt::pb::Reference* Attribute_Symbol::release_name() {
+  
+  ::aapt::pb::Reference* temp = _impl_.name_;
+  _impl_.name_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Reference* Attribute_Symbol::unsafe_arena_release_name() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Attribute.Symbol.name)
+  
+  ::aapt::pb::Reference* temp = _impl_.name_;
+  _impl_.name_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Reference* Attribute_Symbol::_internal_mutable_name() {
+  
+  if (_impl_.name_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Reference>(GetArenaForAllocation());
+    _impl_.name_ = p;
+  }
+  return _impl_.name_;
+}
+inline ::aapt::pb::Reference* Attribute_Symbol::mutable_name() {
+  ::aapt::pb::Reference* _msg = _internal_mutable_name();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Attribute.Symbol.name)
+  return _msg;
+}
+inline void Attribute_Symbol::set_allocated_name(::aapt::pb::Reference* name) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.name_;
+  }
+  if (name) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(name);
+    if (message_arena != submessage_arena) {
+      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, name, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.name_ = name;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Attribute.Symbol.name)
+}
+
+// uint32 value = 4;
+inline void Attribute_Symbol::clear_value() {
+  _impl_.value_ = 0u;
+}
+inline ::uint32_t Attribute_Symbol::_internal_value() const {
+  return _impl_.value_;
+}
+inline ::uint32_t Attribute_Symbol::value() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.value)
+  return _internal_value();
+}
+inline void Attribute_Symbol::_internal_set_value(::uint32_t value) {
+  
+  _impl_.value_ = value;
+}
+inline void Attribute_Symbol::set_value(::uint32_t value) {
+  _internal_set_value(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.Symbol.value)
+}
+
+// uint32 type = 5;
+inline void Attribute_Symbol::clear_type() {
+  _impl_.type_ = 0u;
+}
+inline ::uint32_t Attribute_Symbol::_internal_type() const {
+  return _impl_.type_;
+}
+inline ::uint32_t Attribute_Symbol::type() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.type)
+  return _internal_type();
+}
+inline void Attribute_Symbol::_internal_set_type(::uint32_t value) {
+  
+  _impl_.type_ = value;
+}
+inline void Attribute_Symbol::set_type(::uint32_t value) {
+  _internal_set_type(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.Symbol.type)
+}
+
+// -------------------------------------------------------------------
+
+// Attribute
+
+// uint32 format_flags = 1;
+inline void Attribute::clear_format_flags() {
+  _impl_.format_flags_ = 0u;
+}
+inline ::uint32_t Attribute::_internal_format_flags() const {
+  return _impl_.format_flags_;
+}
+inline ::uint32_t Attribute::format_flags() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.format_flags)
+  return _internal_format_flags();
+}
+inline void Attribute::_internal_set_format_flags(::uint32_t value) {
+  
+  _impl_.format_flags_ = value;
+}
+inline void Attribute::set_format_flags(::uint32_t value) {
+  _internal_set_format_flags(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.format_flags)
+}
+
+// int32 min_int = 2;
+inline void Attribute::clear_min_int() {
+  _impl_.min_int_ = 0;
+}
+inline ::int32_t Attribute::_internal_min_int() const {
+  return _impl_.min_int_;
+}
+inline ::int32_t Attribute::min_int() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.min_int)
+  return _internal_min_int();
+}
+inline void Attribute::_internal_set_min_int(::int32_t value) {
+  
+  _impl_.min_int_ = value;
+}
+inline void Attribute::set_min_int(::int32_t value) {
+  _internal_set_min_int(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.min_int)
+}
+
+// int32 max_int = 3;
+inline void Attribute::clear_max_int() {
+  _impl_.max_int_ = 0;
+}
+inline ::int32_t Attribute::_internal_max_int() const {
+  return _impl_.max_int_;
+}
+inline ::int32_t Attribute::max_int() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.max_int)
+  return _internal_max_int();
+}
+inline void Attribute::_internal_set_max_int(::int32_t value) {
+  
+  _impl_.max_int_ = value;
+}
+inline void Attribute::set_max_int(::int32_t value) {
+  _internal_set_max_int(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.max_int)
+}
+
+// repeated .aapt.pb.Attribute.Symbol symbol = 4;
+inline int Attribute::_internal_symbol_size() const {
+  return _impl_.symbol_.size();
+}
+inline int Attribute::symbol_size() const {
+  return _internal_symbol_size();
+}
+inline void Attribute::clear_symbol() {
+  _impl_.symbol_.Clear();
+}
+inline ::aapt::pb::Attribute_Symbol* Attribute::mutable_symbol(int index) {
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Attribute.symbol)
+  return _impl_.symbol_.Mutable(index);
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Attribute_Symbol >*
+Attribute::mutable_symbol() {
+  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Attribute.symbol)
+  return &_impl_.symbol_;
+}
+inline const ::aapt::pb::Attribute_Symbol& Attribute::_internal_symbol(int index) const {
+  return _impl_.symbol_.Get(index);
+}
+inline const ::aapt::pb::Attribute_Symbol& Attribute::symbol(int index) const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.symbol)
+  return _internal_symbol(index);
+}
+inline ::aapt::pb::Attribute_Symbol* Attribute::_internal_add_symbol() {
+  return _impl_.symbol_.Add();
+}
+inline ::aapt::pb::Attribute_Symbol* Attribute::add_symbol() {
+  ::aapt::pb::Attribute_Symbol* _add = _internal_add_symbol();
+  // @@protoc_insertion_point(field_add:aapt.pb.Attribute.symbol)
+  return _add;
+}
+inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Attribute_Symbol >&
+Attribute::symbol() const {
+  // @@protoc_insertion_point(field_list:aapt.pb.Attribute.symbol)
+  return _impl_.symbol_;
+}
+
+// -------------------------------------------------------------------
+
+// Style_Entry
+
+// .aapt.pb.Source source = 1;
+inline bool Style_Entry::_internal_has_source() const {
+  return this != internal_default_instance() && _impl_.source_ != nullptr;
+}
+inline bool Style_Entry::has_source() const {
+  return _internal_has_source();
+}
+inline void Style_Entry::clear_source() {
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+}
+inline const ::aapt::pb::Source& Style_Entry::_internal_source() const {
+  const ::aapt::pb::Source* p = _impl_.source_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
+      ::aapt::pb::_Source_default_instance_);
+}
+inline const ::aapt::pb::Source& Style_Entry::source() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Style.Entry.source)
+  return _internal_source();
+}
+inline void Style_Entry::unsafe_arena_set_allocated_source(
+    ::aapt::pb::Source* source) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Style.Entry.source)
+}
+inline ::aapt::pb::Source* Style_Entry::release_source() {
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Source* Style_Entry::unsafe_arena_release_source() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Style.Entry.source)
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Source* Style_Entry::_internal_mutable_source() {
+  
+  if (_impl_.source_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
+    _impl_.source_ = p;
+  }
+  return _impl_.source_;
+}
+inline ::aapt::pb::Source* Style_Entry::mutable_source() {
+  ::aapt::pb::Source* _msg = _internal_mutable_source();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.Entry.source)
+  return _msg;
+}
+inline void Style_Entry::set_allocated_source(::aapt::pb::Source* source) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.source_;
+  }
+  if (source) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
+    if (message_arena != submessage_arena) {
+      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, source, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.Entry.source)
+}
+
+// string comment = 2;
+inline void Style_Entry::clear_comment() {
+  _impl_.comment_.ClearToEmpty();
+}
+inline const std::string& Style_Entry::comment() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Style.Entry.comment)
+  return _internal_comment();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void Style_Entry::set_comment(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.Style.Entry.comment)
+}
+inline std::string* Style_Entry::mutable_comment() {
+  std::string* _s = _internal_mutable_comment();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.Entry.comment)
+  return _s;
+}
+inline const std::string& Style_Entry::_internal_comment() const {
+  return _impl_.comment_.Get();
+}
+inline void Style_Entry::_internal_set_comment(const std::string& value) {
+  
+  _impl_.comment_.Set(value, GetArenaForAllocation());
+}
+inline std::string* Style_Entry::_internal_mutable_comment() {
+  
+  return _impl_.comment_.Mutable(GetArenaForAllocation());
+}
+inline std::string* Style_Entry::release_comment() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Style.Entry.comment)
+  return _impl_.comment_.Release();
+}
+inline void Style_Entry::set_allocated_comment(std::string* comment) {
+  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.comment_.IsDefault()) {
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.Entry.comment)
+}
+
+// .aapt.pb.Reference key = 3;
+inline bool Style_Entry::_internal_has_key() const {
+  return this != internal_default_instance() && _impl_.key_ != nullptr;
+}
+inline bool Style_Entry::has_key() const {
+  return _internal_has_key();
+}
+inline void Style_Entry::clear_key() {
+  if (GetArenaForAllocation() == nullptr && _impl_.key_ != nullptr) {
+    delete _impl_.key_;
+  }
+  _impl_.key_ = nullptr;
+}
+inline const ::aapt::pb::Reference& Style_Entry::_internal_key() const {
+  const ::aapt::pb::Reference* p = _impl_.key_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Reference&>(
+      ::aapt::pb::_Reference_default_instance_);
+}
+inline const ::aapt::pb::Reference& Style_Entry::key() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Style.Entry.key)
+  return _internal_key();
+}
+inline void Style_Entry::unsafe_arena_set_allocated_key(
+    ::aapt::pb::Reference* key) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
+  }
+  _impl_.key_ = key;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Style.Entry.key)
+}
+inline ::aapt::pb::Reference* Style_Entry::release_key() {
+  
+  ::aapt::pb::Reference* temp = _impl_.key_;
+  _impl_.key_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Reference* Style_Entry::unsafe_arena_release_key() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Style.Entry.key)
+  
+  ::aapt::pb::Reference* temp = _impl_.key_;
+  _impl_.key_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Reference* Style_Entry::_internal_mutable_key() {
+  
+  if (_impl_.key_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Reference>(GetArenaForAllocation());
+    _impl_.key_ = p;
+  }
+  return _impl_.key_;
+}
+inline ::aapt::pb::Reference* Style_Entry::mutable_key() {
+  ::aapt::pb::Reference* _msg = _internal_mutable_key();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.Entry.key)
+  return _msg;
+}
+inline void Style_Entry::set_allocated_key(::aapt::pb::Reference* key) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.key_;
+  }
+  if (key) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
+    if (message_arena != submessage_arena) {
+      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, key, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.key_ = key;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.Entry.key)
+}
+
+// .aapt.pb.Item item = 4;
+inline bool Style_Entry::_internal_has_item() const {
+  return this != internal_default_instance() && _impl_.item_ != nullptr;
+}
+inline bool Style_Entry::has_item() const {
+  return _internal_has_item();
+}
+inline void Style_Entry::clear_item() {
+  if (GetArenaForAllocation() == nullptr && _impl_.item_ != nullptr) {
+    delete _impl_.item_;
+  }
+  _impl_.item_ = nullptr;
+}
+inline const ::aapt::pb::Item& Style_Entry::_internal_item() const {
+  const ::aapt::pb::Item* p = _impl_.item_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Item&>(
+      ::aapt::pb::_Item_default_instance_);
+}
+inline const ::aapt::pb::Item& Style_Entry::item() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Style.Entry.item)
+  return _internal_item();
+}
+inline void Style_Entry::unsafe_arena_set_allocated_item(
+    ::aapt::pb::Item* item) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
+  }
+  _impl_.item_ = item;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Style.Entry.item)
+}
+inline ::aapt::pb::Item* Style_Entry::release_item() {
+  
+  ::aapt::pb::Item* temp = _impl_.item_;
+  _impl_.item_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Item* Style_Entry::unsafe_arena_release_item() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Style.Entry.item)
+  
+  ::aapt::pb::Item* temp = _impl_.item_;
+  _impl_.item_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Item* Style_Entry::_internal_mutable_item() {
+  
+  if (_impl_.item_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Item>(GetArenaForAllocation());
+    _impl_.item_ = p;
+  }
+  return _impl_.item_;
+}
+inline ::aapt::pb::Item* Style_Entry::mutable_item() {
+  ::aapt::pb::Item* _msg = _internal_mutable_item();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.Entry.item)
+  return _msg;
+}
+inline void Style_Entry::set_allocated_item(::aapt::pb::Item* item) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.item_;
+  }
+  if (item) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
+    if (message_arena != submessage_arena) {
+      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, item, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.item_ = item;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.Entry.item)
+}
+
+// -------------------------------------------------------------------
+
+// Style
+
+// .aapt.pb.Reference parent = 1;
+inline bool Style::_internal_has_parent() const {
+  return this != internal_default_instance() && _impl_.parent_ != nullptr;
+}
+inline bool Style::has_parent() const {
+  return _internal_has_parent();
+}
+inline void Style::clear_parent() {
+  if (GetArenaForAllocation() == nullptr && _impl_.parent_ != nullptr) {
+    delete _impl_.parent_;
+  }
+  _impl_.parent_ = nullptr;
+}
+inline const ::aapt::pb::Reference& Style::_internal_parent() const {
+  const ::aapt::pb::Reference* p = _impl_.parent_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Reference&>(
+      ::aapt::pb::_Reference_default_instance_);
+}
+inline const ::aapt::pb::Reference& Style::parent() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Style.parent)
+  return _internal_parent();
+}
+inline void Style::unsafe_arena_set_allocated_parent(
+    ::aapt::pb::Reference* parent) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
+  }
+  _impl_.parent_ = parent;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Style.parent)
+}
+inline ::aapt::pb::Reference* Style::release_parent() {
+  
+  ::aapt::pb::Reference* temp = _impl_.parent_;
+  _impl_.parent_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Reference* Style::unsafe_arena_release_parent() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Style.parent)
+  
+  ::aapt::pb::Reference* temp = _impl_.parent_;
+  _impl_.parent_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Reference* Style::_internal_mutable_parent() {
+  
+  if (_impl_.parent_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Reference>(GetArenaForAllocation());
+    _impl_.parent_ = p;
+  }
+  return _impl_.parent_;
+}
+inline ::aapt::pb::Reference* Style::mutable_parent() {
+  ::aapt::pb::Reference* _msg = _internal_mutable_parent();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.parent)
+  return _msg;
+}
+inline void Style::set_allocated_parent(::aapt::pb::Reference* parent) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.parent_;
+  }
+  if (parent) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
+    if (message_arena != submessage_arena) {
+      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, parent, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.parent_ = parent;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.parent)
+}
+
+// .aapt.pb.Source parent_source = 2;
+inline bool Style::_internal_has_parent_source() const {
+  return this != internal_default_instance() && _impl_.parent_source_ != nullptr;
+}
+inline bool Style::has_parent_source() const {
+  return _internal_has_parent_source();
+}
+inline void Style::clear_parent_source() {
+  if (GetArenaForAllocation() == nullptr && _impl_.parent_source_ != nullptr) {
+    delete _impl_.parent_source_;
+  }
+  _impl_.parent_source_ = nullptr;
+}
+inline const ::aapt::pb::Source& Style::_internal_parent_source() const {
+  const ::aapt::pb::Source* p = _impl_.parent_source_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
+      ::aapt::pb::_Source_default_instance_);
+}
+inline const ::aapt::pb::Source& Style::parent_source() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Style.parent_source)
+  return _internal_parent_source();
+}
+inline void Style::unsafe_arena_set_allocated_parent_source(
+    ::aapt::pb::Source* parent_source) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_source_);
+  }
+  _impl_.parent_source_ = parent_source;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Style.parent_source)
+}
+inline ::aapt::pb::Source* Style::release_parent_source() {
+  
+  ::aapt::pb::Source* temp = _impl_.parent_source_;
+  _impl_.parent_source_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Source* Style::unsafe_arena_release_parent_source() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Style.parent_source)
+  
+  ::aapt::pb::Source* temp = _impl_.parent_source_;
+  _impl_.parent_source_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Source* Style::_internal_mutable_parent_source() {
+  
+  if (_impl_.parent_source_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
+    _impl_.parent_source_ = p;
+  }
+  return _impl_.parent_source_;
+}
+inline ::aapt::pb::Source* Style::mutable_parent_source() {
+  ::aapt::pb::Source* _msg = _internal_mutable_parent_source();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.parent_source)
+  return _msg;
+}
+inline void Style::set_allocated_parent_source(::aapt::pb::Source* parent_source) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.parent_source_;
+  }
+  if (parent_source) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent_source);
+    if (message_arena != submessage_arena) {
+      parent_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, parent_source, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.parent_source_ = parent_source;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.parent_source)
+}
+
+// repeated .aapt.pb.Style.Entry entry = 3;
+inline int Style::_internal_entry_size() const {
+  return _impl_.entry_.size();
+}
+inline int Style::entry_size() const {
+  return _internal_entry_size();
+}
+inline void Style::clear_entry() {
+  _impl_.entry_.Clear();
+}
+inline ::aapt::pb::Style_Entry* Style::mutable_entry(int index) {
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.entry)
+  return _impl_.entry_.Mutable(index);
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Style_Entry >*
+Style::mutable_entry() {
+  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Style.entry)
+  return &_impl_.entry_;
+}
+inline const ::aapt::pb::Style_Entry& Style::_internal_entry(int index) const {
+  return _impl_.entry_.Get(index);
+}
+inline const ::aapt::pb::Style_Entry& Style::entry(int index) const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Style.entry)
+  return _internal_entry(index);
+}
+inline ::aapt::pb::Style_Entry* Style::_internal_add_entry() {
+  return _impl_.entry_.Add();
+}
+inline ::aapt::pb::Style_Entry* Style::add_entry() {
+  ::aapt::pb::Style_Entry* _add = _internal_add_entry();
+  // @@protoc_insertion_point(field_add:aapt.pb.Style.entry)
+  return _add;
+}
+inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Style_Entry >&
+Style::entry() const {
+  // @@protoc_insertion_point(field_list:aapt.pb.Style.entry)
+  return _impl_.entry_;
+}
+
+// -------------------------------------------------------------------
+
+// Styleable_Entry
+
+// .aapt.pb.Source source = 1;
+inline bool Styleable_Entry::_internal_has_source() const {
+  return this != internal_default_instance() && _impl_.source_ != nullptr;
+}
+inline bool Styleable_Entry::has_source() const {
+  return _internal_has_source();
+}
+inline void Styleable_Entry::clear_source() {
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+}
+inline const ::aapt::pb::Source& Styleable_Entry::_internal_source() const {
+  const ::aapt::pb::Source* p = _impl_.source_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
+      ::aapt::pb::_Source_default_instance_);
+}
+inline const ::aapt::pb::Source& Styleable_Entry::source() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Styleable.Entry.source)
+  return _internal_source();
+}
+inline void Styleable_Entry::unsafe_arena_set_allocated_source(
+    ::aapt::pb::Source* source) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Styleable.Entry.source)
+}
+inline ::aapt::pb::Source* Styleable_Entry::release_source() {
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Source* Styleable_Entry::unsafe_arena_release_source() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Styleable.Entry.source)
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Source* Styleable_Entry::_internal_mutable_source() {
+  
+  if (_impl_.source_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
+    _impl_.source_ = p;
+  }
+  return _impl_.source_;
+}
+inline ::aapt::pb::Source* Styleable_Entry::mutable_source() {
+  ::aapt::pb::Source* _msg = _internal_mutable_source();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Styleable.Entry.source)
+  return _msg;
+}
+inline void Styleable_Entry::set_allocated_source(::aapt::pb::Source* source) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.source_;
+  }
+  if (source) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
+    if (message_arena != submessage_arena) {
+      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, source, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Styleable.Entry.source)
+}
+
+// string comment = 2;
+inline void Styleable_Entry::clear_comment() {
+  _impl_.comment_.ClearToEmpty();
+}
+inline const std::string& Styleable_Entry::comment() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Styleable.Entry.comment)
+  return _internal_comment();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void Styleable_Entry::set_comment(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.Styleable.Entry.comment)
+}
+inline std::string* Styleable_Entry::mutable_comment() {
+  std::string* _s = _internal_mutable_comment();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Styleable.Entry.comment)
+  return _s;
+}
+inline const std::string& Styleable_Entry::_internal_comment() const {
+  return _impl_.comment_.Get();
+}
+inline void Styleable_Entry::_internal_set_comment(const std::string& value) {
+  
+  _impl_.comment_.Set(value, GetArenaForAllocation());
+}
+inline std::string* Styleable_Entry::_internal_mutable_comment() {
+  
+  return _impl_.comment_.Mutable(GetArenaForAllocation());
+}
+inline std::string* Styleable_Entry::release_comment() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Styleable.Entry.comment)
+  return _impl_.comment_.Release();
+}
+inline void Styleable_Entry::set_allocated_comment(std::string* comment) {
+  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.comment_.IsDefault()) {
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Styleable.Entry.comment)
+}
+
+// .aapt.pb.Reference attr = 3;
+inline bool Styleable_Entry::_internal_has_attr() const {
+  return this != internal_default_instance() && _impl_.attr_ != nullptr;
+}
+inline bool Styleable_Entry::has_attr() const {
+  return _internal_has_attr();
+}
+inline void Styleable_Entry::clear_attr() {
+  if (GetArenaForAllocation() == nullptr && _impl_.attr_ != nullptr) {
+    delete _impl_.attr_;
+  }
+  _impl_.attr_ = nullptr;
+}
+inline const ::aapt::pb::Reference& Styleable_Entry::_internal_attr() const {
+  const ::aapt::pb::Reference* p = _impl_.attr_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Reference&>(
+      ::aapt::pb::_Reference_default_instance_);
+}
+inline const ::aapt::pb::Reference& Styleable_Entry::attr() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Styleable.Entry.attr)
+  return _internal_attr();
+}
+inline void Styleable_Entry::unsafe_arena_set_allocated_attr(
+    ::aapt::pb::Reference* attr) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attr_);
+  }
+  _impl_.attr_ = attr;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Styleable.Entry.attr)
+}
+inline ::aapt::pb::Reference* Styleable_Entry::release_attr() {
+  
+  ::aapt::pb::Reference* temp = _impl_.attr_;
+  _impl_.attr_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Reference* Styleable_Entry::unsafe_arena_release_attr() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Styleable.Entry.attr)
+  
+  ::aapt::pb::Reference* temp = _impl_.attr_;
+  _impl_.attr_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Reference* Styleable_Entry::_internal_mutable_attr() {
+  
+  if (_impl_.attr_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Reference>(GetArenaForAllocation());
+    _impl_.attr_ = p;
+  }
+  return _impl_.attr_;
+}
+inline ::aapt::pb::Reference* Styleable_Entry::mutable_attr() {
+  ::aapt::pb::Reference* _msg = _internal_mutable_attr();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Styleable.Entry.attr)
+  return _msg;
+}
+inline void Styleable_Entry::set_allocated_attr(::aapt::pb::Reference* attr) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.attr_;
+  }
+  if (attr) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attr);
+    if (message_arena != submessage_arena) {
+      attr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, attr, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.attr_ = attr;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Styleable.Entry.attr)
+}
+
+// -------------------------------------------------------------------
+
+// Styleable
+
+// repeated .aapt.pb.Styleable.Entry entry = 1;
+inline int Styleable::_internal_entry_size() const {
+  return _impl_.entry_.size();
+}
+inline int Styleable::entry_size() const {
+  return _internal_entry_size();
+}
+inline void Styleable::clear_entry() {
+  _impl_.entry_.Clear();
+}
+inline ::aapt::pb::Styleable_Entry* Styleable::mutable_entry(int index) {
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Styleable.entry)
+  return _impl_.entry_.Mutable(index);
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Styleable_Entry >*
+Styleable::mutable_entry() {
+  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Styleable.entry)
+  return &_impl_.entry_;
+}
+inline const ::aapt::pb::Styleable_Entry& Styleable::_internal_entry(int index) const {
+  return _impl_.entry_.Get(index);
+}
+inline const ::aapt::pb::Styleable_Entry& Styleable::entry(int index) const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Styleable.entry)
+  return _internal_entry(index);
+}
+inline ::aapt::pb::Styleable_Entry* Styleable::_internal_add_entry() {
+  return _impl_.entry_.Add();
+}
+inline ::aapt::pb::Styleable_Entry* Styleable::add_entry() {
+  ::aapt::pb::Styleable_Entry* _add = _internal_add_entry();
+  // @@protoc_insertion_point(field_add:aapt.pb.Styleable.entry)
+  return _add;
+}
+inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Styleable_Entry >&
+Styleable::entry() const {
+  // @@protoc_insertion_point(field_list:aapt.pb.Styleable.entry)
+  return _impl_.entry_;
+}
+
+// -------------------------------------------------------------------
+
+// Array_Element
+
+// .aapt.pb.Source source = 1;
+inline bool Array_Element::_internal_has_source() const {
+  return this != internal_default_instance() && _impl_.source_ != nullptr;
+}
+inline bool Array_Element::has_source() const {
+  return _internal_has_source();
+}
+inline void Array_Element::clear_source() {
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+}
+inline const ::aapt::pb::Source& Array_Element::_internal_source() const {
+  const ::aapt::pb::Source* p = _impl_.source_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
+      ::aapt::pb::_Source_default_instance_);
+}
+inline const ::aapt::pb::Source& Array_Element::source() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Array.Element.source)
+  return _internal_source();
+}
+inline void Array_Element::unsafe_arena_set_allocated_source(
+    ::aapt::pb::Source* source) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Array.Element.source)
+}
+inline ::aapt::pb::Source* Array_Element::release_source() {
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Source* Array_Element::unsafe_arena_release_source() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Array.Element.source)
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Source* Array_Element::_internal_mutable_source() {
+  
+  if (_impl_.source_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
+    _impl_.source_ = p;
+  }
+  return _impl_.source_;
+}
+inline ::aapt::pb::Source* Array_Element::mutable_source() {
+  ::aapt::pb::Source* _msg = _internal_mutable_source();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Array.Element.source)
+  return _msg;
+}
+inline void Array_Element::set_allocated_source(::aapt::pb::Source* source) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.source_;
+  }
+  if (source) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
+    if (message_arena != submessage_arena) {
+      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, source, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Array.Element.source)
+}
+
+// string comment = 2;
+inline void Array_Element::clear_comment() {
+  _impl_.comment_.ClearToEmpty();
+}
+inline const std::string& Array_Element::comment() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Array.Element.comment)
+  return _internal_comment();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void Array_Element::set_comment(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.Array.Element.comment)
+}
+inline std::string* Array_Element::mutable_comment() {
+  std::string* _s = _internal_mutable_comment();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Array.Element.comment)
+  return _s;
+}
+inline const std::string& Array_Element::_internal_comment() const {
+  return _impl_.comment_.Get();
+}
+inline void Array_Element::_internal_set_comment(const std::string& value) {
+  
+  _impl_.comment_.Set(value, GetArenaForAllocation());
+}
+inline std::string* Array_Element::_internal_mutable_comment() {
+  
+  return _impl_.comment_.Mutable(GetArenaForAllocation());
+}
+inline std::string* Array_Element::release_comment() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Array.Element.comment)
+  return _impl_.comment_.Release();
+}
+inline void Array_Element::set_allocated_comment(std::string* comment) {
+  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.comment_.IsDefault()) {
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Array.Element.comment)
+}
+
+// .aapt.pb.Item item = 3;
+inline bool Array_Element::_internal_has_item() const {
+  return this != internal_default_instance() && _impl_.item_ != nullptr;
+}
+inline bool Array_Element::has_item() const {
+  return _internal_has_item();
+}
+inline void Array_Element::clear_item() {
+  if (GetArenaForAllocation() == nullptr && _impl_.item_ != nullptr) {
+    delete _impl_.item_;
+  }
+  _impl_.item_ = nullptr;
+}
+inline const ::aapt::pb::Item& Array_Element::_internal_item() const {
+  const ::aapt::pb::Item* p = _impl_.item_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Item&>(
+      ::aapt::pb::_Item_default_instance_);
+}
+inline const ::aapt::pb::Item& Array_Element::item() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Array.Element.item)
+  return _internal_item();
+}
+inline void Array_Element::unsafe_arena_set_allocated_item(
+    ::aapt::pb::Item* item) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
+  }
+  _impl_.item_ = item;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Array.Element.item)
+}
+inline ::aapt::pb::Item* Array_Element::release_item() {
+  
+  ::aapt::pb::Item* temp = _impl_.item_;
+  _impl_.item_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Item* Array_Element::unsafe_arena_release_item() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Array.Element.item)
+  
+  ::aapt::pb::Item* temp = _impl_.item_;
+  _impl_.item_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Item* Array_Element::_internal_mutable_item() {
+  
+  if (_impl_.item_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Item>(GetArenaForAllocation());
+    _impl_.item_ = p;
+  }
+  return _impl_.item_;
+}
+inline ::aapt::pb::Item* Array_Element::mutable_item() {
+  ::aapt::pb::Item* _msg = _internal_mutable_item();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Array.Element.item)
+  return _msg;
+}
+inline void Array_Element::set_allocated_item(::aapt::pb::Item* item) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.item_;
+  }
+  if (item) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
+    if (message_arena != submessage_arena) {
+      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, item, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.item_ = item;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Array.Element.item)
+}
+
+// -------------------------------------------------------------------
+
+// Array
+
+// repeated .aapt.pb.Array.Element element = 1;
+inline int Array::_internal_element_size() const {
+  return _impl_.element_.size();
+}
+inline int Array::element_size() const {
+  return _internal_element_size();
+}
+inline void Array::clear_element() {
+  _impl_.element_.Clear();
+}
+inline ::aapt::pb::Array_Element* Array::mutable_element(int index) {
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Array.element)
+  return _impl_.element_.Mutable(index);
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Array_Element >*
+Array::mutable_element() {
+  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Array.element)
+  return &_impl_.element_;
+}
+inline const ::aapt::pb::Array_Element& Array::_internal_element(int index) const {
+  return _impl_.element_.Get(index);
+}
+inline const ::aapt::pb::Array_Element& Array::element(int index) const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Array.element)
+  return _internal_element(index);
+}
+inline ::aapt::pb::Array_Element* Array::_internal_add_element() {
+  return _impl_.element_.Add();
+}
+inline ::aapt::pb::Array_Element* Array::add_element() {
+  ::aapt::pb::Array_Element* _add = _internal_add_element();
+  // @@protoc_insertion_point(field_add:aapt.pb.Array.element)
+  return _add;
+}
+inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Array_Element >&
+Array::element() const {
+  // @@protoc_insertion_point(field_list:aapt.pb.Array.element)
+  return _impl_.element_;
+}
+
+// -------------------------------------------------------------------
+
+// Plural_Entry
+
+// .aapt.pb.Source source = 1;
+inline bool Plural_Entry::_internal_has_source() const {
+  return this != internal_default_instance() && _impl_.source_ != nullptr;
+}
+inline bool Plural_Entry::has_source() const {
+  return _internal_has_source();
+}
+inline void Plural_Entry::clear_source() {
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+}
+inline const ::aapt::pb::Source& Plural_Entry::_internal_source() const {
+  const ::aapt::pb::Source* p = _impl_.source_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Source&>(
+      ::aapt::pb::_Source_default_instance_);
+}
+inline const ::aapt::pb::Source& Plural_Entry::source() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Plural.Entry.source)
+  return _internal_source();
+}
+inline void Plural_Entry::unsafe_arena_set_allocated_source(
+    ::aapt::pb::Source* source) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Plural.Entry.source)
+}
+inline ::aapt::pb::Source* Plural_Entry::release_source() {
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Source* Plural_Entry::unsafe_arena_release_source() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Plural.Entry.source)
+  
+  ::aapt::pb::Source* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Source* Plural_Entry::_internal_mutable_source() {
+  
+  if (_impl_.source_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Source>(GetArenaForAllocation());
+    _impl_.source_ = p;
+  }
+  return _impl_.source_;
+}
+inline ::aapt::pb::Source* Plural_Entry::mutable_source() {
+  ::aapt::pb::Source* _msg = _internal_mutable_source();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Plural.Entry.source)
+  return _msg;
+}
+inline void Plural_Entry::set_allocated_source(::aapt::pb::Source* source) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.source_;
+  }
+  if (source) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
+    if (message_arena != submessage_arena) {
+      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, source, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Plural.Entry.source)
+}
+
+// string comment = 2;
+inline void Plural_Entry::clear_comment() {
+  _impl_.comment_.ClearToEmpty();
+}
+inline const std::string& Plural_Entry::comment() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Plural.Entry.comment)
+  return _internal_comment();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void Plural_Entry::set_comment(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.Plural.Entry.comment)
+}
+inline std::string* Plural_Entry::mutable_comment() {
+  std::string* _s = _internal_mutable_comment();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Plural.Entry.comment)
+  return _s;
+}
+inline const std::string& Plural_Entry::_internal_comment() const {
+  return _impl_.comment_.Get();
+}
+inline void Plural_Entry::_internal_set_comment(const std::string& value) {
+  
+  _impl_.comment_.Set(value, GetArenaForAllocation());
+}
+inline std::string* Plural_Entry::_internal_mutable_comment() {
+  
+  return _impl_.comment_.Mutable(GetArenaForAllocation());
+}
+inline std::string* Plural_Entry::release_comment() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Plural.Entry.comment)
+  return _impl_.comment_.Release();
+}
+inline void Plural_Entry::set_allocated_comment(std::string* comment) {
+  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.comment_.IsDefault()) {
+    _impl_.comment_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Plural.Entry.comment)
+}
+
+// .aapt.pb.Plural.Arity arity = 3;
+inline void Plural_Entry::clear_arity() {
+  _impl_.arity_ = 0;
+}
+inline ::aapt::pb::Plural_Arity Plural_Entry::_internal_arity() const {
+  return static_cast< ::aapt::pb::Plural_Arity >(_impl_.arity_);
+}
+inline ::aapt::pb::Plural_Arity Plural_Entry::arity() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Plural.Entry.arity)
+  return _internal_arity();
+}
+inline void Plural_Entry::_internal_set_arity(::aapt::pb::Plural_Arity value) {
+  
+  _impl_.arity_ = value;
+}
+inline void Plural_Entry::set_arity(::aapt::pb::Plural_Arity value) {
+  _internal_set_arity(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.Plural.Entry.arity)
+}
+
+// .aapt.pb.Item item = 4;
+inline bool Plural_Entry::_internal_has_item() const {
+  return this != internal_default_instance() && _impl_.item_ != nullptr;
+}
+inline bool Plural_Entry::has_item() const {
+  return _internal_has_item();
+}
+inline void Plural_Entry::clear_item() {
+  if (GetArenaForAllocation() == nullptr && _impl_.item_ != nullptr) {
+    delete _impl_.item_;
+  }
+  _impl_.item_ = nullptr;
+}
+inline const ::aapt::pb::Item& Plural_Entry::_internal_item() const {
+  const ::aapt::pb::Item* p = _impl_.item_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Item&>(
+      ::aapt::pb::_Item_default_instance_);
+}
+inline const ::aapt::pb::Item& Plural_Entry::item() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Plural.Entry.item)
+  return _internal_item();
+}
+inline void Plural_Entry::unsafe_arena_set_allocated_item(
+    ::aapt::pb::Item* item) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
+  }
+  _impl_.item_ = item;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.Plural.Entry.item)
+}
+inline ::aapt::pb::Item* Plural_Entry::release_item() {
+  
+  ::aapt::pb::Item* temp = _impl_.item_;
+  _impl_.item_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Item* Plural_Entry::unsafe_arena_release_item() {
+  // @@protoc_insertion_point(field_release:aapt.pb.Plural.Entry.item)
+  
+  ::aapt::pb::Item* temp = _impl_.item_;
+  _impl_.item_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Item* Plural_Entry::_internal_mutable_item() {
+  
+  if (_impl_.item_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Item>(GetArenaForAllocation());
+    _impl_.item_ = p;
+  }
+  return _impl_.item_;
+}
+inline ::aapt::pb::Item* Plural_Entry::mutable_item() {
+  ::aapt::pb::Item* _msg = _internal_mutable_item();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Plural.Entry.item)
+  return _msg;
+}
+inline void Plural_Entry::set_allocated_item(::aapt::pb::Item* item) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.item_;
+  }
+  if (item) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
+    if (message_arena != submessage_arena) {
+      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, item, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.item_ = item;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Plural.Entry.item)
+}
+
+// -------------------------------------------------------------------
+
+// Plural
+
+// repeated .aapt.pb.Plural.Entry entry = 1;
+inline int Plural::_internal_entry_size() const {
+  return _impl_.entry_.size();
+}
+inline int Plural::entry_size() const {
+  return _internal_entry_size();
+}
+inline void Plural::clear_entry() {
+  _impl_.entry_.Clear();
+}
+inline ::aapt::pb::Plural_Entry* Plural::mutable_entry(int index) {
+  // @@protoc_insertion_point(field_mutable:aapt.pb.Plural.entry)
+  return _impl_.entry_.Mutable(index);
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Plural_Entry >*
+Plural::mutable_entry() {
+  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Plural.entry)
+  return &_impl_.entry_;
+}
+inline const ::aapt::pb::Plural_Entry& Plural::_internal_entry(int index) const {
+  return _impl_.entry_.Get(index);
+}
+inline const ::aapt::pb::Plural_Entry& Plural::entry(int index) const {
+  // @@protoc_insertion_point(field_get:aapt.pb.Plural.entry)
+  return _internal_entry(index);
+}
+inline ::aapt::pb::Plural_Entry* Plural::_internal_add_entry() {
+  return _impl_.entry_.Add();
+}
+inline ::aapt::pb::Plural_Entry* Plural::add_entry() {
+  ::aapt::pb::Plural_Entry* _add = _internal_add_entry();
+  // @@protoc_insertion_point(field_add:aapt.pb.Plural.entry)
+  return _add;
+}
+inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::Plural_Entry >&
+Plural::entry() const {
+  // @@protoc_insertion_point(field_list:aapt.pb.Plural.entry)
+  return _impl_.entry_;
+}
+
+// -------------------------------------------------------------------
+
+// XmlNode
+
+// .aapt.pb.XmlElement element = 1;
+inline bool XmlNode::_internal_has_element() const {
+  return node_case() == kElement;
+}
+inline bool XmlNode::has_element() const {
+  return _internal_has_element();
+}
+inline void XmlNode::set_has_element() {
+  _impl_._oneof_case_[0] = kElement;
+}
+inline void XmlNode::clear_element() {
+  if (_internal_has_element()) {
+    if (GetArenaForAllocation() == nullptr) {
+      delete _impl_.node_.element_;
+    }
+    clear_has_node();
+  }
+}
+inline ::aapt::pb::XmlElement* XmlNode::release_element() {
+  // @@protoc_insertion_point(field_release:aapt.pb.XmlNode.element)
+  if (_internal_has_element()) {
+    clear_has_node();
+    ::aapt::pb::XmlElement* temp = _impl_.node_.element_;
+    if (GetArenaForAllocation() != nullptr) {
+      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+    }
+    _impl_.node_.element_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline const ::aapt::pb::XmlElement& XmlNode::_internal_element() const {
+  return _internal_has_element()
+      ? *_impl_.node_.element_
+      : reinterpret_cast< ::aapt::pb::XmlElement&>(::aapt::pb::_XmlElement_default_instance_);
+}
+inline const ::aapt::pb::XmlElement& XmlNode::element() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.XmlNode.element)
+  return _internal_element();
+}
+inline ::aapt::pb::XmlElement* XmlNode::unsafe_arena_release_element() {
+  // @@protoc_insertion_point(field_unsafe_arena_release:aapt.pb.XmlNode.element)
+  if (_internal_has_element()) {
+    clear_has_node();
+    ::aapt::pb::XmlElement* temp = _impl_.node_.element_;
+    _impl_.node_.element_ = nullptr;
+    return temp;
+  } else {
+    return nullptr;
+  }
+}
+inline void XmlNode::unsafe_arena_set_allocated_element(::aapt::pb::XmlElement* element) {
+  clear_node();
+  if (element) {
+    set_has_element();
+    _impl_.node_.element_ = element;
+  }
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.XmlNode.element)
+}
+inline ::aapt::pb::XmlElement* XmlNode::_internal_mutable_element() {
+  if (!_internal_has_element()) {
+    clear_node();
+    set_has_element();
+    _impl_.node_.element_ = CreateMaybeMessage< ::aapt::pb::XmlElement >(GetArenaForAllocation());
+  }
+  return _impl_.node_.element_;
+}
+inline ::aapt::pb::XmlElement* XmlNode::mutable_element() {
+  ::aapt::pb::XmlElement* _msg = _internal_mutable_element();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNode.element)
+  return _msg;
+}
+
+// string text = 2;
+inline bool XmlNode::_internal_has_text() const {
+  return node_case() == kText;
+}
+inline bool XmlNode::has_text() const {
+  return _internal_has_text();
+}
+inline void XmlNode::set_has_text() {
+  _impl_._oneof_case_[0] = kText;
+}
+inline void XmlNode::clear_text() {
+  if (_internal_has_text()) {
+    _impl_.node_.text_.Destroy();
+    clear_has_node();
+  }
+}
+inline const std::string& XmlNode::text() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.XmlNode.text)
+  return _internal_text();
+}
+template <typename ArgT0, typename... ArgT>
+inline void XmlNode::set_text(ArgT0&& arg0, ArgT... args) {
+  if (!_internal_has_text()) {
+    clear_node();
+    set_has_text();
+    _impl_.node_.text_.InitDefault();
+  }
+  _impl_.node_.text_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.XmlNode.text)
+}
+inline std::string* XmlNode::mutable_text() {
+  std::string* _s = _internal_mutable_text();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNode.text)
+  return _s;
+}
+inline const std::string& XmlNode::_internal_text() const {
+  if (_internal_has_text()) {
+    return _impl_.node_.text_.Get();
+  }
+  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
+}
+inline void XmlNode::_internal_set_text(const std::string& value) {
+  if (!_internal_has_text()) {
+    clear_node();
+    set_has_text();
+    _impl_.node_.text_.InitDefault();
+  }
+  _impl_.node_.text_.Set(value, GetArenaForAllocation());
+}
+inline std::string* XmlNode::_internal_mutable_text() {
+  if (!_internal_has_text()) {
+    clear_node();
+    set_has_text();
+    _impl_.node_.text_.InitDefault();
+  }
+  return _impl_.node_.text_.Mutable(      GetArenaForAllocation());
+}
+inline std::string* XmlNode::release_text() {
+  // @@protoc_insertion_point(field_release:aapt.pb.XmlNode.text)
+  if (_internal_has_text()) {
+    clear_has_node();
+    return _impl_.node_.text_.Release();
+  } else {
+    return nullptr;
+  }
+}
+inline void XmlNode::set_allocated_text(std::string* text) {
+  if (has_node()) {
+    clear_node();
+  }
+  if (text != nullptr) {
+    set_has_text();
+    _impl_.node_.text_.InitAllocated(text, GetArenaForAllocation());
+  }
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNode.text)
+}
+
+// .aapt.pb.SourcePosition source = 3;
+inline bool XmlNode::_internal_has_source() const {
+  return this != internal_default_instance() && _impl_.source_ != nullptr;
+}
+inline bool XmlNode::has_source() const {
+  return _internal_has_source();
+}
+inline void XmlNode::clear_source() {
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+}
+inline const ::aapt::pb::SourcePosition& XmlNode::_internal_source() const {
+  const ::aapt::pb::SourcePosition* p = _impl_.source_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::SourcePosition&>(
+      ::aapt::pb::_SourcePosition_default_instance_);
+}
+inline const ::aapt::pb::SourcePosition& XmlNode::source() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.XmlNode.source)
+  return _internal_source();
+}
+inline void XmlNode::unsafe_arena_set_allocated_source(
+    ::aapt::pb::SourcePosition* source) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.XmlNode.source)
+}
+inline ::aapt::pb::SourcePosition* XmlNode::release_source() {
+  
+  ::aapt::pb::SourcePosition* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::SourcePosition* XmlNode::unsafe_arena_release_source() {
+  // @@protoc_insertion_point(field_release:aapt.pb.XmlNode.source)
+  
+  ::aapt::pb::SourcePosition* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::SourcePosition* XmlNode::_internal_mutable_source() {
+  
+  if (_impl_.source_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::SourcePosition>(GetArenaForAllocation());
+    _impl_.source_ = p;
+  }
+  return _impl_.source_;
+}
+inline ::aapt::pb::SourcePosition* XmlNode::mutable_source() {
+  ::aapt::pb::SourcePosition* _msg = _internal_mutable_source();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNode.source)
+  return _msg;
+}
+inline void XmlNode::set_allocated_source(::aapt::pb::SourcePosition* source) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.source_;
+  }
+  if (source) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
+    if (message_arena != submessage_arena) {
+      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, source, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNode.source)
+}
+
+inline bool XmlNode::has_node() const {
+  return node_case() != NODE_NOT_SET;
+}
+inline void XmlNode::clear_has_node() {
+  _impl_._oneof_case_[0] = NODE_NOT_SET;
+}
+inline XmlNode::NodeCase XmlNode::node_case() const {
+  return XmlNode::NodeCase(_impl_._oneof_case_[0]);
+}
+// -------------------------------------------------------------------
+
+// XmlElement
+
+// repeated .aapt.pb.XmlNamespace namespace_declaration = 1;
+inline int XmlElement::_internal_namespace_declaration_size() const {
+  return _impl_.namespace_declaration_.size();
+}
+inline int XmlElement::namespace_declaration_size() const {
+  return _internal_namespace_declaration_size();
+}
+inline void XmlElement::clear_namespace_declaration() {
+  _impl_.namespace_declaration_.Clear();
+}
+inline ::aapt::pb::XmlNamespace* XmlElement::mutable_namespace_declaration(int index) {
+  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlElement.namespace_declaration)
+  return _impl_.namespace_declaration_.Mutable(index);
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlNamespace >*
+XmlElement::mutable_namespace_declaration() {
+  // @@protoc_insertion_point(field_mutable_list:aapt.pb.XmlElement.namespace_declaration)
+  return &_impl_.namespace_declaration_;
+}
+inline const ::aapt::pb::XmlNamespace& XmlElement::_internal_namespace_declaration(int index) const {
+  return _impl_.namespace_declaration_.Get(index);
+}
+inline const ::aapt::pb::XmlNamespace& XmlElement::namespace_declaration(int index) const {
+  // @@protoc_insertion_point(field_get:aapt.pb.XmlElement.namespace_declaration)
+  return _internal_namespace_declaration(index);
+}
+inline ::aapt::pb::XmlNamespace* XmlElement::_internal_add_namespace_declaration() {
+  return _impl_.namespace_declaration_.Add();
+}
+inline ::aapt::pb::XmlNamespace* XmlElement::add_namespace_declaration() {
+  ::aapt::pb::XmlNamespace* _add = _internal_add_namespace_declaration();
+  // @@protoc_insertion_point(field_add:aapt.pb.XmlElement.namespace_declaration)
+  return _add;
+}
+inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlNamespace >&
+XmlElement::namespace_declaration() const {
+  // @@protoc_insertion_point(field_list:aapt.pb.XmlElement.namespace_declaration)
+  return _impl_.namespace_declaration_;
+}
+
+// string namespace_uri = 2;
+inline void XmlElement::clear_namespace_uri() {
+  _impl_.namespace_uri_.ClearToEmpty();
+}
+inline const std::string& XmlElement::namespace_uri() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.XmlElement.namespace_uri)
+  return _internal_namespace_uri();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void XmlElement::set_namespace_uri(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.namespace_uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.XmlElement.namespace_uri)
+}
+inline std::string* XmlElement::mutable_namespace_uri() {
+  std::string* _s = _internal_mutable_namespace_uri();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlElement.namespace_uri)
+  return _s;
+}
+inline const std::string& XmlElement::_internal_namespace_uri() const {
+  return _impl_.namespace_uri_.Get();
+}
+inline void XmlElement::_internal_set_namespace_uri(const std::string& value) {
+  
+  _impl_.namespace_uri_.Set(value, GetArenaForAllocation());
+}
+inline std::string* XmlElement::_internal_mutable_namespace_uri() {
+  
+  return _impl_.namespace_uri_.Mutable(GetArenaForAllocation());
+}
+inline std::string* XmlElement::release_namespace_uri() {
+  // @@protoc_insertion_point(field_release:aapt.pb.XmlElement.namespace_uri)
+  return _impl_.namespace_uri_.Release();
+}
+inline void XmlElement::set_allocated_namespace_uri(std::string* namespace_uri) {
+  _impl_.namespace_uri_.SetAllocated(namespace_uri, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.namespace_uri_.IsDefault()) {
+    _impl_.namespace_uri_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlElement.namespace_uri)
+}
+
+// string name = 3;
+inline void XmlElement::clear_name() {
+  _impl_.name_.ClearToEmpty();
+}
+inline const std::string& XmlElement::name() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.XmlElement.name)
+  return _internal_name();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void XmlElement::set_name(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.XmlElement.name)
+}
+inline std::string* XmlElement::mutable_name() {
+  std::string* _s = _internal_mutable_name();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlElement.name)
+  return _s;
+}
+inline const std::string& XmlElement::_internal_name() const {
+  return _impl_.name_.Get();
+}
+inline void XmlElement::_internal_set_name(const std::string& value) {
+  
+  _impl_.name_.Set(value, GetArenaForAllocation());
+}
+inline std::string* XmlElement::_internal_mutable_name() {
+  
+  return _impl_.name_.Mutable(GetArenaForAllocation());
+}
+inline std::string* XmlElement::release_name() {
+  // @@protoc_insertion_point(field_release:aapt.pb.XmlElement.name)
+  return _impl_.name_.Release();
+}
+inline void XmlElement::set_allocated_name(std::string* name) {
+  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.name_.IsDefault()) {
+    _impl_.name_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlElement.name)
+}
+
+// repeated .aapt.pb.XmlAttribute attribute = 4;
+inline int XmlElement::_internal_attribute_size() const {
+  return _impl_.attribute_.size();
+}
+inline int XmlElement::attribute_size() const {
+  return _internal_attribute_size();
+}
+inline void XmlElement::clear_attribute() {
+  _impl_.attribute_.Clear();
+}
+inline ::aapt::pb::XmlAttribute* XmlElement::mutable_attribute(int index) {
+  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlElement.attribute)
+  return _impl_.attribute_.Mutable(index);
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlAttribute >*
+XmlElement::mutable_attribute() {
+  // @@protoc_insertion_point(field_mutable_list:aapt.pb.XmlElement.attribute)
+  return &_impl_.attribute_;
+}
+inline const ::aapt::pb::XmlAttribute& XmlElement::_internal_attribute(int index) const {
+  return _impl_.attribute_.Get(index);
+}
+inline const ::aapt::pb::XmlAttribute& XmlElement::attribute(int index) const {
+  // @@protoc_insertion_point(field_get:aapt.pb.XmlElement.attribute)
+  return _internal_attribute(index);
+}
+inline ::aapt::pb::XmlAttribute* XmlElement::_internal_add_attribute() {
+  return _impl_.attribute_.Add();
+}
+inline ::aapt::pb::XmlAttribute* XmlElement::add_attribute() {
+  ::aapt::pb::XmlAttribute* _add = _internal_add_attribute();
+  // @@protoc_insertion_point(field_add:aapt.pb.XmlElement.attribute)
+  return _add;
+}
+inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlAttribute >&
+XmlElement::attribute() const {
+  // @@protoc_insertion_point(field_list:aapt.pb.XmlElement.attribute)
+  return _impl_.attribute_;
+}
+
+// repeated .aapt.pb.XmlNode child = 5;
+inline int XmlElement::_internal_child_size() const {
+  return _impl_.child_.size();
+}
+inline int XmlElement::child_size() const {
+  return _internal_child_size();
+}
+inline void XmlElement::clear_child() {
+  _impl_.child_.Clear();
+}
+inline ::aapt::pb::XmlNode* XmlElement::mutable_child(int index) {
+  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlElement.child)
+  return _impl_.child_.Mutable(index);
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlNode >*
+XmlElement::mutable_child() {
+  // @@protoc_insertion_point(field_mutable_list:aapt.pb.XmlElement.child)
+  return &_impl_.child_;
+}
+inline const ::aapt::pb::XmlNode& XmlElement::_internal_child(int index) const {
+  return _impl_.child_.Get(index);
+}
+inline const ::aapt::pb::XmlNode& XmlElement::child(int index) const {
+  // @@protoc_insertion_point(field_get:aapt.pb.XmlElement.child)
+  return _internal_child(index);
+}
+inline ::aapt::pb::XmlNode* XmlElement::_internal_add_child() {
+  return _impl_.child_.Add();
+}
+inline ::aapt::pb::XmlNode* XmlElement::add_child() {
+  ::aapt::pb::XmlNode* _add = _internal_add_child();
+  // @@protoc_insertion_point(field_add:aapt.pb.XmlElement.child)
+  return _add;
+}
+inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::XmlNode >&
+XmlElement::child() const {
+  // @@protoc_insertion_point(field_list:aapt.pb.XmlElement.child)
+  return _impl_.child_;
+}
+
+// -------------------------------------------------------------------
+
+// XmlNamespace
+
+// string prefix = 1;
+inline void XmlNamespace::clear_prefix() {
+  _impl_.prefix_.ClearToEmpty();
+}
+inline const std::string& XmlNamespace::prefix() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.XmlNamespace.prefix)
+  return _internal_prefix();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void XmlNamespace::set_prefix(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.prefix_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.XmlNamespace.prefix)
+}
+inline std::string* XmlNamespace::mutable_prefix() {
+  std::string* _s = _internal_mutable_prefix();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNamespace.prefix)
+  return _s;
+}
+inline const std::string& XmlNamespace::_internal_prefix() const {
+  return _impl_.prefix_.Get();
+}
+inline void XmlNamespace::_internal_set_prefix(const std::string& value) {
+  
+  _impl_.prefix_.Set(value, GetArenaForAllocation());
+}
+inline std::string* XmlNamespace::_internal_mutable_prefix() {
+  
+  return _impl_.prefix_.Mutable(GetArenaForAllocation());
+}
+inline std::string* XmlNamespace::release_prefix() {
+  // @@protoc_insertion_point(field_release:aapt.pb.XmlNamespace.prefix)
+  return _impl_.prefix_.Release();
+}
+inline void XmlNamespace::set_allocated_prefix(std::string* prefix) {
+  _impl_.prefix_.SetAllocated(prefix, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.prefix_.IsDefault()) {
+    _impl_.prefix_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNamespace.prefix)
+}
+
+// string uri = 2;
+inline void XmlNamespace::clear_uri() {
+  _impl_.uri_.ClearToEmpty();
+}
+inline const std::string& XmlNamespace::uri() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.XmlNamespace.uri)
+  return _internal_uri();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void XmlNamespace::set_uri(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.XmlNamespace.uri)
+}
+inline std::string* XmlNamespace::mutable_uri() {
+  std::string* _s = _internal_mutable_uri();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNamespace.uri)
+  return _s;
+}
+inline const std::string& XmlNamespace::_internal_uri() const {
+  return _impl_.uri_.Get();
+}
+inline void XmlNamespace::_internal_set_uri(const std::string& value) {
+  
+  _impl_.uri_.Set(value, GetArenaForAllocation());
+}
+inline std::string* XmlNamespace::_internal_mutable_uri() {
+  
+  return _impl_.uri_.Mutable(GetArenaForAllocation());
+}
+inline std::string* XmlNamespace::release_uri() {
+  // @@protoc_insertion_point(field_release:aapt.pb.XmlNamespace.uri)
+  return _impl_.uri_.Release();
+}
+inline void XmlNamespace::set_allocated_uri(std::string* uri) {
+  _impl_.uri_.SetAllocated(uri, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.uri_.IsDefault()) {
+    _impl_.uri_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNamespace.uri)
+}
+
+// .aapt.pb.SourcePosition source = 3;
+inline bool XmlNamespace::_internal_has_source() const {
+  return this != internal_default_instance() && _impl_.source_ != nullptr;
+}
+inline bool XmlNamespace::has_source() const {
+  return _internal_has_source();
+}
+inline void XmlNamespace::clear_source() {
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+}
+inline const ::aapt::pb::SourcePosition& XmlNamespace::_internal_source() const {
+  const ::aapt::pb::SourcePosition* p = _impl_.source_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::SourcePosition&>(
+      ::aapt::pb::_SourcePosition_default_instance_);
+}
+inline const ::aapt::pb::SourcePosition& XmlNamespace::source() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.XmlNamespace.source)
+  return _internal_source();
+}
+inline void XmlNamespace::unsafe_arena_set_allocated_source(
+    ::aapt::pb::SourcePosition* source) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.XmlNamespace.source)
+}
+inline ::aapt::pb::SourcePosition* XmlNamespace::release_source() {
+  
+  ::aapt::pb::SourcePosition* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::SourcePosition* XmlNamespace::unsafe_arena_release_source() {
+  // @@protoc_insertion_point(field_release:aapt.pb.XmlNamespace.source)
+  
+  ::aapt::pb::SourcePosition* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::SourcePosition* XmlNamespace::_internal_mutable_source() {
+  
+  if (_impl_.source_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::SourcePosition>(GetArenaForAllocation());
+    _impl_.source_ = p;
+  }
+  return _impl_.source_;
+}
+inline ::aapt::pb::SourcePosition* XmlNamespace::mutable_source() {
+  ::aapt::pb::SourcePosition* _msg = _internal_mutable_source();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNamespace.source)
+  return _msg;
+}
+inline void XmlNamespace::set_allocated_source(::aapt::pb::SourcePosition* source) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.source_;
+  }
+  if (source) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
+    if (message_arena != submessage_arena) {
+      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, source, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNamespace.source)
+}
+
+// -------------------------------------------------------------------
+
+// XmlAttribute
+
+// string namespace_uri = 1;
+inline void XmlAttribute::clear_namespace_uri() {
+  _impl_.namespace_uri_.ClearToEmpty();
+}
+inline const std::string& XmlAttribute::namespace_uri() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.namespace_uri)
+  return _internal_namespace_uri();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void XmlAttribute::set_namespace_uri(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.namespace_uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.XmlAttribute.namespace_uri)
+}
+inline std::string* XmlAttribute::mutable_namespace_uri() {
+  std::string* _s = _internal_mutable_namespace_uri();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlAttribute.namespace_uri)
+  return _s;
+}
+inline const std::string& XmlAttribute::_internal_namespace_uri() const {
+  return _impl_.namespace_uri_.Get();
+}
+inline void XmlAttribute::_internal_set_namespace_uri(const std::string& value) {
+  
+  _impl_.namespace_uri_.Set(value, GetArenaForAllocation());
+}
+inline std::string* XmlAttribute::_internal_mutable_namespace_uri() {
+  
+  return _impl_.namespace_uri_.Mutable(GetArenaForAllocation());
+}
+inline std::string* XmlAttribute::release_namespace_uri() {
+  // @@protoc_insertion_point(field_release:aapt.pb.XmlAttribute.namespace_uri)
+  return _impl_.namespace_uri_.Release();
+}
+inline void XmlAttribute::set_allocated_namespace_uri(std::string* namespace_uri) {
+  _impl_.namespace_uri_.SetAllocated(namespace_uri, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.namespace_uri_.IsDefault()) {
+    _impl_.namespace_uri_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlAttribute.namespace_uri)
+}
+
+// string name = 2;
+inline void XmlAttribute::clear_name() {
+  _impl_.name_.ClearToEmpty();
+}
+inline const std::string& XmlAttribute::name() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.name)
+  return _internal_name();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void XmlAttribute::set_name(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.XmlAttribute.name)
+}
+inline std::string* XmlAttribute::mutable_name() {
+  std::string* _s = _internal_mutable_name();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlAttribute.name)
+  return _s;
+}
+inline const std::string& XmlAttribute::_internal_name() const {
+  return _impl_.name_.Get();
+}
+inline void XmlAttribute::_internal_set_name(const std::string& value) {
+  
+  _impl_.name_.Set(value, GetArenaForAllocation());
+}
+inline std::string* XmlAttribute::_internal_mutable_name() {
+  
+  return _impl_.name_.Mutable(GetArenaForAllocation());
+}
+inline std::string* XmlAttribute::release_name() {
+  // @@protoc_insertion_point(field_release:aapt.pb.XmlAttribute.name)
+  return _impl_.name_.Release();
+}
+inline void XmlAttribute::set_allocated_name(std::string* name) {
+  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.name_.IsDefault()) {
+    _impl_.name_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlAttribute.name)
+}
+
+// string value = 3;
+inline void XmlAttribute::clear_value() {
+  _impl_.value_.ClearToEmpty();
+}
+inline const std::string& XmlAttribute::value() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.value)
+  return _internal_value();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void XmlAttribute::set_value(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.XmlAttribute.value)
+}
+inline std::string* XmlAttribute::mutable_value() {
+  std::string* _s = _internal_mutable_value();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlAttribute.value)
+  return _s;
+}
+inline const std::string& XmlAttribute::_internal_value() const {
+  return _impl_.value_.Get();
+}
+inline void XmlAttribute::_internal_set_value(const std::string& value) {
+  
+  _impl_.value_.Set(value, GetArenaForAllocation());
+}
+inline std::string* XmlAttribute::_internal_mutable_value() {
+  
+  return _impl_.value_.Mutable(GetArenaForAllocation());
+}
+inline std::string* XmlAttribute::release_value() {
+  // @@protoc_insertion_point(field_release:aapt.pb.XmlAttribute.value)
+  return _impl_.value_.Release();
+}
+inline void XmlAttribute::set_allocated_value(std::string* value) {
+  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.value_.IsDefault()) {
+    _impl_.value_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlAttribute.value)
+}
+
+// .aapt.pb.SourcePosition source = 4;
+inline bool XmlAttribute::_internal_has_source() const {
+  return this != internal_default_instance() && _impl_.source_ != nullptr;
+}
+inline bool XmlAttribute::has_source() const {
+  return _internal_has_source();
+}
+inline void XmlAttribute::clear_source() {
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+}
+inline const ::aapt::pb::SourcePosition& XmlAttribute::_internal_source() const {
+  const ::aapt::pb::SourcePosition* p = _impl_.source_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::SourcePosition&>(
+      ::aapt::pb::_SourcePosition_default_instance_);
+}
+inline const ::aapt::pb::SourcePosition& XmlAttribute::source() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.source)
+  return _internal_source();
+}
+inline void XmlAttribute::unsafe_arena_set_allocated_source(
+    ::aapt::pb::SourcePosition* source) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.XmlAttribute.source)
+}
+inline ::aapt::pb::SourcePosition* XmlAttribute::release_source() {
+  
+  ::aapt::pb::SourcePosition* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::SourcePosition* XmlAttribute::unsafe_arena_release_source() {
+  // @@protoc_insertion_point(field_release:aapt.pb.XmlAttribute.source)
+  
+  ::aapt::pb::SourcePosition* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::SourcePosition* XmlAttribute::_internal_mutable_source() {
+  
+  if (_impl_.source_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::SourcePosition>(GetArenaForAllocation());
+    _impl_.source_ = p;
+  }
+  return _impl_.source_;
+}
+inline ::aapt::pb::SourcePosition* XmlAttribute::mutable_source() {
+  ::aapt::pb::SourcePosition* _msg = _internal_mutable_source();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlAttribute.source)
+  return _msg;
+}
+inline void XmlAttribute::set_allocated_source(::aapt::pb::SourcePosition* source) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.source_;
+  }
+  if (source) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
+    if (message_arena != submessage_arena) {
+      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, source, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlAttribute.source)
+}
+
+// uint32 resource_id = 5;
+inline void XmlAttribute::clear_resource_id() {
+  _impl_.resource_id_ = 0u;
+}
+inline ::uint32_t XmlAttribute::_internal_resource_id() const {
+  return _impl_.resource_id_;
+}
+inline ::uint32_t XmlAttribute::resource_id() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.resource_id)
+  return _internal_resource_id();
+}
+inline void XmlAttribute::_internal_set_resource_id(::uint32_t value) {
+  
+  _impl_.resource_id_ = value;
+}
+inline void XmlAttribute::set_resource_id(::uint32_t value) {
+  _internal_set_resource_id(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.XmlAttribute.resource_id)
+}
+
+// .aapt.pb.Item compiled_item = 6;
+inline bool XmlAttribute::_internal_has_compiled_item() const {
+  return this != internal_default_instance() && _impl_.compiled_item_ != nullptr;
+}
+inline bool XmlAttribute::has_compiled_item() const {
+  return _internal_has_compiled_item();
+}
+inline void XmlAttribute::clear_compiled_item() {
+  if (GetArenaForAllocation() == nullptr && _impl_.compiled_item_ != nullptr) {
+    delete _impl_.compiled_item_;
+  }
+  _impl_.compiled_item_ = nullptr;
+}
+inline const ::aapt::pb::Item& XmlAttribute::_internal_compiled_item() const {
+  const ::aapt::pb::Item* p = _impl_.compiled_item_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Item&>(
+      ::aapt::pb::_Item_default_instance_);
+}
+inline const ::aapt::pb::Item& XmlAttribute::compiled_item() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.compiled_item)
+  return _internal_compiled_item();
+}
+inline void XmlAttribute::unsafe_arena_set_allocated_compiled_item(
+    ::aapt::pb::Item* compiled_item) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.compiled_item_);
+  }
+  _impl_.compiled_item_ = compiled_item;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.XmlAttribute.compiled_item)
+}
+inline ::aapt::pb::Item* XmlAttribute::release_compiled_item() {
+  
+  ::aapt::pb::Item* temp = _impl_.compiled_item_;
+  _impl_.compiled_item_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Item* XmlAttribute::unsafe_arena_release_compiled_item() {
+  // @@protoc_insertion_point(field_release:aapt.pb.XmlAttribute.compiled_item)
+  
+  ::aapt::pb::Item* temp = _impl_.compiled_item_;
+  _impl_.compiled_item_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Item* XmlAttribute::_internal_mutable_compiled_item() {
+  
+  if (_impl_.compiled_item_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Item>(GetArenaForAllocation());
+    _impl_.compiled_item_ = p;
+  }
+  return _impl_.compiled_item_;
+}
+inline ::aapt::pb::Item* XmlAttribute::mutable_compiled_item() {
+  ::aapt::pb::Item* _msg = _internal_mutable_compiled_item();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlAttribute.compiled_item)
+  return _msg;
+}
+inline void XmlAttribute::set_allocated_compiled_item(::aapt::pb::Item* compiled_item) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.compiled_item_;
+  }
+  if (compiled_item) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(compiled_item);
+    if (message_arena != submessage_arena) {
+      compiled_item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, compiled_item, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.compiled_item_ = compiled_item;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlAttribute.compiled_item)
+}
+
+// -------------------------------------------------------------------
+
+// MacroBody
+
+// string raw_string = 1;
+inline void MacroBody::clear_raw_string() {
+  _impl_.raw_string_.ClearToEmpty();
+}
+inline const std::string& MacroBody::raw_string() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.MacroBody.raw_string)
+  return _internal_raw_string();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void MacroBody::set_raw_string(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.raw_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.MacroBody.raw_string)
+}
+inline std::string* MacroBody::mutable_raw_string() {
+  std::string* _s = _internal_mutable_raw_string();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.MacroBody.raw_string)
+  return _s;
+}
+inline const std::string& MacroBody::_internal_raw_string() const {
+  return _impl_.raw_string_.Get();
+}
+inline void MacroBody::_internal_set_raw_string(const std::string& value) {
+  
+  _impl_.raw_string_.Set(value, GetArenaForAllocation());
+}
+inline std::string* MacroBody::_internal_mutable_raw_string() {
+  
+  return _impl_.raw_string_.Mutable(GetArenaForAllocation());
+}
+inline std::string* MacroBody::release_raw_string() {
+  // @@protoc_insertion_point(field_release:aapt.pb.MacroBody.raw_string)
+  return _impl_.raw_string_.Release();
+}
+inline void MacroBody::set_allocated_raw_string(std::string* raw_string) {
+  _impl_.raw_string_.SetAllocated(raw_string, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.raw_string_.IsDefault()) {
+    _impl_.raw_string_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.MacroBody.raw_string)
+}
+
+// .aapt.pb.StyleString style_string = 2;
+inline bool MacroBody::_internal_has_style_string() const {
+  return this != internal_default_instance() && _impl_.style_string_ != nullptr;
+}
+inline bool MacroBody::has_style_string() const {
+  return _internal_has_style_string();
+}
+inline void MacroBody::clear_style_string() {
+  if (GetArenaForAllocation() == nullptr && _impl_.style_string_ != nullptr) {
+    delete _impl_.style_string_;
+  }
+  _impl_.style_string_ = nullptr;
+}
+inline const ::aapt::pb::StyleString& MacroBody::_internal_style_string() const {
+  const ::aapt::pb::StyleString* p = _impl_.style_string_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::StyleString&>(
+      ::aapt::pb::_StyleString_default_instance_);
+}
+inline const ::aapt::pb::StyleString& MacroBody::style_string() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.MacroBody.style_string)
+  return _internal_style_string();
+}
+inline void MacroBody::unsafe_arena_set_allocated_style_string(
+    ::aapt::pb::StyleString* style_string) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.style_string_);
+  }
+  _impl_.style_string_ = style_string;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.MacroBody.style_string)
+}
+inline ::aapt::pb::StyleString* MacroBody::release_style_string() {
+  
+  ::aapt::pb::StyleString* temp = _impl_.style_string_;
+  _impl_.style_string_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::StyleString* MacroBody::unsafe_arena_release_style_string() {
+  // @@protoc_insertion_point(field_release:aapt.pb.MacroBody.style_string)
+  
+  ::aapt::pb::StyleString* temp = _impl_.style_string_;
+  _impl_.style_string_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::StyleString* MacroBody::_internal_mutable_style_string() {
+  
+  if (_impl_.style_string_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::StyleString>(GetArenaForAllocation());
+    _impl_.style_string_ = p;
+  }
+  return _impl_.style_string_;
+}
+inline ::aapt::pb::StyleString* MacroBody::mutable_style_string() {
+  ::aapt::pb::StyleString* _msg = _internal_mutable_style_string();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.MacroBody.style_string)
+  return _msg;
+}
+inline void MacroBody::set_allocated_style_string(::aapt::pb::StyleString* style_string) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.style_string_;
+  }
+  if (style_string) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(style_string);
+    if (message_arena != submessage_arena) {
+      style_string = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, style_string, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.style_string_ = style_string;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.MacroBody.style_string)
+}
+
+// repeated .aapt.pb.UntranslatableSection untranslatable_sections = 3;
+inline int MacroBody::_internal_untranslatable_sections_size() const {
+  return _impl_.untranslatable_sections_.size();
+}
+inline int MacroBody::untranslatable_sections_size() const {
+  return _internal_untranslatable_sections_size();
+}
+inline void MacroBody::clear_untranslatable_sections() {
+  _impl_.untranslatable_sections_.Clear();
+}
+inline ::aapt::pb::UntranslatableSection* MacroBody::mutable_untranslatable_sections(int index) {
+  // @@protoc_insertion_point(field_mutable:aapt.pb.MacroBody.untranslatable_sections)
+  return _impl_.untranslatable_sections_.Mutable(index);
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::UntranslatableSection >*
+MacroBody::mutable_untranslatable_sections() {
+  // @@protoc_insertion_point(field_mutable_list:aapt.pb.MacroBody.untranslatable_sections)
+  return &_impl_.untranslatable_sections_;
+}
+inline const ::aapt::pb::UntranslatableSection& MacroBody::_internal_untranslatable_sections(int index) const {
+  return _impl_.untranslatable_sections_.Get(index);
+}
+inline const ::aapt::pb::UntranslatableSection& MacroBody::untranslatable_sections(int index) const {
+  // @@protoc_insertion_point(field_get:aapt.pb.MacroBody.untranslatable_sections)
+  return _internal_untranslatable_sections(index);
+}
+inline ::aapt::pb::UntranslatableSection* MacroBody::_internal_add_untranslatable_sections() {
+  return _impl_.untranslatable_sections_.Add();
+}
+inline ::aapt::pb::UntranslatableSection* MacroBody::add_untranslatable_sections() {
+  ::aapt::pb::UntranslatableSection* _add = _internal_add_untranslatable_sections();
+  // @@protoc_insertion_point(field_add:aapt.pb.MacroBody.untranslatable_sections)
+  return _add;
+}
+inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::UntranslatableSection >&
+MacroBody::untranslatable_sections() const {
+  // @@protoc_insertion_point(field_list:aapt.pb.MacroBody.untranslatable_sections)
+  return _impl_.untranslatable_sections_;
+}
+
+// repeated .aapt.pb.NamespaceAlias namespace_stack = 4;
+inline int MacroBody::_internal_namespace_stack_size() const {
+  return _impl_.namespace_stack_.size();
+}
+inline int MacroBody::namespace_stack_size() const {
+  return _internal_namespace_stack_size();
+}
+inline void MacroBody::clear_namespace_stack() {
+  _impl_.namespace_stack_.Clear();
+}
+inline ::aapt::pb::NamespaceAlias* MacroBody::mutable_namespace_stack(int index) {
+  // @@protoc_insertion_point(field_mutable:aapt.pb.MacroBody.namespace_stack)
+  return _impl_.namespace_stack_.Mutable(index);
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::NamespaceAlias >*
+MacroBody::mutable_namespace_stack() {
+  // @@protoc_insertion_point(field_mutable_list:aapt.pb.MacroBody.namespace_stack)
+  return &_impl_.namespace_stack_;
+}
+inline const ::aapt::pb::NamespaceAlias& MacroBody::_internal_namespace_stack(int index) const {
+  return _impl_.namespace_stack_.Get(index);
+}
+inline const ::aapt::pb::NamespaceAlias& MacroBody::namespace_stack(int index) const {
+  // @@protoc_insertion_point(field_get:aapt.pb.MacroBody.namespace_stack)
+  return _internal_namespace_stack(index);
+}
+inline ::aapt::pb::NamespaceAlias* MacroBody::_internal_add_namespace_stack() {
+  return _impl_.namespace_stack_.Add();
+}
+inline ::aapt::pb::NamespaceAlias* MacroBody::add_namespace_stack() {
+  ::aapt::pb::NamespaceAlias* _add = _internal_add_namespace_stack();
+  // @@protoc_insertion_point(field_add:aapt.pb.MacroBody.namespace_stack)
+  return _add;
+}
+inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::NamespaceAlias >&
+MacroBody::namespace_stack() const {
+  // @@protoc_insertion_point(field_list:aapt.pb.MacroBody.namespace_stack)
+  return _impl_.namespace_stack_;
+}
+
+// .aapt.pb.SourcePosition source = 5;
+inline bool MacroBody::_internal_has_source() const {
+  return this != internal_default_instance() && _impl_.source_ != nullptr;
+}
+inline bool MacroBody::has_source() const {
+  return _internal_has_source();
+}
+inline void MacroBody::clear_source() {
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+}
+inline const ::aapt::pb::SourcePosition& MacroBody::_internal_source() const {
+  const ::aapt::pb::SourcePosition* p = _impl_.source_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::SourcePosition&>(
+      ::aapt::pb::_SourcePosition_default_instance_);
+}
+inline const ::aapt::pb::SourcePosition& MacroBody::source() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.MacroBody.source)
+  return _internal_source();
+}
+inline void MacroBody::unsafe_arena_set_allocated_source(
+    ::aapt::pb::SourcePosition* source) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.MacroBody.source)
+}
+inline ::aapt::pb::SourcePosition* MacroBody::release_source() {
+  
+  ::aapt::pb::SourcePosition* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::SourcePosition* MacroBody::unsafe_arena_release_source() {
+  // @@protoc_insertion_point(field_release:aapt.pb.MacroBody.source)
+  
+  ::aapt::pb::SourcePosition* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::SourcePosition* MacroBody::_internal_mutable_source() {
+  
+  if (_impl_.source_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::SourcePosition>(GetArenaForAllocation());
+    _impl_.source_ = p;
+  }
+  return _impl_.source_;
+}
+inline ::aapt::pb::SourcePosition* MacroBody::mutable_source() {
+  ::aapt::pb::SourcePosition* _msg = _internal_mutable_source();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.MacroBody.source)
+  return _msg;
+}
+inline void MacroBody::set_allocated_source(::aapt::pb::SourcePosition* source) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete _impl_.source_;
+  }
+  if (source) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
+    if (message_arena != submessage_arena) {
+      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, source, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.MacroBody.source)
+}
+
+// -------------------------------------------------------------------
+
+// NamespaceAlias
+
+// string prefix = 1;
+inline void NamespaceAlias::clear_prefix() {
+  _impl_.prefix_.ClearToEmpty();
+}
+inline const std::string& NamespaceAlias::prefix() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.NamespaceAlias.prefix)
+  return _internal_prefix();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void NamespaceAlias::set_prefix(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.prefix_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.NamespaceAlias.prefix)
+}
+inline std::string* NamespaceAlias::mutable_prefix() {
+  std::string* _s = _internal_mutable_prefix();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.NamespaceAlias.prefix)
+  return _s;
+}
+inline const std::string& NamespaceAlias::_internal_prefix() const {
+  return _impl_.prefix_.Get();
+}
+inline void NamespaceAlias::_internal_set_prefix(const std::string& value) {
+  
+  _impl_.prefix_.Set(value, GetArenaForAllocation());
+}
+inline std::string* NamespaceAlias::_internal_mutable_prefix() {
+  
+  return _impl_.prefix_.Mutable(GetArenaForAllocation());
+}
+inline std::string* NamespaceAlias::release_prefix() {
+  // @@protoc_insertion_point(field_release:aapt.pb.NamespaceAlias.prefix)
+  return _impl_.prefix_.Release();
+}
+inline void NamespaceAlias::set_allocated_prefix(std::string* prefix) {
+  _impl_.prefix_.SetAllocated(prefix, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.prefix_.IsDefault()) {
+    _impl_.prefix_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.NamespaceAlias.prefix)
+}
+
+// string package_name = 2;
+inline void NamespaceAlias::clear_package_name() {
+  _impl_.package_name_.ClearToEmpty();
+}
+inline const std::string& NamespaceAlias::package_name() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.NamespaceAlias.package_name)
+  return _internal_package_name();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void NamespaceAlias::set_package_name(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.NamespaceAlias.package_name)
+}
+inline std::string* NamespaceAlias::mutable_package_name() {
+  std::string* _s = _internal_mutable_package_name();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.NamespaceAlias.package_name)
+  return _s;
+}
+inline const std::string& NamespaceAlias::_internal_package_name() const {
+  return _impl_.package_name_.Get();
+}
+inline void NamespaceAlias::_internal_set_package_name(const std::string& value) {
+  
+  _impl_.package_name_.Set(value, GetArenaForAllocation());
+}
+inline std::string* NamespaceAlias::_internal_mutable_package_name() {
+  
+  return _impl_.package_name_.Mutable(GetArenaForAllocation());
+}
+inline std::string* NamespaceAlias::release_package_name() {
+  // @@protoc_insertion_point(field_release:aapt.pb.NamespaceAlias.package_name)
+  return _impl_.package_name_.Release();
+}
+inline void NamespaceAlias::set_allocated_package_name(std::string* package_name) {
+  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.package_name_.IsDefault()) {
+    _impl_.package_name_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.NamespaceAlias.package_name)
+}
+
+// bool is_private = 3;
+inline void NamespaceAlias::clear_is_private() {
+  _impl_.is_private_ = false;
+}
+inline bool NamespaceAlias::_internal_is_private() const {
+  return _impl_.is_private_;
+}
+inline bool NamespaceAlias::is_private() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.NamespaceAlias.is_private)
+  return _internal_is_private();
+}
+inline void NamespaceAlias::_internal_set_is_private(bool value) {
+  
+  _impl_.is_private_ = value;
+}
+inline void NamespaceAlias::set_is_private(bool value) {
+  _internal_set_is_private(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.NamespaceAlias.is_private)
+}
+
+// -------------------------------------------------------------------
+
+// StyleString_Span
+
+// string name = 1;
+inline void StyleString_Span::clear_name() {
+  _impl_.name_.ClearToEmpty();
+}
+inline const std::string& StyleString_Span::name() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.StyleString.Span.name)
+  return _internal_name();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void StyleString_Span::set_name(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.StyleString.Span.name)
+}
+inline std::string* StyleString_Span::mutable_name() {
+  std::string* _s = _internal_mutable_name();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.StyleString.Span.name)
+  return _s;
+}
+inline const std::string& StyleString_Span::_internal_name() const {
+  return _impl_.name_.Get();
+}
+inline void StyleString_Span::_internal_set_name(const std::string& value) {
+  
+  _impl_.name_.Set(value, GetArenaForAllocation());
+}
+inline std::string* StyleString_Span::_internal_mutable_name() {
+  
+  return _impl_.name_.Mutable(GetArenaForAllocation());
+}
+inline std::string* StyleString_Span::release_name() {
+  // @@protoc_insertion_point(field_release:aapt.pb.StyleString.Span.name)
+  return _impl_.name_.Release();
+}
+inline void StyleString_Span::set_allocated_name(std::string* name) {
+  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.name_.IsDefault()) {
+    _impl_.name_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.StyleString.Span.name)
+}
+
+// uint32 start_index = 2;
+inline void StyleString_Span::clear_start_index() {
+  _impl_.start_index_ = 0u;
+}
+inline ::uint32_t StyleString_Span::_internal_start_index() const {
+  return _impl_.start_index_;
+}
+inline ::uint32_t StyleString_Span::start_index() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.StyleString.Span.start_index)
+  return _internal_start_index();
+}
+inline void StyleString_Span::_internal_set_start_index(::uint32_t value) {
+  
+  _impl_.start_index_ = value;
+}
+inline void StyleString_Span::set_start_index(::uint32_t value) {
+  _internal_set_start_index(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.StyleString.Span.start_index)
+}
+
+// uint32 end_index = 3;
+inline void StyleString_Span::clear_end_index() {
+  _impl_.end_index_ = 0u;
+}
+inline ::uint32_t StyleString_Span::_internal_end_index() const {
+  return _impl_.end_index_;
+}
+inline ::uint32_t StyleString_Span::end_index() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.StyleString.Span.end_index)
+  return _internal_end_index();
+}
+inline void StyleString_Span::_internal_set_end_index(::uint32_t value) {
+  
+  _impl_.end_index_ = value;
+}
+inline void StyleString_Span::set_end_index(::uint32_t value) {
+  _internal_set_end_index(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.StyleString.Span.end_index)
+}
+
+// -------------------------------------------------------------------
+
+// StyleString
+
+// string str = 1;
+inline void StyleString::clear_str() {
+  _impl_.str_.ClearToEmpty();
+}
+inline const std::string& StyleString::str() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.StyleString.str)
+  return _internal_str();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void StyleString::set_str(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.str_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.StyleString.str)
+}
+inline std::string* StyleString::mutable_str() {
+  std::string* _s = _internal_mutable_str();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.StyleString.str)
+  return _s;
+}
+inline const std::string& StyleString::_internal_str() const {
+  return _impl_.str_.Get();
+}
+inline void StyleString::_internal_set_str(const std::string& value) {
+  
+  _impl_.str_.Set(value, GetArenaForAllocation());
+}
+inline std::string* StyleString::_internal_mutable_str() {
+  
+  return _impl_.str_.Mutable(GetArenaForAllocation());
+}
+inline std::string* StyleString::release_str() {
+  // @@protoc_insertion_point(field_release:aapt.pb.StyleString.str)
+  return _impl_.str_.Release();
+}
+inline void StyleString::set_allocated_str(std::string* str) {
+  _impl_.str_.SetAllocated(str, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.str_.IsDefault()) {
+    _impl_.str_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.StyleString.str)
+}
+
+// repeated .aapt.pb.StyleString.Span spans = 2;
+inline int StyleString::_internal_spans_size() const {
+  return _impl_.spans_.size();
+}
+inline int StyleString::spans_size() const {
+  return _internal_spans_size();
+}
+inline void StyleString::clear_spans() {
+  _impl_.spans_.Clear();
+}
+inline ::aapt::pb::StyleString_Span* StyleString::mutable_spans(int index) {
+  // @@protoc_insertion_point(field_mutable:aapt.pb.StyleString.spans)
+  return _impl_.spans_.Mutable(index);
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::StyleString_Span >*
+StyleString::mutable_spans() {
+  // @@protoc_insertion_point(field_mutable_list:aapt.pb.StyleString.spans)
+  return &_impl_.spans_;
+}
+inline const ::aapt::pb::StyleString_Span& StyleString::_internal_spans(int index) const {
+  return _impl_.spans_.Get(index);
+}
+inline const ::aapt::pb::StyleString_Span& StyleString::spans(int index) const {
+  // @@protoc_insertion_point(field_get:aapt.pb.StyleString.spans)
+  return _internal_spans(index);
+}
+inline ::aapt::pb::StyleString_Span* StyleString::_internal_add_spans() {
+  return _impl_.spans_.Add();
+}
+inline ::aapt::pb::StyleString_Span* StyleString::add_spans() {
+  ::aapt::pb::StyleString_Span* _add = _internal_add_spans();
+  // @@protoc_insertion_point(field_add:aapt.pb.StyleString.spans)
+  return _add;
+}
+inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::StyleString_Span >&
+StyleString::spans() const {
+  // @@protoc_insertion_point(field_list:aapt.pb.StyleString.spans)
+  return _impl_.spans_;
+}
+
+// -------------------------------------------------------------------
+
+// UntranslatableSection
+
+// uint64 start_index = 1;
+inline void UntranslatableSection::clear_start_index() {
+  _impl_.start_index_ = ::uint64_t{0u};
+}
+inline ::uint64_t UntranslatableSection::_internal_start_index() const {
+  return _impl_.start_index_;
+}
+inline ::uint64_t UntranslatableSection::start_index() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.UntranslatableSection.start_index)
+  return _internal_start_index();
+}
+inline void UntranslatableSection::_internal_set_start_index(::uint64_t value) {
+  
+  _impl_.start_index_ = value;
+}
+inline void UntranslatableSection::set_start_index(::uint64_t value) {
+  _internal_set_start_index(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.UntranslatableSection.start_index)
+}
+
+// uint64 end_index = 2;
+inline void UntranslatableSection::clear_end_index() {
+  _impl_.end_index_ = ::uint64_t{0u};
+}
+inline ::uint64_t UntranslatableSection::_internal_end_index() const {
+  return _impl_.end_index_;
+}
+inline ::uint64_t UntranslatableSection::end_index() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.UntranslatableSection.end_index)
+  return _internal_end_index();
+}
+inline void UntranslatableSection::_internal_set_end_index(::uint64_t value) {
+  
+  _impl_.end_index_ = value;
+}
+inline void UntranslatableSection::set_end_index(::uint64_t value) {
+  _internal_set_end_index(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.UntranslatableSection.end_index)
+}
+
+#ifdef __GNUC__
+  #pragma GCC diagnostic pop
+#endif  // __GNUC__
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+
+// @@protoc_insertion_point(namespace_scope)
+
+}  // namespace pb
+}  // namespace aapt
+
+PROTOBUF_NAMESPACE_OPEN
+
+template <> struct is_proto_enum< ::aapt::pb::Visibility_Level> : ::std::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Visibility_Level>() {
+  return ::aapt::pb::Visibility_Level_descriptor();
+}
+template <> struct is_proto_enum< ::aapt::pb::OverlayableItem_Policy> : ::std::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::OverlayableItem_Policy>() {
+  return ::aapt::pb::OverlayableItem_Policy_descriptor();
+}
+template <> struct is_proto_enum< ::aapt::pb::Reference_Type> : ::std::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Reference_Type>() {
+  return ::aapt::pb::Reference_Type_descriptor();
+}
+template <> struct is_proto_enum< ::aapt::pb::FileReference_Type> : ::std::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::FileReference_Type>() {
+  return ::aapt::pb::FileReference_Type_descriptor();
+}
+template <> struct is_proto_enum< ::aapt::pb::Attribute_FormatFlags> : ::std::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Attribute_FormatFlags>() {
+  return ::aapt::pb::Attribute_FormatFlags_descriptor();
+}
+template <> struct is_proto_enum< ::aapt::pb::Plural_Arity> : ::std::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::aapt::pb::Plural_Arity>() {
+  return ::aapt::pb::Plural_Arity_descriptor();
+}
+
+PROTOBUF_NAMESPACE_CLOSE
+
+// @@protoc_insertion_point(global_scope)
+
+#include <google/protobuf/port_undef.inc>
+#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Resources_2eproto
diff --git a/tools/aapt2/Resources.proto b/tools/aapt2/Resources.proto
index 95b79496..be363bc1 100644
--- a/tools/aapt2/Resources.proto
+++ b/tools/aapt2/Resources.proto
@@ -16,7 +16,7 @@
 
 syntax = "proto3";
 
-import "frameworks/base/tools/aapt2/Configuration.proto";
+import "Configuration.proto";
 
 package aapt.pb;
 
diff --git a/tools/aapt2/ResourcesInternal.pb.cc b/tools/aapt2/ResourcesInternal.pb.cc
new file mode 100644
index 00000000..b5c12fea
--- /dev/null
+++ b/tools/aapt2/ResourcesInternal.pb.cc
@@ -0,0 +1,774 @@
+// Generated by the protocol buffer compiler.  DO NOT EDIT!
+// source: ResourcesInternal.proto
+
+#include "ResourcesInternal.pb.h"
+
+#include <algorithm>
+#include <cstdint>
+
+#include <google/protobuf/io/coded_stream.h>
+#include <google/protobuf/extension_set.h>
+#include <google/protobuf/wire_format_lite.h>
+#include <google/protobuf/descriptor.h>
+#include <google/protobuf/generated_message_reflection.h>
+#include <google/protobuf/reflection_ops.h>
+#include <google/protobuf/wire_format.h>
+// @@protoc_insertion_point(includes)
+#include <google/protobuf/port_def.inc>
+
+PROTOBUF_PRAGMA_INIT_SEG
+
+namespace _pb = ::PROTOBUF_NAMESPACE_ID;
+namespace _pbi = _pb::internal;
+
+namespace aapt {
+namespace pb {
+namespace internal {
+PROTOBUF_CONSTEXPR CompiledFile_Symbol::CompiledFile_Symbol(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.resource_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.source_)*/nullptr
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct CompiledFile_SymbolDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR CompiledFile_SymbolDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~CompiledFile_SymbolDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    CompiledFile_Symbol _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompiledFile_SymbolDefaultTypeInternal _CompiledFile_Symbol_default_instance_;
+PROTOBUF_CONSTEXPR CompiledFile::CompiledFile(
+    ::_pbi::ConstantInitialized): _impl_{
+    /*decltype(_impl_.exported_symbol_)*/{}
+  , /*decltype(_impl_.resource_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.source_path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
+  , /*decltype(_impl_.config_)*/nullptr
+  , /*decltype(_impl_.type_)*/0
+  , /*decltype(_impl_._cached_size_)*/{}} {}
+struct CompiledFileDefaultTypeInternal {
+  PROTOBUF_CONSTEXPR CompiledFileDefaultTypeInternal()
+      : _instance(::_pbi::ConstantInitialized{}) {}
+  ~CompiledFileDefaultTypeInternal() {}
+  union {  // NOLINT(misc-non-private-member-variables-in-classes)
+    CompiledFile _instance;
+  };
+};
+PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompiledFileDefaultTypeInternal _CompiledFile_default_instance_;
+}  // namespace internal
+}  // namespace pb
+}  // namespace aapt
+static ::_pb::Metadata file_level_metadata_ResourcesInternal_2eproto[2];
+static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_ResourcesInternal_2eproto = nullptr;
+static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_ResourcesInternal_2eproto = nullptr;
+
+const ::uint32_t TableStruct_ResourcesInternal_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::internal::CompiledFile_Symbol, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::internal::CompiledFile_Symbol, _impl_.resource_name_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::internal::CompiledFile_Symbol, _impl_.source_),
+  ~0u,  // no _has_bits_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::internal::CompiledFile, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  ~0u,  // no _inlined_string_donated_
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::internal::CompiledFile, _impl_.resource_name_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::internal::CompiledFile, _impl_.config_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::internal::CompiledFile, _impl_.type_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::internal::CompiledFile, _impl_.source_path_),
+  PROTOBUF_FIELD_OFFSET(::aapt::pb::internal::CompiledFile, _impl_.exported_symbol_),
+};
+static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
+  { 0, -1, -1, sizeof(::aapt::pb::internal::CompiledFile_Symbol)},
+  { 8, -1, -1, sizeof(::aapt::pb::internal::CompiledFile)},
+};
+
+static const ::_pb::Message* const file_default_instances[] = {
+  &::aapt::pb::internal::_CompiledFile_Symbol_default_instance_._instance,
+  &::aapt::pb::internal::_CompiledFile_default_instance_._instance,
+};
+
+const char descriptor_table_protodef_ResourcesInternal_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
+  "\n\027ResourcesInternal.proto\022\020aapt.pb.inter"
+  "nal\032\023Configuration.proto\032\017Resources.prot"
+  "o\"\227\002\n\014CompiledFile\022\025\n\rresource_name\030\001 \001("
+  "\t\022&\n\006config\030\002 \001(\0132\026.aapt.pb.Configuratio"
+  "n\022)\n\004type\030\003 \001(\0162\033.aapt.pb.FileReference."
+  "Type\022\023\n\013source_path\030\004 \001(\t\022>\n\017exported_sy"
+  "mbol\030\005 \003(\0132%.aapt.pb.internal.CompiledFi"
+  "le.Symbol\032H\n\006Symbol\022\025\n\rresource_name\030\001 \001"
+  "(\t\022\'\n\006source\030\002 \001(\0132\027.aapt.pb.SourcePosit"
+  "ionB\032\n\030android.aapt.pb.internalb\006proto3"
+  ;
+static const ::_pbi::DescriptorTable* const descriptor_table_ResourcesInternal_2eproto_deps[2] = {
+  &::descriptor_table_Configuration_2eproto,
+  &::descriptor_table_Resources_2eproto,
+};
+static ::_pbi::once_flag descriptor_table_ResourcesInternal_2eproto_once;
+const ::_pbi::DescriptorTable descriptor_table_ResourcesInternal_2eproto = {
+    false, false, 399, descriptor_table_protodef_ResourcesInternal_2eproto,
+    "ResourcesInternal.proto",
+    &descriptor_table_ResourcesInternal_2eproto_once, descriptor_table_ResourcesInternal_2eproto_deps, 2, 2,
+    schemas, file_default_instances, TableStruct_ResourcesInternal_2eproto::offsets,
+    file_level_metadata_ResourcesInternal_2eproto, file_level_enum_descriptors_ResourcesInternal_2eproto,
+    file_level_service_descriptors_ResourcesInternal_2eproto,
+};
+PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_ResourcesInternal_2eproto_getter() {
+  return &descriptor_table_ResourcesInternal_2eproto;
+}
+
+// Force running AddDescriptors() at dynamic initialization time.
+PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_ResourcesInternal_2eproto(&descriptor_table_ResourcesInternal_2eproto);
+namespace aapt {
+namespace pb {
+namespace internal {
+
+// ===================================================================
+
+class CompiledFile_Symbol::_Internal {
+ public:
+  static const ::aapt::pb::SourcePosition& source(const CompiledFile_Symbol* msg);
+};
+
+const ::aapt::pb::SourcePosition&
+CompiledFile_Symbol::_Internal::source(const CompiledFile_Symbol* msg) {
+  return *msg->_impl_.source_;
+}
+void CompiledFile_Symbol::clear_source() {
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+}
+CompiledFile_Symbol::CompiledFile_Symbol(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.internal.CompiledFile.Symbol)
+}
+CompiledFile_Symbol::CompiledFile_Symbol(const CompiledFile_Symbol& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  CompiledFile_Symbol* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.resource_name_){}
+    , decltype(_impl_.source_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.resource_name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.resource_name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_resource_name().empty()) {
+    _this->_impl_.resource_name_.Set(from._internal_resource_name(), 
+      _this->GetArenaForAllocation());
+  }
+  if (from._internal_has_source()) {
+    _this->_impl_.source_ = new ::aapt::pb::SourcePosition(*from._impl_.source_);
+  }
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.internal.CompiledFile.Symbol)
+}
+
+inline void CompiledFile_Symbol::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.resource_name_){}
+    , decltype(_impl_.source_){nullptr}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.resource_name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.resource_name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+CompiledFile_Symbol::~CompiledFile_Symbol() {
+  // @@protoc_insertion_point(destructor:aapt.pb.internal.CompiledFile.Symbol)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void CompiledFile_Symbol::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.resource_name_.Destroy();
+  if (this != internal_default_instance()) delete _impl_.source_;
+}
+
+void CompiledFile_Symbol::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void CompiledFile_Symbol::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.internal.CompiledFile.Symbol)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.resource_name_.ClearToEmpty();
+  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
+    delete _impl_.source_;
+  }
+  _impl_.source_ = nullptr;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* CompiledFile_Symbol::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // string resource_name = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          auto str = _internal_mutable_resource_name();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.internal.CompiledFile.Symbol.resource_name"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.SourcePosition source = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* CompiledFile_Symbol::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.internal.CompiledFile.Symbol)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // string resource_name = 1;
+  if (!this->_internal_resource_name().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_resource_name().data(), static_cast<int>(this->_internal_resource_name().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.internal.CompiledFile.Symbol.resource_name");
+    target = stream->WriteStringMaybeAliased(
+        1, this->_internal_resource_name(), target);
+  }
+
+  // .aapt.pb.SourcePosition source = 2;
+  if (this->_internal_has_source()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(2, _Internal::source(this),
+        _Internal::source(this).GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.internal.CompiledFile.Symbol)
+  return target;
+}
+
+size_t CompiledFile_Symbol::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.internal.CompiledFile.Symbol)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // string resource_name = 1;
+  if (!this->_internal_resource_name().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_resource_name());
+  }
+
+  // .aapt.pb.SourcePosition source = 2;
+  if (this->_internal_has_source()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.source_);
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CompiledFile_Symbol::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    CompiledFile_Symbol::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CompiledFile_Symbol::GetClassData() const { return &_class_data_; }
+
+
+void CompiledFile_Symbol::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<CompiledFile_Symbol*>(&to_msg);
+  auto& from = static_cast<const CompiledFile_Symbol&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.internal.CompiledFile.Symbol)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (!from._internal_resource_name().empty()) {
+    _this->_internal_set_resource_name(from._internal_resource_name());
+  }
+  if (from._internal_has_source()) {
+    _this->_internal_mutable_source()->::aapt::pb::SourcePosition::MergeFrom(
+        from._internal_source());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void CompiledFile_Symbol::CopyFrom(const CompiledFile_Symbol& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.internal.CompiledFile.Symbol)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool CompiledFile_Symbol::IsInitialized() const {
+  return true;
+}
+
+void CompiledFile_Symbol::InternalSwap(CompiledFile_Symbol* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.resource_name_, lhs_arena,
+      &other->_impl_.resource_name_, rhs_arena
+  );
+  swap(_impl_.source_, other->_impl_.source_);
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata CompiledFile_Symbol::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_ResourcesInternal_2eproto_getter, &descriptor_table_ResourcesInternal_2eproto_once,
+      file_level_metadata_ResourcesInternal_2eproto[0]);
+}
+
+// ===================================================================
+
+class CompiledFile::_Internal {
+ public:
+  static const ::aapt::pb::Configuration& config(const CompiledFile* msg);
+};
+
+const ::aapt::pb::Configuration&
+CompiledFile::_Internal::config(const CompiledFile* msg) {
+  return *msg->_impl_.config_;
+}
+void CompiledFile::clear_config() {
+  if (GetArenaForAllocation() == nullptr && _impl_.config_ != nullptr) {
+    delete _impl_.config_;
+  }
+  _impl_.config_ = nullptr;
+}
+CompiledFile::CompiledFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                         bool is_message_owned)
+  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
+  SharedCtor(arena, is_message_owned);
+  // @@protoc_insertion_point(arena_constructor:aapt.pb.internal.CompiledFile)
+}
+CompiledFile::CompiledFile(const CompiledFile& from)
+  : ::PROTOBUF_NAMESPACE_ID::Message() {
+  CompiledFile* const _this = this; (void)_this;
+  new (&_impl_) Impl_{
+      decltype(_impl_.exported_symbol_){from._impl_.exported_symbol_}
+    , decltype(_impl_.resource_name_){}
+    , decltype(_impl_.source_path_){}
+    , decltype(_impl_.config_){nullptr}
+    , decltype(_impl_.type_){}
+    , /*decltype(_impl_._cached_size_)*/{}};
+
+  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+  _impl_.resource_name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.resource_name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_resource_name().empty()) {
+    _this->_impl_.resource_name_.Set(from._internal_resource_name(), 
+      _this->GetArenaForAllocation());
+  }
+  _impl_.source_path_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.source_path_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (!from._internal_source_path().empty()) {
+    _this->_impl_.source_path_.Set(from._internal_source_path(), 
+      _this->GetArenaForAllocation());
+  }
+  if (from._internal_has_config()) {
+    _this->_impl_.config_ = new ::aapt::pb::Configuration(*from._impl_.config_);
+  }
+  _this->_impl_.type_ = from._impl_.type_;
+  // @@protoc_insertion_point(copy_constructor:aapt.pb.internal.CompiledFile)
+}
+
+inline void CompiledFile::SharedCtor(
+    ::_pb::Arena* arena, bool is_message_owned) {
+  (void)arena;
+  (void)is_message_owned;
+  new (&_impl_) Impl_{
+      decltype(_impl_.exported_symbol_){arena}
+    , decltype(_impl_.resource_name_){}
+    , decltype(_impl_.source_path_){}
+    , decltype(_impl_.config_){nullptr}
+    , decltype(_impl_.type_){0}
+    , /*decltype(_impl_._cached_size_)*/{}
+  };
+  _impl_.resource_name_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.resource_name_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.source_path_.InitDefault();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+    _impl_.source_path_.Set("", GetArenaForAllocation());
+  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+}
+
+CompiledFile::~CompiledFile() {
+  // @@protoc_insertion_point(destructor:aapt.pb.internal.CompiledFile)
+  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
+  (void)arena;
+    return;
+  }
+  SharedDtor();
+}
+
+inline void CompiledFile::SharedDtor() {
+  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
+  _impl_.exported_symbol_.~RepeatedPtrField();
+  _impl_.resource_name_.Destroy();
+  _impl_.source_path_.Destroy();
+  if (this != internal_default_instance()) delete _impl_.config_;
+}
+
+void CompiledFile::SetCachedSize(int size) const {
+  _impl_._cached_size_.Set(size);
+}
+
+void CompiledFile::Clear() {
+// @@protoc_insertion_point(message_clear_start:aapt.pb.internal.CompiledFile)
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  _impl_.exported_symbol_.Clear();
+  _impl_.resource_name_.ClearToEmpty();
+  _impl_.source_path_.ClearToEmpty();
+  if (GetArenaForAllocation() == nullptr && _impl_.config_ != nullptr) {
+    delete _impl_.config_;
+  }
+  _impl_.config_ = nullptr;
+  _impl_.type_ = 0;
+  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
+}
+
+const char* CompiledFile::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
+  while (!ctx->Done(&ptr)) {
+    ::uint32_t tag;
+    ptr = ::_pbi::ReadTag(ptr, &tag);
+    switch (tag >> 3) {
+      // string resource_name = 1;
+      case 1:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
+          auto str = _internal_mutable_resource_name();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.internal.CompiledFile.resource_name"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.Configuration config = 2;
+      case 2:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
+          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
+          CHK_(ptr);
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // .aapt.pb.FileReference.Type type = 3;
+      case 3:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
+          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+          _internal_set_type(static_cast<::aapt::pb::FileReference_Type>(val));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // string source_path = 4;
+      case 4:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
+          auto str = _internal_mutable_source_path();
+          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
+          CHK_(ptr);
+          CHK_(::_pbi::VerifyUTF8(str, "aapt.pb.internal.CompiledFile.source_path"));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      // repeated .aapt.pb.internal.CompiledFile.Symbol exported_symbol = 5;
+      case 5:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
+          ptr -= 1;
+          do {
+            ptr += 1;
+            ptr = ctx->ParseMessage(_internal_add_exported_symbol(), ptr);
+            CHK_(ptr);
+            if (!ctx->DataAvailable(ptr)) break;
+          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
+        } else {
+          goto handle_unusual;
+        }
+        continue;
+      default:
+        goto handle_unusual;
+    }  // switch
+  handle_unusual:
+    if ((tag == 0) || ((tag & 7) == 4)) {
+      CHK_(ptr);
+      ctx->SetLastTag(tag);
+      goto message_done;
+    }
+    ptr = UnknownFieldParse(
+        tag,
+        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
+        ptr, ctx);
+    CHK_(ptr != nullptr);
+  }  // while
+message_done:
+  return ptr;
+failure:
+  ptr = nullptr;
+  goto message_done;
+#undef CHK_
+}
+
+::uint8_t* CompiledFile::_InternalSerialize(
+    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
+  // @@protoc_insertion_point(serialize_to_array_start:aapt.pb.internal.CompiledFile)
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // string resource_name = 1;
+  if (!this->_internal_resource_name().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_resource_name().data(), static_cast<int>(this->_internal_resource_name().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.internal.CompiledFile.resource_name");
+    target = stream->WriteStringMaybeAliased(
+        1, this->_internal_resource_name(), target);
+  }
+
+  // .aapt.pb.Configuration config = 2;
+  if (this->_internal_has_config()) {
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+      InternalWriteMessage(2, _Internal::config(this),
+        _Internal::config(this).GetCachedSize(), target, stream);
+  }
+
+  // .aapt.pb.FileReference.Type type = 3;
+  if (this->_internal_type() != 0) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteEnumToArray(
+      3, this->_internal_type(), target);
+  }
+
+  // string source_path = 4;
+  if (!this->_internal_source_path().empty()) {
+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
+      this->_internal_source_path().data(), static_cast<int>(this->_internal_source_path().length()),
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
+      "aapt.pb.internal.CompiledFile.source_path");
+    target = stream->WriteStringMaybeAliased(
+        4, this->_internal_source_path(), target);
+  }
+
+  // repeated .aapt.pb.internal.CompiledFile.Symbol exported_symbol = 5;
+  for (unsigned i = 0,
+      n = static_cast<unsigned>(this->_internal_exported_symbol_size()); i < n; i++) {
+    const auto& repfield = this->_internal_exported_symbol(i);
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
+        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
+  }
+
+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
+    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
+        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:aapt.pb.internal.CompiledFile)
+  return target;
+}
+
+size_t CompiledFile::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:aapt.pb.internal.CompiledFile)
+  size_t total_size = 0;
+
+  ::uint32_t cached_has_bits = 0;
+  // Prevent compiler warnings about cached_has_bits being unused
+  (void) cached_has_bits;
+
+  // repeated .aapt.pb.internal.CompiledFile.Symbol exported_symbol = 5;
+  total_size += 1UL * this->_internal_exported_symbol_size();
+  for (const auto& msg : this->_impl_.exported_symbol_) {
+    total_size +=
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
+  }
+
+  // string resource_name = 1;
+  if (!this->_internal_resource_name().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_resource_name());
+  }
+
+  // string source_path = 4;
+  if (!this->_internal_source_path().empty()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
+        this->_internal_source_path());
+  }
+
+  // .aapt.pb.Configuration config = 2;
+  if (this->_internal_has_config()) {
+    total_size += 1 +
+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
+        *_impl_.config_);
+  }
+
+  // .aapt.pb.FileReference.Type type = 3;
+  if (this->_internal_type() != 0) {
+    total_size += 1 +
+      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
+  }
+
+  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
+}
+
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CompiledFile::_class_data_ = {
+    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
+    CompiledFile::MergeImpl
+};
+const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CompiledFile::GetClassData() const { return &_class_data_; }
+
+
+void CompiledFile::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
+  auto* const _this = static_cast<CompiledFile*>(&to_msg);
+  auto& from = static_cast<const CompiledFile&>(from_msg);
+  // @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.internal.CompiledFile)
+  GOOGLE_DCHECK_NE(&from, _this);
+  ::uint32_t cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  _this->_impl_.exported_symbol_.MergeFrom(from._impl_.exported_symbol_);
+  if (!from._internal_resource_name().empty()) {
+    _this->_internal_set_resource_name(from._internal_resource_name());
+  }
+  if (!from._internal_source_path().empty()) {
+    _this->_internal_set_source_path(from._internal_source_path());
+  }
+  if (from._internal_has_config()) {
+    _this->_internal_mutable_config()->::aapt::pb::Configuration::MergeFrom(
+        from._internal_config());
+  }
+  if (from._internal_type() != 0) {
+    _this->_internal_set_type(from._internal_type());
+  }
+  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
+}
+
+void CompiledFile::CopyFrom(const CompiledFile& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.internal.CompiledFile)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool CompiledFile::IsInitialized() const {
+  return true;
+}
+
+void CompiledFile::InternalSwap(CompiledFile* other) {
+  using std::swap;
+  auto* lhs_arena = GetArenaForAllocation();
+  auto* rhs_arena = other->GetArenaForAllocation();
+  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
+  _impl_.exported_symbol_.InternalSwap(&other->_impl_.exported_symbol_);
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.resource_name_, lhs_arena,
+      &other->_impl_.resource_name_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
+      &_impl_.source_path_, lhs_arena,
+      &other->_impl_.source_path_, rhs_arena
+  );
+  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
+      PROTOBUF_FIELD_OFFSET(CompiledFile, _impl_.type_)
+      + sizeof(CompiledFile::_impl_.type_)  // NOLINT
+      - PROTOBUF_FIELD_OFFSET(CompiledFile, _impl_.config_)>(
+          reinterpret_cast<char*>(&_impl_.config_),
+          reinterpret_cast<char*>(&other->_impl_.config_));
+}
+
+::PROTOBUF_NAMESPACE_ID::Metadata CompiledFile::GetMetadata() const {
+  return ::_pbi::AssignDescriptors(
+      &descriptor_table_ResourcesInternal_2eproto_getter, &descriptor_table_ResourcesInternal_2eproto_once,
+      file_level_metadata_ResourcesInternal_2eproto[1]);
+}
+
+// @@protoc_insertion_point(namespace_scope)
+}  // namespace internal
+}  // namespace pb
+}  // namespace aapt
+PROTOBUF_NAMESPACE_OPEN
+template<> PROTOBUF_NOINLINE ::aapt::pb::internal::CompiledFile_Symbol*
+Arena::CreateMaybeMessage< ::aapt::pb::internal::CompiledFile_Symbol >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::internal::CompiledFile_Symbol >(arena);
+}
+template<> PROTOBUF_NOINLINE ::aapt::pb::internal::CompiledFile*
+Arena::CreateMaybeMessage< ::aapt::pb::internal::CompiledFile >(Arena* arena) {
+  return Arena::CreateMessageInternal< ::aapt::pb::internal::CompiledFile >(arena);
+}
+PROTOBUF_NAMESPACE_CLOSE
+
+// @@protoc_insertion_point(global_scope)
+#include <google/protobuf/port_undef.inc>
diff --git a/tools/aapt2/ResourcesInternal.pb.h b/tools/aapt2/ResourcesInternal.pb.h
new file mode 100644
index 00000000..42adfc94
--- /dev/null
+++ b/tools/aapt2/ResourcesInternal.pb.h
@@ -0,0 +1,858 @@
+// Generated by the protocol buffer compiler.  DO NOT EDIT!
+// source: ResourcesInternal.proto
+
+#ifndef GOOGLE_PROTOBUF_INCLUDED_ResourcesInternal_2eproto
+#define GOOGLE_PROTOBUF_INCLUDED_ResourcesInternal_2eproto
+
+#include <cstdint>
+#include <limits>
+#include <string>
+
+#include <google/protobuf/port_def.inc>
+#if PROTOBUF_VERSION < 3021000
+#error This file was generated by a newer version of protoc which is
+#error incompatible with your Protocol Buffer headers. Please update
+#error your headers.
+#endif
+#if 3021007 < PROTOBUF_MIN_PROTOC_VERSION
+#error This file was generated by an older version of protoc which is
+#error incompatible with your Protocol Buffer headers. Please
+#error regenerate this file with a newer version of protoc.
+#endif
+
+#include <google/protobuf/port_undef.inc>
+#include <google/protobuf/io/coded_stream.h>
+#include <google/protobuf/arena.h>
+#include <google/protobuf/arenastring.h>
+#include <google/protobuf/generated_message_util.h>
+#include <google/protobuf/metadata_lite.h>
+#include <google/protobuf/generated_message_reflection.h>
+#include <google/protobuf/message.h>
+#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
+#include <google/protobuf/extension_set.h>  // IWYU pragma: export
+#include <google/protobuf/unknown_field_set.h>
+#include "Configuration.pb.h"
+#include "Resources.pb.h"
+// @@protoc_insertion_point(includes)
+#include <google/protobuf/port_def.inc>
+#define PROTOBUF_INTERNAL_EXPORT_ResourcesInternal_2eproto
+PROTOBUF_NAMESPACE_OPEN
+namespace internal {
+class AnyMetadata;
+}  // namespace internal
+PROTOBUF_NAMESPACE_CLOSE
+
+// Internal implementation detail -- do not use these members.
+struct TableStruct_ResourcesInternal_2eproto {
+  static const ::uint32_t offsets[];
+};
+extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ResourcesInternal_2eproto;
+namespace aapt {
+namespace pb {
+namespace internal {
+class CompiledFile;
+struct CompiledFileDefaultTypeInternal;
+extern CompiledFileDefaultTypeInternal _CompiledFile_default_instance_;
+class CompiledFile_Symbol;
+struct CompiledFile_SymbolDefaultTypeInternal;
+extern CompiledFile_SymbolDefaultTypeInternal _CompiledFile_Symbol_default_instance_;
+}  // namespace internal
+}  // namespace pb
+}  // namespace aapt
+PROTOBUF_NAMESPACE_OPEN
+template<> ::aapt::pb::internal::CompiledFile* Arena::CreateMaybeMessage<::aapt::pb::internal::CompiledFile>(Arena*);
+template<> ::aapt::pb::internal::CompiledFile_Symbol* Arena::CreateMaybeMessage<::aapt::pb::internal::CompiledFile_Symbol>(Arena*);
+PROTOBUF_NAMESPACE_CLOSE
+namespace aapt {
+namespace pb {
+namespace internal {
+
+// ===================================================================
+
+class CompiledFile_Symbol final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.internal.CompiledFile.Symbol) */ {
+ public:
+  inline CompiledFile_Symbol() : CompiledFile_Symbol(nullptr) {}
+  ~CompiledFile_Symbol() override;
+  explicit PROTOBUF_CONSTEXPR CompiledFile_Symbol(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  CompiledFile_Symbol(const CompiledFile_Symbol& from);
+  CompiledFile_Symbol(CompiledFile_Symbol&& from) noexcept
+    : CompiledFile_Symbol() {
+    *this = ::std::move(from);
+  }
+
+  inline CompiledFile_Symbol& operator=(const CompiledFile_Symbol& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline CompiledFile_Symbol& operator=(CompiledFile_Symbol&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const CompiledFile_Symbol& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const CompiledFile_Symbol* internal_default_instance() {
+    return reinterpret_cast<const CompiledFile_Symbol*>(
+               &_CompiledFile_Symbol_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    0;
+
+  friend void swap(CompiledFile_Symbol& a, CompiledFile_Symbol& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(CompiledFile_Symbol* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(CompiledFile_Symbol* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  CompiledFile_Symbol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<CompiledFile_Symbol>(arena);
+  }
+  CompiledFile_Symbol* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const CompiledFile_Symbol& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const CompiledFile_Symbol& from) {
+    CompiledFile_Symbol::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(CompiledFile_Symbol* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.internal.CompiledFile.Symbol";
+  }
+  protected:
+  explicit CompiledFile_Symbol(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kResourceNameFieldNumber = 1,
+    kSourceFieldNumber = 2,
+  };
+  // string resource_name = 1;
+  void clear_resource_name();
+  const std::string& resource_name() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_resource_name(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_resource_name();
+  PROTOBUF_NODISCARD std::string* release_resource_name();
+  void set_allocated_resource_name(std::string* resource_name);
+  private:
+  const std::string& _internal_resource_name() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_name(const std::string& value);
+  std::string* _internal_mutable_resource_name();
+  public:
+
+  // .aapt.pb.SourcePosition source = 2;
+  bool has_source() const;
+  private:
+  bool _internal_has_source() const;
+  public:
+  void clear_source();
+  const ::aapt::pb::SourcePosition& source() const;
+  PROTOBUF_NODISCARD ::aapt::pb::SourcePosition* release_source();
+  ::aapt::pb::SourcePosition* mutable_source();
+  void set_allocated_source(::aapt::pb::SourcePosition* source);
+  private:
+  const ::aapt::pb::SourcePosition& _internal_source() const;
+  ::aapt::pb::SourcePosition* _internal_mutable_source();
+  public:
+  void unsafe_arena_set_allocated_source(
+      ::aapt::pb::SourcePosition* source);
+  ::aapt::pb::SourcePosition* unsafe_arena_release_source();
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.internal.CompiledFile.Symbol)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_name_;
+    ::aapt::pb::SourcePosition* source_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_ResourcesInternal_2eproto;
+};
+// -------------------------------------------------------------------
+
+class CompiledFile final :
+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aapt.pb.internal.CompiledFile) */ {
+ public:
+  inline CompiledFile() : CompiledFile(nullptr) {}
+  ~CompiledFile() override;
+  explicit PROTOBUF_CONSTEXPR CompiledFile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
+
+  CompiledFile(const CompiledFile& from);
+  CompiledFile(CompiledFile&& from) noexcept
+    : CompiledFile() {
+    *this = ::std::move(from);
+  }
+
+  inline CompiledFile& operator=(const CompiledFile& from) {
+    if (this == &from) return *this;
+    CopyFrom(from);
+    return *this;
+  }
+  inline CompiledFile& operator=(CompiledFile&& from) noexcept {
+    if (this == &from) return *this;
+    if (GetOwningArena() == from.GetOwningArena()
+  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        && GetOwningArena() != nullptr
+  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      InternalSwap(&from);
+    } else {
+      CopyFrom(from);
+    }
+    return *this;
+  }
+
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
+    return GetDescriptor();
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
+    return default_instance().GetMetadata().descriptor;
+  }
+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
+    return default_instance().GetMetadata().reflection;
+  }
+  static const CompiledFile& default_instance() {
+    return *internal_default_instance();
+  }
+  static inline const CompiledFile* internal_default_instance() {
+    return reinterpret_cast<const CompiledFile*>(
+               &_CompiledFile_default_instance_);
+  }
+  static constexpr int kIndexInFileMessages =
+    1;
+
+  friend void swap(CompiledFile& a, CompiledFile& b) {
+    a.Swap(&b);
+  }
+  inline void Swap(CompiledFile* other) {
+    if (other == this) return;
+  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena()) {
+   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena()) {
+  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+      InternalSwap(other);
+    } else {
+      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
+    }
+  }
+  void UnsafeArenaSwap(CompiledFile* other) {
+    if (other == this) return;
+    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
+    InternalSwap(other);
+  }
+
+  // implements Message ----------------------------------------------
+
+  CompiledFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
+    return CreateMaybeMessage<CompiledFile>(arena);
+  }
+  CompiledFile* New() const {
+    return New(nullptr);
+  }
+  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
+  void CopyFrom(const CompiledFile& from);
+  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
+  void MergeFrom( const CompiledFile& from) {
+    CompiledFile::MergeImpl(*this, from);
+  }
+  private:
+  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
+  public:
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
+  bool IsInitialized() const final;
+
+  size_t ByteSizeLong() const final;
+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
+  ::uint8_t* _InternalSerialize(
+      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
+  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }
+
+  private:
+  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
+  void SharedDtor();
+  void SetCachedSize(int size) const final;
+  void InternalSwap(CompiledFile* other);
+
+  private:
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
+    return "aapt.pb.internal.CompiledFile";
+  }
+  protected:
+  explicit CompiledFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
+                       bool is_message_owned = false);
+  public:
+
+  static const ClassData _class_data_;
+  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;
+
+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
+
+  // nested types ----------------------------------------------------
+
+  typedef CompiledFile_Symbol Symbol;
+
+  // accessors -------------------------------------------------------
+
+  enum : int {
+    kExportedSymbolFieldNumber = 5,
+    kResourceNameFieldNumber = 1,
+    kSourcePathFieldNumber = 4,
+    kConfigFieldNumber = 2,
+    kTypeFieldNumber = 3,
+  };
+  // repeated .aapt.pb.internal.CompiledFile.Symbol exported_symbol = 5;
+  int exported_symbol_size() const;
+  private:
+  int _internal_exported_symbol_size() const;
+  public:
+  void clear_exported_symbol();
+  ::aapt::pb::internal::CompiledFile_Symbol* mutable_exported_symbol(int index);
+  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::internal::CompiledFile_Symbol >*
+      mutable_exported_symbol();
+  private:
+  const ::aapt::pb::internal::CompiledFile_Symbol& _internal_exported_symbol(int index) const;
+  ::aapt::pb::internal::CompiledFile_Symbol* _internal_add_exported_symbol();
+  public:
+  const ::aapt::pb::internal::CompiledFile_Symbol& exported_symbol(int index) const;
+  ::aapt::pb::internal::CompiledFile_Symbol* add_exported_symbol();
+  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::internal::CompiledFile_Symbol >&
+      exported_symbol() const;
+
+  // string resource_name = 1;
+  void clear_resource_name();
+  const std::string& resource_name() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_resource_name(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_resource_name();
+  PROTOBUF_NODISCARD std::string* release_resource_name();
+  void set_allocated_resource_name(std::string* resource_name);
+  private:
+  const std::string& _internal_resource_name() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_name(const std::string& value);
+  std::string* _internal_mutable_resource_name();
+  public:
+
+  // string source_path = 4;
+  void clear_source_path();
+  const std::string& source_path() const;
+  template <typename ArgT0 = const std::string&, typename... ArgT>
+  void set_source_path(ArgT0&& arg0, ArgT... args);
+  std::string* mutable_source_path();
+  PROTOBUF_NODISCARD std::string* release_source_path();
+  void set_allocated_source_path(std::string* source_path);
+  private:
+  const std::string& _internal_source_path() const;
+  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_path(const std::string& value);
+  std::string* _internal_mutable_source_path();
+  public:
+
+  // .aapt.pb.Configuration config = 2;
+  bool has_config() const;
+  private:
+  bool _internal_has_config() const;
+  public:
+  void clear_config();
+  const ::aapt::pb::Configuration& config() const;
+  PROTOBUF_NODISCARD ::aapt::pb::Configuration* release_config();
+  ::aapt::pb::Configuration* mutable_config();
+  void set_allocated_config(::aapt::pb::Configuration* config);
+  private:
+  const ::aapt::pb::Configuration& _internal_config() const;
+  ::aapt::pb::Configuration* _internal_mutable_config();
+  public:
+  void unsafe_arena_set_allocated_config(
+      ::aapt::pb::Configuration* config);
+  ::aapt::pb::Configuration* unsafe_arena_release_config();
+
+  // .aapt.pb.FileReference.Type type = 3;
+  void clear_type();
+  ::aapt::pb::FileReference_Type type() const;
+  void set_type(::aapt::pb::FileReference_Type value);
+  private:
+  ::aapt::pb::FileReference_Type _internal_type() const;
+  void _internal_set_type(::aapt::pb::FileReference_Type value);
+  public:
+
+  // @@protoc_insertion_point(class_scope:aapt.pb.internal.CompiledFile)
+ private:
+  class _Internal;
+
+  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+  struct Impl_ {
+    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::internal::CompiledFile_Symbol > exported_symbol_;
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_name_;
+    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_path_;
+    ::aapt::pb::Configuration* config_;
+    int type_;
+    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
+  };
+  union { Impl_ _impl_; };
+  friend struct ::TableStruct_ResourcesInternal_2eproto;
+};
+// ===================================================================
+
+
+// ===================================================================
+
+#ifdef __GNUC__
+  #pragma GCC diagnostic push
+  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
+#endif  // __GNUC__
+// CompiledFile_Symbol
+
+// string resource_name = 1;
+inline void CompiledFile_Symbol::clear_resource_name() {
+  _impl_.resource_name_.ClearToEmpty();
+}
+inline const std::string& CompiledFile_Symbol::resource_name() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.internal.CompiledFile.Symbol.resource_name)
+  return _internal_resource_name();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void CompiledFile_Symbol::set_resource_name(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.resource_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.internal.CompiledFile.Symbol.resource_name)
+}
+inline std::string* CompiledFile_Symbol::mutable_resource_name() {
+  std::string* _s = _internal_mutable_resource_name();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.internal.CompiledFile.Symbol.resource_name)
+  return _s;
+}
+inline const std::string& CompiledFile_Symbol::_internal_resource_name() const {
+  return _impl_.resource_name_.Get();
+}
+inline void CompiledFile_Symbol::_internal_set_resource_name(const std::string& value) {
+  
+  _impl_.resource_name_.Set(value, GetArenaForAllocation());
+}
+inline std::string* CompiledFile_Symbol::_internal_mutable_resource_name() {
+  
+  return _impl_.resource_name_.Mutable(GetArenaForAllocation());
+}
+inline std::string* CompiledFile_Symbol::release_resource_name() {
+  // @@protoc_insertion_point(field_release:aapt.pb.internal.CompiledFile.Symbol.resource_name)
+  return _impl_.resource_name_.Release();
+}
+inline void CompiledFile_Symbol::set_allocated_resource_name(std::string* resource_name) {
+  _impl_.resource_name_.SetAllocated(resource_name, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.resource_name_.IsDefault()) {
+    _impl_.resource_name_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.internal.CompiledFile.Symbol.resource_name)
+}
+
+// .aapt.pb.SourcePosition source = 2;
+inline bool CompiledFile_Symbol::_internal_has_source() const {
+  return this != internal_default_instance() && _impl_.source_ != nullptr;
+}
+inline bool CompiledFile_Symbol::has_source() const {
+  return _internal_has_source();
+}
+inline const ::aapt::pb::SourcePosition& CompiledFile_Symbol::_internal_source() const {
+  const ::aapt::pb::SourcePosition* p = _impl_.source_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::SourcePosition&>(
+      ::aapt::pb::_SourcePosition_default_instance_);
+}
+inline const ::aapt::pb::SourcePosition& CompiledFile_Symbol::source() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.internal.CompiledFile.Symbol.source)
+  return _internal_source();
+}
+inline void CompiledFile_Symbol::unsafe_arena_set_allocated_source(
+    ::aapt::pb::SourcePosition* source) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.internal.CompiledFile.Symbol.source)
+}
+inline ::aapt::pb::SourcePosition* CompiledFile_Symbol::release_source() {
+  
+  ::aapt::pb::SourcePosition* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::SourcePosition* CompiledFile_Symbol::unsafe_arena_release_source() {
+  // @@protoc_insertion_point(field_release:aapt.pb.internal.CompiledFile.Symbol.source)
+  
+  ::aapt::pb::SourcePosition* temp = _impl_.source_;
+  _impl_.source_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::SourcePosition* CompiledFile_Symbol::_internal_mutable_source() {
+  
+  if (_impl_.source_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::SourcePosition>(GetArenaForAllocation());
+    _impl_.source_ = p;
+  }
+  return _impl_.source_;
+}
+inline ::aapt::pb::SourcePosition* CompiledFile_Symbol::mutable_source() {
+  ::aapt::pb::SourcePosition* _msg = _internal_mutable_source();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.internal.CompiledFile.Symbol.source)
+  return _msg;
+}
+inline void CompiledFile_Symbol::set_allocated_source(::aapt::pb::SourcePosition* source) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
+  }
+  if (source) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
+                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source));
+    if (message_arena != submessage_arena) {
+      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, source, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.source_ = source;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.internal.CompiledFile.Symbol.source)
+}
+
+// -------------------------------------------------------------------
+
+// CompiledFile
+
+// string resource_name = 1;
+inline void CompiledFile::clear_resource_name() {
+  _impl_.resource_name_.ClearToEmpty();
+}
+inline const std::string& CompiledFile::resource_name() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.internal.CompiledFile.resource_name)
+  return _internal_resource_name();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void CompiledFile::set_resource_name(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.resource_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.internal.CompiledFile.resource_name)
+}
+inline std::string* CompiledFile::mutable_resource_name() {
+  std::string* _s = _internal_mutable_resource_name();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.internal.CompiledFile.resource_name)
+  return _s;
+}
+inline const std::string& CompiledFile::_internal_resource_name() const {
+  return _impl_.resource_name_.Get();
+}
+inline void CompiledFile::_internal_set_resource_name(const std::string& value) {
+  
+  _impl_.resource_name_.Set(value, GetArenaForAllocation());
+}
+inline std::string* CompiledFile::_internal_mutable_resource_name() {
+  
+  return _impl_.resource_name_.Mutable(GetArenaForAllocation());
+}
+inline std::string* CompiledFile::release_resource_name() {
+  // @@protoc_insertion_point(field_release:aapt.pb.internal.CompiledFile.resource_name)
+  return _impl_.resource_name_.Release();
+}
+inline void CompiledFile::set_allocated_resource_name(std::string* resource_name) {
+  _impl_.resource_name_.SetAllocated(resource_name, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.resource_name_.IsDefault()) {
+    _impl_.resource_name_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.internal.CompiledFile.resource_name)
+}
+
+// .aapt.pb.Configuration config = 2;
+inline bool CompiledFile::_internal_has_config() const {
+  return this != internal_default_instance() && _impl_.config_ != nullptr;
+}
+inline bool CompiledFile::has_config() const {
+  return _internal_has_config();
+}
+inline const ::aapt::pb::Configuration& CompiledFile::_internal_config() const {
+  const ::aapt::pb::Configuration* p = _impl_.config_;
+  return p != nullptr ? *p : reinterpret_cast<const ::aapt::pb::Configuration&>(
+      ::aapt::pb::_Configuration_default_instance_);
+}
+inline const ::aapt::pb::Configuration& CompiledFile::config() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.internal.CompiledFile.config)
+  return _internal_config();
+}
+inline void CompiledFile::unsafe_arena_set_allocated_config(
+    ::aapt::pb::Configuration* config) {
+  if (GetArenaForAllocation() == nullptr) {
+    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
+  }
+  _impl_.config_ = config;
+  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aapt.pb.internal.CompiledFile.config)
+}
+inline ::aapt::pb::Configuration* CompiledFile::release_config() {
+  
+  ::aapt::pb::Configuration* temp = _impl_.config_;
+  _impl_.config_ = nullptr;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
+  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  if (GetArenaForAllocation() == nullptr) { delete old; }
+#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
+  if (GetArenaForAllocation() != nullptr) {
+    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  return temp;
+}
+inline ::aapt::pb::Configuration* CompiledFile::unsafe_arena_release_config() {
+  // @@protoc_insertion_point(field_release:aapt.pb.internal.CompiledFile.config)
+  
+  ::aapt::pb::Configuration* temp = _impl_.config_;
+  _impl_.config_ = nullptr;
+  return temp;
+}
+inline ::aapt::pb::Configuration* CompiledFile::_internal_mutable_config() {
+  
+  if (_impl_.config_ == nullptr) {
+    auto* p = CreateMaybeMessage<::aapt::pb::Configuration>(GetArenaForAllocation());
+    _impl_.config_ = p;
+  }
+  return _impl_.config_;
+}
+inline ::aapt::pb::Configuration* CompiledFile::mutable_config() {
+  ::aapt::pb::Configuration* _msg = _internal_mutable_config();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.internal.CompiledFile.config)
+  return _msg;
+}
+inline void CompiledFile::set_allocated_config(::aapt::pb::Configuration* config) {
+  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
+  if (message_arena == nullptr) {
+    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
+  }
+  if (config) {
+    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
+        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
+                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config));
+    if (message_arena != submessage_arena) {
+      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
+          message_arena, config, submessage_arena);
+    }
+    
+  } else {
+    
+  }
+  _impl_.config_ = config;
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.internal.CompiledFile.config)
+}
+
+// .aapt.pb.FileReference.Type type = 3;
+inline void CompiledFile::clear_type() {
+  _impl_.type_ = 0;
+}
+inline ::aapt::pb::FileReference_Type CompiledFile::_internal_type() const {
+  return static_cast< ::aapt::pb::FileReference_Type >(_impl_.type_);
+}
+inline ::aapt::pb::FileReference_Type CompiledFile::type() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.internal.CompiledFile.type)
+  return _internal_type();
+}
+inline void CompiledFile::_internal_set_type(::aapt::pb::FileReference_Type value) {
+  
+  _impl_.type_ = value;
+}
+inline void CompiledFile::set_type(::aapt::pb::FileReference_Type value) {
+  _internal_set_type(value);
+  // @@protoc_insertion_point(field_set:aapt.pb.internal.CompiledFile.type)
+}
+
+// string source_path = 4;
+inline void CompiledFile::clear_source_path() {
+  _impl_.source_path_.ClearToEmpty();
+}
+inline const std::string& CompiledFile::source_path() const {
+  // @@protoc_insertion_point(field_get:aapt.pb.internal.CompiledFile.source_path)
+  return _internal_source_path();
+}
+template <typename ArgT0, typename... ArgT>
+inline PROTOBUF_ALWAYS_INLINE
+void CompiledFile::set_source_path(ArgT0&& arg0, ArgT... args) {
+ 
+ _impl_.source_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
+  // @@protoc_insertion_point(field_set:aapt.pb.internal.CompiledFile.source_path)
+}
+inline std::string* CompiledFile::mutable_source_path() {
+  std::string* _s = _internal_mutable_source_path();
+  // @@protoc_insertion_point(field_mutable:aapt.pb.internal.CompiledFile.source_path)
+  return _s;
+}
+inline const std::string& CompiledFile::_internal_source_path() const {
+  return _impl_.source_path_.Get();
+}
+inline void CompiledFile::_internal_set_source_path(const std::string& value) {
+  
+  _impl_.source_path_.Set(value, GetArenaForAllocation());
+}
+inline std::string* CompiledFile::_internal_mutable_source_path() {
+  
+  return _impl_.source_path_.Mutable(GetArenaForAllocation());
+}
+inline std::string* CompiledFile::release_source_path() {
+  // @@protoc_insertion_point(field_release:aapt.pb.internal.CompiledFile.source_path)
+  return _impl_.source_path_.Release();
+}
+inline void CompiledFile::set_allocated_source_path(std::string* source_path) {
+  _impl_.source_path_.SetAllocated(source_path, GetArenaForAllocation());
+#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  if (_impl_.source_path_.IsDefault()) {
+    _impl_.source_path_.Set("", GetArenaForAllocation());
+  }
+#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  // @@protoc_insertion_point(field_set_allocated:aapt.pb.internal.CompiledFile.source_path)
+}
+
+// repeated .aapt.pb.internal.CompiledFile.Symbol exported_symbol = 5;
+inline int CompiledFile::_internal_exported_symbol_size() const {
+  return _impl_.exported_symbol_.size();
+}
+inline int CompiledFile::exported_symbol_size() const {
+  return _internal_exported_symbol_size();
+}
+inline void CompiledFile::clear_exported_symbol() {
+  _impl_.exported_symbol_.Clear();
+}
+inline ::aapt::pb::internal::CompiledFile_Symbol* CompiledFile::mutable_exported_symbol(int index) {
+  // @@protoc_insertion_point(field_mutable:aapt.pb.internal.CompiledFile.exported_symbol)
+  return _impl_.exported_symbol_.Mutable(index);
+}
+inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::internal::CompiledFile_Symbol >*
+CompiledFile::mutable_exported_symbol() {
+  // @@protoc_insertion_point(field_mutable_list:aapt.pb.internal.CompiledFile.exported_symbol)
+  return &_impl_.exported_symbol_;
+}
+inline const ::aapt::pb::internal::CompiledFile_Symbol& CompiledFile::_internal_exported_symbol(int index) const {
+  return _impl_.exported_symbol_.Get(index);
+}
+inline const ::aapt::pb::internal::CompiledFile_Symbol& CompiledFile::exported_symbol(int index) const {
+  // @@protoc_insertion_point(field_get:aapt.pb.internal.CompiledFile.exported_symbol)
+  return _internal_exported_symbol(index);
+}
+inline ::aapt::pb::internal::CompiledFile_Symbol* CompiledFile::_internal_add_exported_symbol() {
+  return _impl_.exported_symbol_.Add();
+}
+inline ::aapt::pb::internal::CompiledFile_Symbol* CompiledFile::add_exported_symbol() {
+  ::aapt::pb::internal::CompiledFile_Symbol* _add = _internal_add_exported_symbol();
+  // @@protoc_insertion_point(field_add:aapt.pb.internal.CompiledFile.exported_symbol)
+  return _add;
+}
+inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aapt::pb::internal::CompiledFile_Symbol >&
+CompiledFile::exported_symbol() const {
+  // @@protoc_insertion_point(field_list:aapt.pb.internal.CompiledFile.exported_symbol)
+  return _impl_.exported_symbol_;
+}
+
+#ifdef __GNUC__
+  #pragma GCC diagnostic pop
+#endif  // __GNUC__
+// -------------------------------------------------------------------
+
+
+// @@protoc_insertion_point(namespace_scope)
+
+}  // namespace internal
+}  // namespace pb
+}  // namespace aapt
+
+// @@protoc_insertion_point(global_scope)
+
+#include <google/protobuf/port_undef.inc>
+#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ResourcesInternal_2eproto
diff --git a/tools/aapt2/ResourcesInternal.proto b/tools/aapt2/ResourcesInternal.proto
index b0ed3da3..97aa5af7 100644
--- a/tools/aapt2/ResourcesInternal.proto
+++ b/tools/aapt2/ResourcesInternal.proto
@@ -16,8 +16,8 @@
 
 syntax = "proto3";
 
-import "frameworks/base/tools/aapt2/Configuration.proto";
-import "frameworks/base/tools/aapt2/Resources.proto";
+import "Configuration.proto";
+import "Resources.proto";
 
 package aapt.pb.internal;
 
diff --git a/tools/aapt2/util/Files.cpp b/tools/aapt2/util/Files.cpp
index 3285d8ba..aacbff0b 100644
--- a/tools/aapt2/util/Files.cpp
+++ b/tools/aapt2/util/Files.cpp
@@ -189,7 +189,7 @@ void AppendPath(std::string* base, StringPiece part) {
   base->append(part.data(), part.size());
 }
 
-std::string BuildPath(std::vector<const StringPiece>&& args) {
+std::string BuildPath(std::vector<StringPiece>&& args) {
   if (args.empty()) {
     return "";
   }
-- 
2.25.1

