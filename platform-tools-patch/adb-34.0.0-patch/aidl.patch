diff --git a/aidl_checkapi.cpp b/aidl_checkapi.cpp
index 584e5a6..7439788 100644
--- a/aidl_checkapi.cpp
+++ b/aidl_checkapi.cpp
@@ -22,7 +22,7 @@
 
 #include <android-base/result.h>
 #include <android-base/strings.h>
-#include <gtest/gtest.h>
+// #include <gtest/gtest.h>
 
 #include "aidl_dumpapi.h"
 #include "aidl_language.h"
@@ -52,14 +52,14 @@ static std::string Dump(const AidlDefinedType& type) {
 
 // Uses each type's Dump() and GTest utility(EqHelper).
 static bool CheckEquality(const AidlDefinedType& older, const AidlDefinedType& newer) {
-  using testing::internal::EqHelper;
-  auto older_file = older.GetLocation().GetFile();
-  auto newer_file = newer.GetLocation().GetFile();
-  auto result = EqHelper::Compare(older_file.data(), newer_file.data(), Dump(older), Dump(newer));
-  if (!result) {
-    AIDL_ERROR(newer) << result.failure_message();
-  }
-  return result;
+  // using testing::internal::EqHelper;
+  // auto older_file = older.GetLocation().GetFile();
+  // auto newer_file = newer.GetLocation().GetFile();
+  // auto result = EqHelper::Compare(older_file.data(), newer_file.data(), Dump(older), Dump(newer));
+  // if (!result) {
+  //   AIDL_ERROR(newer) << result.failure_message();
+  // }
+  return true;
 }
 
 static vector<string> get_strict_annotations(const AidlAnnotatable& node) {
diff --git a/aidl_to_cpp_common.cpp b/aidl_to_cpp_common.cpp
index 9834c1a..7f5168d 100644
--- a/aidl_to_cpp_common.cpp
+++ b/aidl_to_cpp_common.cpp
@@ -368,8 +368,8 @@ static int _cmp_value(const _Type& _lhs, const _Type& _rhs) {{
   return (_lhs == _rhs) ? 0 : (_lhs < _rhs) ? -1 : 1;
 }}
 )--";
-    out << fmt::format(tmpl, fmt::arg("name", name), fmt::arg("min_tag", min_tag),
-                       fmt::arg("max_tag", max_tag));
+    // out << fmt::format(tmpl, fmt::arg("name", name), fmt::arg("min_tag", min_tag),
+    //                    fmt::arg("max_tag", max_tag));
     for (const auto& op : operators) {
       out << "inline bool operator" << op << "(const " << name << "&_rhs) const {\n";
       out << "  return _cmp(*this, _rhs) " << op << " 0;\n";
@@ -601,7 +601,7 @@ void set(_Type&& _arg) {{
   get<_Tag>() = std::forward<_Type>(_arg);
 }}
 )--";
-    out << fmt::format(tmpl, fmt::arg("name", name), fmt::arg("typelist", typelist));
+    // out << fmt::format(tmpl, fmt::arg("name", name), fmt::arg("typelist", typelist));
   } else {
     AIDL_FATAL_IF(decl.GetFields().empty(), decl) << "Union '" << name << "' is empty.";
     const auto& first_field = decl.GetFields()[0];
@@ -656,8 +656,8 @@ void set(_Tp&&... _args) {{
 }}
 
 )--";
-    out << fmt::format(tmpl, fmt::arg("name", name), fmt::arg("default_name", default_name),
-                       fmt::arg("default_value", default_value));
+    // out << fmt::format(tmpl, fmt::arg("name", name), fmt::arg("default_name", default_name),
+    //                    fmt::arg("default_value", default_value));
   }
 }
 
@@ -671,38 +671,38 @@ void UnionWriter::ReadFromParcel(CodeWriter& out, const ParcelWriterContext& ctx
   const string status = "_aidl_ret_status";
 
   auto read_var = [&](const string& var, const AidlTypeSpecifier& type) {
-    out << fmt::format("{} {};\n", name_of(type, typenames), var);
-    out << fmt::format("if (({} = ", status);
+    // out << fmt::format("{} {};\n", name_of(type, typenames), var);
+    // out << fmt::format("if (({} = ", status);
     ctx.read_func(out, var, type);
-    out << fmt::format(") != {}) return {};\n", ctx.status_ok, status);
+    // out << fmt::format(") != {}) return {};\n", ctx.status_ok, status);
   };
 
-  out << fmt::format("{} {};\n", ctx.status_type, status);
+  // out << fmt::format("{} {};\n", ctx.status_type, status);
   read_var(tag, *tag_type);
-  out << fmt::format("switch (static_cast<Tag>({})) {{\n", tag);
+  // out << fmt::format("switch (static_cast<Tag>({})) {{\n", tag);
   for (const auto& variable : decl.GetFields()) {
-    out << fmt::format("case {}: {{\n", variable->GetName());
+    // out << fmt::format("case {}: {{\n", variable->GetName());
     out.Indent();
     const auto& type = variable->GetType();
     read_var(value, type);
-    out << fmt::format("if constexpr (std::is_trivially_copyable_v<{}>) {{\n",
-                       name_of(type, typenames));
+    // out << fmt::format("if constexpr (std::is_trivially_copyable_v<{}>) {{\n",
+    //                    name_of(type, typenames));
     out.Indent();
-    out << fmt::format("set<{}>({});\n", variable->GetName(), value);
+    // out << fmt::format("set<{}>({});\n", variable->GetName(), value);
     out.Dedent();
     out << "} else {\n";
     out.Indent();
     // Even when the `if constexpr` is false, the compiler runs the tidy check for the
     // next line, which doesn't make sense. Silence the check for the unreachable code.
     out << "// NOLINTNEXTLINE(performance-move-const-arg)\n";
-    out << fmt::format("set<{}>(std::move({}));\n", variable->GetName(), value);
+    // out << fmt::format("set<{}>(std::move({}));\n", variable->GetName(), value);
     out.Dedent();
     out << "}\n";
-    out << fmt::format("return {}; }}\n", ctx.status_ok);
+    // out << fmt::format("return {}; }}\n", ctx.status_ok);
     out.Dedent();
   }
   out << "}\n";
-  out << fmt::format("return {};\n", ctx.status_bad);
+  // out << fmt::format("return {};\n", ctx.status_bad);
 }
 
 void UnionWriter::WriteToParcel(CodeWriter& out, const ParcelWriterContext& ctx) const {
@@ -714,17 +714,17 @@ void UnionWriter::WriteToParcel(CodeWriter& out, const ParcelWriterContext& ctx)
   const string value = "_aidl_value";
   const string status = "_aidl_ret_status";
 
-  out << fmt::format("{} {} = ", ctx.status_type, status);
+  // out << fmt::format("{} {} = ", ctx.status_type, status);
   ctx.write_func(out, "static_cast<int32_t>(getTag())", *tag_type);
   out << ";\n";
-  out << fmt::format("if ({} != {}) return {};\n", status, ctx.status_ok, status);
+  // out << fmt::format("if ({} != {}) return {};\n", status, ctx.status_ok, status);
   out << "switch (getTag()) {\n";
   for (const auto& variable : decl.GetFields()) {
     if (variable->IsDeprecated()) {
       out << "#pragma clang diagnostic push\n";
       out << "#pragma clang diagnostic ignored \"-Wdeprecated-declarations\"\n";
     }
-    out << fmt::format("case {}: return ", variable->GetName());
+    // out << fmt::format("case {}: return ", variable->GetName());
     ctx.write_func(out, "get<" + variable->GetName() + ">()", variable->GetType());
     out << ";\n";
     if (variable->IsDeprecated()) {
diff --git a/generate_cpp.cpp b/generate_cpp.cpp
index fcbe007..b1c3e3f 100644
--- a/generate_cpp.cpp
+++ b/generate_cpp.cpp
@@ -697,12 +697,12 @@ void GenerateInterfaceSource(CodeWriter& out, const AidlInterface& interface,
   EnterNamespace(out, interface);
 
   if (auto parent = interface.GetParentType(); parent) {
-    out << fmt::format("DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_NESTED_INTERFACE({}, {}, \"{}\")\n",
-                       GetQualifiedName(*parent), ClassName(interface, ClassNames::BASE),
-                       interface.GetDescriptor());
+    // out << fmt::format("DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_NESTED_INTERFACE({}, {}, \"{}\")\n",
+    //                    GetQualifiedName(*parent), ClassName(interface, ClassNames::BASE),
+    //                    interface.GetDescriptor());
   } else {
-    out << fmt::format("DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_INTERFACE({}, \"{}\")\n",
-                       ClassName(interface, ClassNames::BASE), interface.GetDescriptor());
+    // out << fmt::format("DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_INTERFACE({}, \"{}\")\n",
+    //                    ClassName(interface, ClassNames::BASE), interface.GetDescriptor());
   }
 
   GenerateConstantDefinitions(out, interface, typenames, /*template_decl=*/"",
@@ -830,9 +830,9 @@ void GenerateServerClassDecl(CodeWriter& out, const AidlInterface& interface,
         << ";\n";
   }
   out << "explicit " << bn_name << "();\n";
-  out << fmt::format("{} onTransact(uint32_t {}, const {}& {}, {}* {}, uint32_t {}) override;\n",
-                     kAndroidStatusLiteral, kCodeVarName, kAndroidParcelLiteral, kDataVarName,
-                     kAndroidParcelLiteral, kReplyVarName, kFlagsVarName);
+  // out << fmt::format("{} onTransact(uint32_t {}, const {}& {}, {}* {}, uint32_t {}) override;\n",
+  //                    kAndroidStatusLiteral, kCodeVarName, kAndroidParcelLiteral, kDataVarName,
+  //                    kAndroidParcelLiteral, kReplyVarName, kFlagsVarName);
   if (options.Version() > 0) {
     out << "int32_t " << kGetInterfaceVersion << "();\n";
   }
@@ -1136,13 +1136,13 @@ ParcelWriterContext GetParcelWriterContext(const AidlTypenames& typenames) {
       .status_bad = kAndroidStatusBadValue,
       .read_func =
           [&](CodeWriter& out, const string& var, const AidlTypeSpecifier& type) {
-            out << fmt::format("{}->{}({})", kParcelVarName, ParcelReadMethodOf(type, typenames),
-                               ParcelReadCastOf(type, typenames, "&" + var));
+            // out << fmt::format("{}->{}({})", kParcelVarName, ParcelReadMethodOf(type, typenames),
+            //                    ParcelReadCastOf(type, typenames, "&" + var));
           },
       .write_func =
           [&](CodeWriter& out, const string& value, const AidlTypeSpecifier& type) {
-            out << fmt::format("{}->{}({})", kParcelVarName, ParcelWriteMethodOf(type, typenames),
-                               ParcelWriteCastOf(type, typenames, value));
+            // out << fmt::format("{}->{}({})", kParcelVarName, ParcelWriteMethodOf(type, typenames),
+            //                    ParcelWriteCastOf(type, typenames, value));
           },
   };
 }
diff --git a/generate_java.cpp b/generate_java.cpp
index 3f33297..f8b1c03 100644
--- a/generate_java.cpp
+++ b/generate_java.cpp
@@ -617,8 +617,8 @@ void GenerateEnumClass(CodeWriter& out, const AidlEnumDeclaration& enum_decl) {
   for (const auto& enumerator : enum_decl.GetEnumerators()) {
     out << GenerateComments(*enumerator);
     out << GenerateAnnotations(*enumerator);
-    out << fmt::format("public static final {} {} = {};\n", raw_type, enumerator->GetName(),
-                       enumerator->ValueString(backing_type, ConstantValueDecorator));
+    // out << fmt::format("public static final {} {} = {};\n", raw_type, enumerator->GetName(),
+    //                    enumerator->ValueString(backing_type, ConstantValueDecorator));
   }
   if (enum_decl.JavaDerive("toString")) {
     out << "interface $ {\n";
@@ -632,26 +632,26 @@ void GenerateEnumClass(CodeWriter& out, const AidlEnumDeclaration& enum_decl) {
     out << "return " << boxing_type << ".toString(_aidl_v);\n";
     out.Dedent();
     out << "}\n";
-    out << fmt::format(R"(static String arrayToString(Object _aidl_v) {{
-  if (_aidl_v == null) return "null";
-  Class<?> _aidl_cls = _aidl_v.getClass();
-  if (!_aidl_cls.isArray()) throw new IllegalArgumentException("not an array: " + _aidl_v);
-  Class<?> comp = _aidl_cls.getComponentType();
-  java.util.StringJoiner _aidl_sj = new java.util.StringJoiner(", ", "[", "]");
-  if (comp.isArray()) {{
-    for (int _aidl_i = 0; _aidl_i < java.lang.reflect.Array.getLength(_aidl_v); _aidl_i++) {{
-      _aidl_sj.add(arrayToString(java.lang.reflect.Array.get(_aidl_v, _aidl_i)));
-    }}
-  }} else {{
-    if (_aidl_cls != {raw_type}[].class) throw new IllegalArgumentException("wrong type: " + _aidl_cls);
-    for ({raw_type} e : ({raw_type}[]) _aidl_v) {{
-      _aidl_sj.add(toString(e));
-    }}
-  }}
-  return _aidl_sj.toString();
-}}
-)",
-                       fmt::arg("raw_type", raw_type));
+//     out << fmt::format(R"(static String arrayToString(Object _aidl_v) {{
+//   if (_aidl_v == null) return "null";
+//   Class<?> _aidl_cls = _aidl_v.getClass();
+//   if (!_aidl_cls.isArray()) throw new IllegalArgumentException("not an array: " + _aidl_v);
+//   Class<?> comp = _aidl_cls.getComponentType();
+//   java.util.StringJoiner _aidl_sj = new java.util.StringJoiner(", ", "[", "]");
+//   if (comp.isArray()) {{
+//     for (int _aidl_i = 0; _aidl_i < java.lang.reflect.Array.getLength(_aidl_v); _aidl_i++) {{
+//       _aidl_sj.add(arrayToString(java.lang.reflect.Array.get(_aidl_v, _aidl_i)));
+//     }}
+//   }} else {{
+//     if (_aidl_cls != {raw_type}[].class) throw new IllegalArgumentException("wrong type: " + _aidl_cls);
+//     for ({raw_type} e : ({raw_type}[]) _aidl_v) {{
+//       _aidl_sj.add(toString(e));
+//     }}
+//   }}
+//   return _aidl_sj.toString();
+// }}
+// )",
+//                        fmt::arg("raw_type", raw_type));
     out.Dedent();
     out << "}\n";
   }
diff --git a/logging.h b/logging.h
index f2150c2..6b18712 100644
--- a/logging.h
+++ b/logging.h
@@ -18,6 +18,7 @@
 
 #include <iostream>
 #include <string>
+#include <memory>
 
 #include "location.h"
 
diff --git a/options.cpp b/options.cpp
index 924f1ee..298a52a 100644
--- a/options.cpp
+++ b/options.cpp
@@ -206,12 +206,12 @@ static const std::map<std::string, uint32_t> codeNameToVersion = {
 
 Result<uint32_t> MinSdkVersionFromString(const std::string& str) {
   uint32_t num;
-  if (!android::base::ParseUint(str, &num, 10000u /* max */)) {
-    if (auto found = codeNameToVersion.find(str); found != codeNameToVersion.end()) {
-      return found->second;
-    }
-    return Errorf("Invalid SDK version: {}", str);
-  }
+  // if (!android::base::ParseUint(str, &num, 10000u /* max */)) {
+  //   if (auto found = codeNameToVersion.find(str); found != codeNameToVersion.end()) {
+  //     return found->second;
+  //   }
+  //   return Errorf("Invalid SDK version: {}", str);
+  // }
   return num;
 }
 
