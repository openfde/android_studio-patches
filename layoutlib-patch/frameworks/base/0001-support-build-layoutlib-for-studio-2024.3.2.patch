From d6b8bea8d5599ecb374d744f85cc695aba8c56d5 Mon Sep 17 00:00:00 2001
From: pengcui <pngcui1224@163.com>
Date: Mon, 1 Sep 2025 11:13:01 +0800
Subject: [PATCH] support build layoutlib for studio-2024.3.2

---
 core/java/android/app/ContextImpl.java        |    8 +
 core/java/android/content/Context.java        |   14 +
 core/java/android/content/ContextWrapper.java |    8 +
 core/java/android/os/Build.java               |   18 +-
 core/java/android/view/WindowManager.java     |    2 +
 core/java/android/view/WindowManagerImpl.java |    5 +
 core/java/android/widget/TextView.java        |   16 +
 core/jni/Android.bp                           |   28 +-
 core/jni/AndroidRuntime.cpp                   | 1406 ++---------------
 core/jni/LayoutlibLoader.cpp                  |   10 +-
 core/jni/android_text_Hyphenator.cpp          |   41 +-
 core/jni/android_view_LayoutlibRenderer.cpp   |  199 +++
 core/jni/android_view_Surface.cpp             |   37 +
 .../include/android_runtime/AndroidRuntime.h  |    1 +
 libs/hostgraphics/ANativeWindow.cpp           |  107 ++
 libs/hostgraphics/Android.bp                  |   26 +-
 libs/hostgraphics/HostBufferQueue.cpp         |   24 +
 .../hostgraphics/gui/IGraphicBufferProducer.h |    9 +-
 libs/hostgraphics/gui/Surface.h               |   57 +-
 libs/hostgraphics/ui/GraphicBuffer.h          |    9 +-
 libs/hwui/Android.bp                          |   47 +-
 libs/hwui/RootRenderNode.cpp                  |   21 +-
 libs/hwui/RootRenderNode.h                    |    2 -
 libs/hwui/apex/android_bitmap.cpp             |    4 +
 libs/hwui/apex/android_canvas.cpp             |    2 +
 .../jni/android_graphics_HardwareRenderer.cpp |   74 +-
 libs/hwui/pipeline/skia/SkiaHostPipeline.cpp  |  102 ++
 libs/hwui/pipeline/skia/SkiaHostPipeline.h    |   55 +
 libs/hwui/pipeline/skia/SkiaPipeline.cpp      |   36 +-
 libs/hwui/pipeline/skia/SkiaPipeline.h        |    8 +-
 libs/hwui/renderthread/CanvasContext.cpp      |   95 +-
 libs/hwui/renderthread/CanvasContext.h        |   18 +-
 libs/hwui/renderthread/DrawFrameTask.cpp      |   19 +-
 libs/hwui/renderthread/DrawFrameTask.h        |    4 +
 libs/hwui/renderthread/IRenderPipeline.h      |    7 +-
 libs/hwui/renderthread/ReliableSurface.cpp    |   18 +
 libs/hwui/renderthread/ReliableSurface.h      |    4 +
 libs/hwui/renderthread/RenderProxy.cpp        |   66 +-
 libs/hwui/utils/HostColorSpace.cpp            |  417 +++++
 39 files changed, 1694 insertions(+), 1330 deletions(-)
 create mode 100755 core/jni/android_view_LayoutlibRenderer.cpp
 create mode 100755 libs/hostgraphics/ANativeWindow.cpp
 create mode 100755 libs/hwui/pipeline/skia/SkiaHostPipeline.cpp
 create mode 100755 libs/hwui/pipeline/skia/SkiaHostPipeline.h
 create mode 100755 libs/hwui/utils/HostColorSpace.cpp

diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index e4beb885ca61..48fbec2e04e6 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -1557,6 +1557,14 @@ class ContextImpl extends Context {
         }
     }
 
+    @Override
+    public void sendOrderedBroadcastAsUserMultiplePermissions(Intent intent, UserHandle user,
+            String[] receiverPermissions, int appOp, Bundle options,
+            BroadcastReceiver resultReceiver, Handler scheduler, int initialCode,
+            String initialData, Bundle initialExtras) {
+        sendOrderedBroadcastAsUser(intent, user, receiverPermissions[0], appOp, options, resultReceiver, scheduler, initialCode, initialData, initialExtras);
+    }
+
     @Override
     public void sendOrderedBroadcast(Intent intent, String receiverPermission,
             String receiverAppOp, BroadcastReceiver resultReceiver, Handler scheduler,
diff --git a/core/java/android/content/Context.java b/core/java/android/content/Context.java
index c7e5d88c299d..58df478217a0 100644
--- a/core/java/android/content/Context.java
+++ b/core/java/android/content/Context.java
@@ -2915,6 +2915,20 @@ public abstract class Context {
             BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode,
             @Nullable String initialData, @Nullable  Bundle initialExtras);
 
+    /**
+     * Similar to above but takes an appOp as well, to enforce restrictions, and an options Bundle.
+     * @see #sendOrderedBroadcastAsUser(Intent, UserHandle, String,
+     *       BroadcastReceiver, Handler, int, String, Bundle)
+     * @hide
+     */
+    @SuppressWarnings("HiddenAbstractMethod")
+    @RequiresPermission(android.Manifest.permission.INTERACT_ACROSS_USERS)
+    @UnsupportedAppUsage
+    public abstract void sendOrderedBroadcastAsUserMultiplePermissions(Intent intent, UserHandle user,
+            @Nullable String[] receiverPermission, int appOp, @Nullable Bundle options,
+            BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode,
+            @Nullable String initialData, @Nullable  Bundle initialExtras);
+
     /**
      * Version of
      * {@link #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String,
diff --git a/core/java/android/content/ContextWrapper.java b/core/java/android/content/ContextWrapper.java
index e0cf0a5f8178..303f55b574ff 100644
--- a/core/java/android/content/ContextWrapper.java
+++ b/core/java/android/content/ContextWrapper.java
@@ -652,6 +652,14 @@ public class ContextWrapper extends Context {
                 resultReceiver, scheduler, initialCode, initialData, initialExtras);
     }
 
+    @Override
+    public void sendOrderedBroadcastAsUserMultiplePermissions(Intent intent, UserHandle user,
+            String[] receiverPermissions, int appOp, Bundle options,
+            BroadcastReceiver resultReceiver, Handler scheduler, int initialCode,
+            String initialData, Bundle initialExtras) {
+        mBase.sendOrderedBroadcastAsUser(intent, user, receiverPermissions[0], appOp, options, resultReceiver, scheduler, initialCode, initialData, initialExtras);
+    }
+
     @Override
     public void sendOrderedBroadcast(@RequiresPermission @NonNull Intent intent,
             @Nullable String receiverPermission, @Nullable String receiverAppOp,
diff --git a/core/java/android/os/Build.java b/core/java/android/os/Build.java
index 3977bdf413d9..c3977d0fcced 100755
--- a/core/java/android/os/Build.java
+++ b/core/java/android/os/Build.java
@@ -284,8 +284,8 @@ public class Build {
      *
      * See {@link #SUPPORTED_ABIS} and {@link #SUPPORTED_64_BIT_ABIS}.
      */
-    public static final String[] SUPPORTED_32_BIT_ABIS =
-            getStringList("ro.product.cpu.abilist32", ",");
+    public static final String[] SUPPORTED_32_BIT_ABIS = {"armeabi-v7a","armeabi"};
+            // getStringList("ro.product.cpu.abilist32", ",");
 
     /**
      * An ordered list of <b>64 bit</b> ABIs supported by this device. The most preferred ABI
@@ -293,8 +293,8 @@ public class Build {
      *
      * See {@link #SUPPORTED_ABIS} and {@link #SUPPORTED_32_BIT_ABIS}.
      */
-    public static final String[] SUPPORTED_64_BIT_ABIS =
-            getStringList("ro.product.cpu.abilist64", ",");
+    public static final String[] SUPPORTED_64_BIT_ABIS = {"arm64-v8a"};
+            // getStringList("ro.product.cpu.abilist64", ",");
 
     /** {@hide} */
     @TestApi
@@ -396,8 +396,8 @@ public class Build {
          * <p>
          * Possible values are defined in {@link Build.VERSION_CODES}.
          */
-        public static final int SDK_INT = SystemProperties.getInt(
-                "ro.build.version.sdk", 0);
+        public static final int SDK_INT = 33;//SystemProperties.getInt(
+                // "ro.build.version.sdk", 0);
 
         /**
          * The SDK version of the software that <em>initially</em> shipped on
@@ -486,8 +486,8 @@ public class Build {
          */
         @UnsupportedAppUsage
         @TestApi
-        public static final String[] ACTIVE_CODENAMES = "REL".equals(ALL_CODENAMES[0])
-                ? new String[0] : ALL_CODENAMES;
+        public static final String[] ACTIVE_CODENAMES = new String[0];//"REL".equals(ALL_CODENAMES[0])
+                // ? new String[0] : ALL_CODENAMES;
 
         /**
          * The SDK version to use when accessing resources.
@@ -496,7 +496,7 @@ public class Build {
          * @hide
          */
         @TestApi
-        public static final int RESOURCES_SDK_INT = SDK_INT + ACTIVE_CODENAMES.length;
+        public static final int RESOURCES_SDK_INT = SDK_INT;// + ACTIVE_CODENAMES.length;
 
         /**
          * The current lowest supported value of app target SDK. Applications targeting
diff --git a/core/java/android/view/WindowManager.java b/core/java/android/view/WindowManager.java
index d5cb4700a037..7fc54b0c7549 100644
--- a/core/java/android/view/WindowManager.java
+++ b/core/java/android/view/WindowManager.java
@@ -771,6 +771,8 @@ public interface WindowManager extends ViewManager {
      */
     public void removeViewImmediate(View view);
 
+    public KeyboardShortcutGroup getApplicationLaunchKeyboardShortcuts(int deviceId);
+
     /**
      * Returns the {@link WindowMetrics} according to the current system state.
      * <p>
diff --git a/core/java/android/view/WindowManagerImpl.java b/core/java/android/view/WindowManagerImpl.java
index 460935282c38..9c0b010d9cbe 100644
--- a/core/java/android/view/WindowManagerImpl.java
+++ b/core/java/android/view/WindowManagerImpl.java
@@ -230,6 +230,11 @@ public final class WindowManagerImpl implements WindowManager {
         mGlobal.removeView(view, true);
     }
 
+    @Override
+    public KeyboardShortcutGroup getApplicationLaunchKeyboardShortcuts(int deviceId) {
+        return new KeyboardShortcutGroup("", new ArrayList<>());
+    }
+
     @Override
     public void requestAppKeyboardShortcuts(
             final KeyboardShortcutsReceiver receiver, int deviceId) {
diff --git a/core/java/android/widget/TextView.java b/core/java/android/widget/TextView.java
index 92dcf88490cb..d85d0a12ec7f 100644
--- a/core/java/android/widget/TextView.java
+++ b/core/java/android/widget/TextView.java
@@ -11090,6 +11090,22 @@ public class TextView extends View implements ViewTreeObserver.OnPreDrawListener
                                 mShiftDrawingOffsetForStartOverhang,
                                 getResolvedMinimumFontMetrics());
                     }
+                } else {
+                    result = new BoringLayout(
+                                mTransformed,
+                                mTextPaint,
+                                wantWidth,
+                                alignment,
+                                mSpacingMult,
+                                mSpacingAdd,
+                                mIncludePad,
+                                isFallbackLineSpacingForBoringLayout(),
+                                wantWidth,
+                                null,
+                                boring,
+                                mUseBoundsForWidth,
+                                mShiftDrawingOffsetForStartOverhang,
+                                getResolvedMinimumFontMetrics());
                 }
             }
         }
diff --git a/core/jni/Android.bp b/core/jni/Android.bp
index 76e71380017c..a6adb9967d17 100644
--- a/core/jni/Android.bp
+++ b/core/jni/Android.bp
@@ -381,6 +381,12 @@ cc_library_shared_for_libandroid_runtime {
             cflags: [
                 "-Wno-unused-const-variable",
                 "-Wno-unused-function",
+                "-DLOG_ALWAYS_FATAL_IF(cond, ...)=if(cond) LOG_ALWAYS_FATAL(...)",
+                "-DLOG_ALWAYS_FATAL(...)=__android_log_call_aborter(\"Fatal Error\")",
+                // Use all declarations in native_window.h in Layoutlib
+                "-D__INTRODUCED_IN(n)=",
+                "-D__ANDROID_API__=10000",
+                "-D__HOST_JVM__",
             ],
             srcs: [
                 "LayoutlibLoader.cpp",
@@ -420,6 +426,7 @@ cc_library_shared_for_libandroid_runtime {
         },
         host_linux: {
             srcs: [
+                "AndroidRuntime.cpp",
                 "android_content_res_ApkAssets.cpp",
                 "android_database_CursorWindow.cpp",
                 "android_database_SQLiteCommon.cpp",
@@ -429,7 +436,7 @@ cc_library_shared_for_libandroid_runtime {
                 "android_hardware_input_InputApplicationHandle.cpp",
                 "android_os_MessageQueue.cpp",
                 "android_os_Parcel.cpp",
-
+                "android_view_Surface.cpp",
                 "android_view_KeyCharacterMap.cpp",
                 "android_view_KeyEvent.cpp",
                 "android_view_InputChannel.cpp",
@@ -440,17 +447,19 @@ cc_library_shared_for_libandroid_runtime {
                 "android_view_VelocityTracker.cpp",
                 "android_view_VerifiedKeyEvent.cpp",
                 "android_view_VerifiedMotionEvent.cpp",
-
+                "android_view_LayoutlibRenderer.cpp",
                 "android_util_AssetManager.cpp",
                 "android_util_Binder.cpp",
-
                 "android_util_FileObserver.cpp",
+                "android_text_Hyphenator.cpp",
             ],
             static_libs: [
                 "libinput",
                 "libbinderthreadstateutils",
                 "libsqlite",
                 "libgui_window_info_static",
+                "libhwui",
+                "libhostgraphics",
             ],
             shared_libs: [
                 // libbinder needs to be shared since it has global state
@@ -458,6 +467,19 @@ cc_library_shared_for_libandroid_runtime {
                 "libbinder",
                 "libhidlbase", // libhwbinder is in here
             ],
+            header_libs: [
+                "libbinder_headers",
+                "jni_headers",
+                "libnativehelper_header_only",
+                "libnativehelper_include_only",
+                "libbase_headers",
+                "libnativebase_headers",
+                "libnativedisplay_headers",
+                "libnativewindow_headers",
+                "libhostgraphics_headers",
+                "libmath_headers",
+                "android_graphics_apex_headers",
+            ],
         },
     },
 }
diff --git a/core/jni/AndroidRuntime.cpp b/core/jni/AndroidRuntime.cpp
index aa63f4fa03d4..43411647d2f2 100644
--- a/core/jni/AndroidRuntime.cpp
+++ b/core/jni/AndroidRuntime.cpp
@@ -28,7 +28,7 @@
 #include <binder/IPCThreadState.h>
 #include <binder/IServiceManager.h>
 #include <binder/Parcel.h>
-#include <bionic/malloc.h>
+#include <malloc.h>
 #include <cutils/properties.h>
 #include <dirent.h>
 #include <dlfcn.h>
@@ -50,60 +50,38 @@
 #include "android_util_Binder.h"
 #include "jni.h"
 
+#include "android_view_InputDevice.h"
+#include "core_jni_helpers.h"
+
+#include <fcntl.h>
+#include <sys/mman.h>
+
+
+#include <iostream>
+
 using namespace android;
 using android::base::GetBoolProperty;
 using android::base::GetProperty;
 using android::base::ParseBool;
 using android::base::ParseBoolResult;
 
+static JNIEnv* mJniEnv;
+
 extern int register_android_os_Binder(JNIEnv* env);
-extern int register_android_os_Process(JNIEnv* env);
-extern int register_android_graphics_GraphicBuffer(JNIEnv* env);
-
-extern int register_com_google_android_gles_jni_EGLImpl(JNIEnv* env);
-extern int register_com_google_android_gles_jni_GLImpl(JNIEnv* env);
-extern int register_android_opengl_jni_EGL14(JNIEnv* env);
-extern int register_android_opengl_jni_EGL15(JNIEnv* env);
-extern int register_android_opengl_jni_EGLExt(JNIEnv* env);
-extern int register_android_opengl_jni_GLES10(JNIEnv* env);
-extern int register_android_opengl_jni_GLES10Ext(JNIEnv* env);
-extern int register_android_opengl_jni_GLES11(JNIEnv* env);
-extern int register_android_opengl_jni_GLES11Ext(JNIEnv* env);
-extern int register_android_opengl_jni_GLES20(JNIEnv* env);
-extern int register_android_opengl_jni_GLES30(JNIEnv* env);
-extern int register_android_opengl_jni_GLES31(JNIEnv* env);
-extern int register_android_opengl_jni_GLES31Ext(JNIEnv* env);
-extern int register_android_opengl_jni_GLES32(JNIEnv* env);
-
-extern int register_android_hardware_Camera(JNIEnv *env);
-extern int register_android_hardware_camera2_CameraMetadata(JNIEnv *env);
-extern int register_android_hardware_camera2_DngCreator(JNIEnv *env);
-extern int register_android_hardware_camera2_impl_CameraExtensionJpegProcessor(JNIEnv* env);
-extern int register_android_hardware_camera2_utils_SurfaceUtils(JNIEnv* env);
-extern int register_android_hardware_display_DisplayManagerGlobal(JNIEnv* env);
-extern int register_android_hardware_HardwareBuffer(JNIEnv *env);
-extern int register_android_hardware_OverlayProperties(JNIEnv* env);
-extern int register_android_hardware_SensorManager(JNIEnv *env);
-extern int register_android_hardware_SerialPort(JNIEnv *env);
-extern int register_android_hardware_SyncFence(JNIEnv* env);
-extern int register_android_hardware_UsbDevice(JNIEnv *env);
-extern int register_android_hardware_UsbDeviceConnection(JNIEnv *env);
-extern int register_android_hardware_UsbRequest(JNIEnv *env);
-extern int register_android_hardware_location_ActivityRecognitionHardware(JNIEnv* env);
-
-extern int register_android_media_AudioDeviceAttributes(JNIEnv* env);
-extern int register_android_media_AudioEffectDescriptor(JNIEnv *env);
-extern int register_android_media_AudioRecord(JNIEnv *env);
-extern int register_android_media_AudioSystem(JNIEnv *env);
-extern int register_android_media_AudioTrack(JNIEnv *env);
-extern int register_android_media_AudioAttributes(JNIEnv *env);
-extern int register_android_media_AudioProductStrategies(JNIEnv *env);
-extern int register_android_media_AudioVolumeGroups(JNIEnv *env);
-extern int register_android_media_AudioVolumeGroupChangeHandler(JNIEnv *env);
-extern int register_android_media_MicrophoneInfo(JNIEnv *env);
-extern int register_android_media_ToneGenerator(JNIEnv *env);
-extern int register_android_media_audio_common_AidlConversion(JNIEnv* env);
-extern int register_android_media_midi(JNIEnv *env);
+
+extern int register_android_graphics_Bitmap(JNIEnv*);
+extern int register_android_graphics_BitmapFactory(JNIEnv*);
+extern int register_android_graphics_ByteBufferStreamAdaptor(JNIEnv* env);
+extern int register_android_graphics_CreateJavaOutputStreamAdaptor(JNIEnv* env);
+extern int register_android_graphics_Graphics(JNIEnv* env);
+extern int register_android_graphics_ImageDecoder(JNIEnv*);
+extern int register_android_graphics_Interpolator(JNIEnv* env);
+extern int register_android_graphics_MaskFilter(JNIEnv* env);
+extern int register_android_graphics_NinePatch(JNIEnv*);
+extern int register_android_graphics_PathEffect(JNIEnv* env);
+extern int register_android_graphics_Shader(JNIEnv* env);
+extern int register_android_graphics_RenderEffect(JNIEnv* env);
+extern int register_android_graphics_Typeface(JNIEnv* env);
 
 namespace android {
 
@@ -111,116 +89,88 @@ namespace android {
  * JNI-based registration functions.  Note these are properly contained in
  * namespace android.
  */
-extern int register_android_app_admin_SecurityLog(JNIEnv* env);
 extern int register_android_content_AssetManager(JNIEnv* env);
-extern int register_android_util_CharsetUtils(JNIEnv* env);
 extern int register_android_util_EventLog(JNIEnv* env);
 extern int register_android_util_Log(JNIEnv* env);
-extern int register_android_util_MemoryIntArray(JNIEnv* env);
 extern int register_android_content_StringBlock(JNIEnv* env);
 extern int register_android_content_XmlBlock(JNIEnv* env);
 extern int register_android_content_res_ApkAssets(JNIEnv* env);
-extern int register_android_content_res_ResourceTimer(JNIEnv* env);
-extern int register_android_graphics_BLASTBufferQueue(JNIEnv* env);
-extern int register_android_graphics_SurfaceTexture(JNIEnv* env);
-extern int register_android_view_DisplayEventReceiver(JNIEnv* env);
-extern int register_android_view_InputApplicationHandle(JNIEnv* env);
-extern int register_android_view_InputWindowHandle(JNIEnv* env);
-extern int register_android_view_Surface(JNIEnv* env);
-extern int register_android_view_SurfaceControl(JNIEnv* env);
-extern int register_android_view_SurfaceControlHdrLayerInfoListener(JNIEnv* env);
-extern int register_android_view_SurfaceSession(JNIEnv* env);
-extern int register_android_view_CompositionSamplingListener(JNIEnv* env);
-extern int register_android_view_TextureView(JNIEnv* env);
-extern int register_android_view_TunnelModeEnabledListener(JNIEnv* env);
 extern int register_android_database_CursorWindow(JNIEnv* env);
 extern int register_android_database_SQLiteConnection(JNIEnv* env);
 extern int register_android_database_SQLiteGlobal(JNIEnv* env);
 extern int register_android_database_SQLiteDebug(JNIEnv* env);
-extern int register_android_database_SQLiteRawStatement(JNIEnv* env);
-extern int register_android_media_MediaMetrics(JNIEnv *env);
-extern int register_android_os_Debug(JNIEnv* env);
-extern int register_android_os_GraphicsEnvironment(JNIEnv* env);
-extern int register_android_os_HidlSupport(JNIEnv* env);
-extern int register_android_os_HwBinder(JNIEnv *env);
-extern int register_android_os_HwBlob(JNIEnv *env);
-extern int register_android_os_HwParcel(JNIEnv *env);
-extern int register_android_os_HwRemoteBinder(JNIEnv *env);
-extern int register_android_os_NativeHandle(JNIEnv *env);
-extern int register_android_os_ServiceManager(JNIEnv *env);
 extern int register_android_os_MessageQueue(JNIEnv* env);
 extern int register_android_os_Parcel(JNIEnv* env);
-extern int register_android_os_PerformanceHintManager(JNIEnv* env);
-extern int register_android_os_SELinux(JNIEnv* env);
-extern int register_android_os_storage_StorageManager(JNIEnv* env);
 extern int register_android_os_SystemProperties(JNIEnv *env);
 extern int register_android_os_SystemClock(JNIEnv* env);
 extern int register_android_os_Trace(JNIEnv* env);
 extern int register_android_os_FileObserver(JNIEnv *env);
-extern int register_android_os_UEventObserver(JNIEnv* env);
-extern int register_android_os_HidlMemory(JNIEnv* env);
-extern int register_android_os_MemoryFile(JNIEnv* env);
-extern int register_android_os_SharedMemory(JNIEnv* env);
-extern int register_android_service_DataLoaderService(JNIEnv* env);
-extern int register_android_os_incremental_IncrementalManager(JNIEnv* env);
-extern int register_android_net_LocalSocketImpl(JNIEnv* env);
 extern int register_android_text_AndroidCharacter(JNIEnv *env);
-extern int register_android_text_Hyphenator(JNIEnv *env);
-extern int register_android_opengl_classes(JNIEnv *env);
-extern int register_android_ddm_DdmHandleNativeHeap(JNIEnv *env);
-extern int register_android_backup_BackupDataInput(JNIEnv *env);
-extern int register_android_backup_BackupDataOutput(JNIEnv *env);
-extern int register_android_backup_FileBackupHelperBase(JNIEnv *env);
-extern int register_android_backup_BackupHelperDispatcher(JNIEnv *env);
-extern int register_android_app_backup_FullBackup(JNIEnv *env);
-extern int register_android_app_Activity(JNIEnv *env);
-extern int register_android_app_ActivityThread(JNIEnv *env);
-extern int register_android_app_NativeActivity(JNIEnv *env);
-extern int register_android_media_RemoteDisplay(JNIEnv *env);
 extern int register_android_util_jar_StrictJarFile(JNIEnv* env);
-extern int register_android_view_InputChannel(JNIEnv* env);
 extern int register_android_view_InputDevice(JNIEnv* env);
-extern int register_android_view_InputEventReceiver(JNIEnv* env);
-extern int register_android_view_InputEventSender(JNIEnv* env);
-extern int register_android_view_InputQueue(JNIEnv* env);
 extern int register_android_view_KeyCharacterMap(JNIEnv *env);
 extern int register_android_view_KeyEvent(JNIEnv* env);
 extern int register_android_view_MotionEvent(JNIEnv* env);
-extern int register_android_view_MotionPredictor(JNIEnv* env);
-extern int register_android_view_PointerIcon(JNIEnv* env);
 extern int register_android_view_VelocityTracker(JNIEnv* env);
-extern int register_android_view_VerifiedKeyEvent(JNIEnv* env);
-extern int register_android_view_VerifiedMotionEvent(JNIEnv* env);
-extern int register_android_content_res_ObbScanner(JNIEnv* env);
-extern int register_android_content_res_Configuration(JNIEnv* env);
+extern int register_android_view_ThreadedRenderer(JNIEnv* env);
+extern int register_android_graphics_HardwareBufferRenderer(JNIEnv* env);
 extern int register_android_animation_PropertyValuesHolder(JNIEnv *env);
-extern int register_android_security_Scrypt(JNIEnv *env);
-extern int register_com_android_internal_content_F2fsUtils(JNIEnv* env);
-extern int register_com_android_internal_content_NativeLibraryHelper(JNIEnv *env);
-extern int register_com_android_internal_content_om_OverlayConfig(JNIEnv *env);
-extern int register_com_android_internal_content_om_OverlayManagerImpl(JNIEnv* env);
-extern int register_com_android_internal_net_NetworkUtilsInternal(JNIEnv* env);
-extern int register_com_android_internal_os_ClassLoaderFactory(JNIEnv* env);
-extern int register_com_android_internal_os_FuseAppLoop(JNIEnv* env);
-extern int register_com_android_internal_os_KernelAllocationStats(JNIEnv* env);
-extern int register_com_android_internal_os_KernelCpuBpfTracking(JNIEnv* env);
-extern int register_com_android_internal_os_KernelCpuTotalBpfMapReader(JNIEnv* env);
-extern int register_com_android_internal_os_KernelCpuUidBpfMapReader(JNIEnv *env);
-extern int register_com_android_internal_os_KernelSingleProcessCpuThreadReader(JNIEnv* env);
-extern int register_com_android_internal_os_KernelSingleUidTimeReader(JNIEnv *env);
-extern int register_com_android_internal_os_LongArrayMultiStateCounter(JNIEnv* env);
-extern int register_com_android_internal_os_LongMultiStateCounter(JNIEnv* env);
-extern int register_com_android_internal_os_Zygote(JNIEnv *env);
-extern int register_com_android_internal_os_ZygoteCommandBuffer(JNIEnv *env);
-extern int register_com_android_internal_os_ZygoteInit(JNIEnv *env);
-extern int register_com_android_internal_security_VerityUtils(JNIEnv* env);
 extern int register_com_android_internal_util_VirtualRefBasePtr(JNIEnv *env);
-extern int register_android_window_WindowInfosListener(JNIEnv* env);
-extern int register_android_window_ScreenCapture(JNIEnv* env);
-extern int register_jni_common(JNIEnv* env);
-extern int register_android_tracing_PerfettoDataSource(JNIEnv* env);
-extern int register_android_tracing_PerfettoDataSourceInstance(JNIEnv* env);
-extern int register_android_tracing_PerfettoProducer(JNIEnv* env);
+extern int register_android_graphics_Region(JNIEnv *env);
+extern int register_android_view_LayoutlibRenderer(JNIEnv *env);
+extern int register_android_view_Surface(JNIEnv *env);
+
+extern int register_android_graphics_Canvas(JNIEnv* env);
+extern int register_android_graphics_ColorFilter(JNIEnv* env);
+extern int register_android_graphics_ColorSpace(JNIEnv* env);
+extern int register_android_graphics_DrawFilter(JNIEnv* env);
+extern int register_android_graphics_FontFamily(JNIEnv* env);
+extern int register_android_graphics_Matrix(JNIEnv* env);
+extern int register_android_graphics_Paint(JNIEnv* env);
+extern int register_android_graphics_Path(JNIEnv* env);
+extern int register_android_graphics_PathMeasure(JNIEnv* env);
+extern int register_android_graphics_Picture(JNIEnv* env);
+//extern int register_android_graphics_Region(JNIEnv* env);
+extern int register_android_graphics_animation_NativeInterpolatorFactory(JNIEnv* env);
+extern int register_android_graphics_animation_RenderNodeAnimator(JNIEnv* env);
+extern int register_android_graphics_drawable_AnimatedVectorDrawable(JNIEnv* env);
+extern int register_android_graphics_drawable_VectorDrawable(JNIEnv* env);
+extern int register_android_graphics_fonts_Font(JNIEnv* env);
+extern int register_android_graphics_fonts_FontFamily(JNIEnv* env);
+extern int register_android_graphics_text_LineBreaker(JNIEnv* env);
+extern int register_android_graphics_text_MeasuredText(JNIEnv* env);
+extern int register_android_util_PathParser(JNIEnv* env);
+extern int register_android_view_RenderNode(JNIEnv* env);
+extern int register_android_view_DisplayListCanvas(JNIEnv* env);
+extern int register_android_graphics_text_TextShaper(JNIEnv* env);
+extern int register_android_text_Hyphenator(JNIEnv* env);
+
+//
+
+#if 0
+extern int register_libcore_util_NativeAllocationRegistry_Delegate(JNIEnv *env);
+
+
+typedef void (*FreeFunction)(void*);
+
+static void NativeAllocationRegistry_Delegate_nativeApplyFreeFunction(JNIEnv*, jclass,
+                                                                      jlong freeFunction,
+                                                                      jlong ptr) {
+    void* nativePtr = reinterpret_cast<void*>(static_cast<uintptr_t>(ptr));
+    FreeFunction nativeFreeFunction =
+            reinterpret_cast<FreeFunction>(static_cast<uintptr_t>(freeFunction));
+    nativeFreeFunction(nativePtr);
+}
+
+static JNINativeMethod gMethods[] = {
+        NATIVE_METHOD(NativeAllocationRegistry_Delegate, nativeApplyFreeFunction, "(JJ)V"),
+};
+
+int register_libcore_util_NativeAllocationRegistry_Delegate(JNIEnv* env) {
+    return jniRegisterNativeMethods(env, "libcore/util/NativeAllocationRegistry_Delegate", gMethods,
+                                    NELEM(gMethods));
+}
+#endif
 
 // Namespace for Android Runtime flags applied during boot time.
 static const char* RUNTIME_NATIVE_BOOT_NAMESPACE = "runtime_native_boot";
@@ -250,51 +200,6 @@ static const char* kLockProfThresholdRuntimeOption = "-Xlockprofthreshold:0";
 
 static AndroidRuntime* gCurRuntime = NULL;
 
-/*
- * Code written in the Java Programming Language calls here from main().
- */
-static void com_android_internal_os_RuntimeInit_nativeFinishInit(JNIEnv* env, jobject clazz)
-{
-    gCurRuntime->onStarted();
-}
-
-static void com_android_internal_os_ZygoteInit_nativeZygoteInit(JNIEnv* env, jobject clazz)
-{
-    gCurRuntime->onZygoteInit();
-}
-
-static void com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup(JNIEnv* env,
-        jobject clazz, jboolean exitWithoutCleanup)
-{
-    gCurRuntime->setExitWithoutCleanup(exitWithoutCleanup);
-}
-
-/*
- * JNI registration.
- */
-
-int register_com_android_internal_os_RuntimeInit(JNIEnv* env)
-{
-    const JNINativeMethod methods[] = {
-            {"nativeFinishInit", "()V",
-             (void*)com_android_internal_os_RuntimeInit_nativeFinishInit},
-            {"nativeSetExitWithoutCleanup", "(Z)V",
-             (void*)com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup},
-    };
-    return jniRegisterNativeMethods(env, "com/android/internal/os/RuntimeInit",
-        methods, NELEM(methods));
-}
-
-int register_com_android_internal_os_ZygoteInit_nativeZygoteInit(JNIEnv* env)
-{
-    const JNINativeMethod methods[] = {
-        { "nativeZygoteInit", "()V",
-            (void*) com_android_internal_os_ZygoteInit_nativeZygoteInit },
-    };
-    return jniRegisterNativeMethods(env, "com/android/internal/os/ZygoteInit",
-        methods, NELEM(methods));
-}
-
 // ----------------------------------------------------------------------
 
 /*static*/ JavaVM* AndroidRuntime::mJavaVM = NULL;
@@ -304,10 +209,10 @@ AndroidRuntime::AndroidRuntime(char* argBlockStart, const size_t argBlockLength)
         mArgBlockStart(argBlockStart),
         mArgBlockLength(argBlockLength)
 {
-    init_android_graphics();
+    // init_android_graphics();
 
     // Pre-allocate enough space to hold a fair number of options.
-    mOptions.setCapacity(20);
+    // mOptions.setCapacity(20);
 
     assert(gCurRuntime == NULL);        // one per process
     gCurRuntime = this;
@@ -317,75 +222,6 @@ AndroidRuntime::~AndroidRuntime()
 {
 }
 
-/*
- * Register native methods using JNI.
- */
-/*static*/ int AndroidRuntime::registerNativeMethods(JNIEnv* env,
-    const char* className, const JNINativeMethod* gMethods, int numMethods)
-{
-    return jniRegisterNativeMethods(env, className, gMethods, numMethods);
-}
-
-void AndroidRuntime::setArgv0(const char* argv0, bool setProcName) {
-    // Set the kernel's task name, for as much of the name as we can fit.
-    // The kernel's TASK_COMM_LEN minus one for the terminating NUL == 15.
-    if (setProcName) {
-        int len = strlen(argv0);
-        if (len < 15) {
-            pthread_setname_np(pthread_self(), argv0);
-        } else {
-            pthread_setname_np(pthread_self(), argv0 + len - 15);
-        }
-    }
-
-    // Directly change the memory pointed to by argv[0].
-    memset(mArgBlockStart, 0, mArgBlockLength);
-    strlcpy(mArgBlockStart, argv0, mArgBlockLength);
-
-    // Let bionic know that we just did that, because __progname points
-    // into argv[0] (https://issuetracker.google.com/152893281).
-    setprogname(mArgBlockStart);
-}
-
-status_t AndroidRuntime::callMain(const String8& className, jclass clazz,
-    const Vector<String8>& args)
-{
-    JNIEnv* env;
-    jmethodID methodId;
-
-    ALOGD("Calling main entry %s", className.c_str());
-
-    env = getJNIEnv();
-    if (clazz == NULL || env == NULL) {
-        return UNKNOWN_ERROR;
-    }
-
-    methodId = env->GetStaticMethodID(clazz, "main", "([Ljava/lang/String;)V");
-    if (methodId == NULL) {
-        ALOGE("ERROR: could not find method %s.main(String[])\n", className.c_str());
-        return UNKNOWN_ERROR;
-    }
-
-    /*
-     * We want to call main() with a String array with our arguments in it.
-     * Create an array and populate it.
-     */
-    jclass stringClass;
-    jobjectArray strArray;
-
-    const size_t numArgs = args.size();
-    stringClass = env->FindClass("java/lang/String");
-    strArray = env->NewObjectArray(numArgs, stringClass, NULL);
-
-    for (size_t i = 0; i < numArgs; i++) {
-        jstring argStr = env->NewStringUTF(args[i].c_str());
-        env->SetObjectArrayElement(strArray, i, argStr);
-    }
-
-    env->CallStaticVoidMethod(clazz, methodId, strArray);
-    return NO_ERROR;
-}
-
 /*
  * The VM calls this through the "exit" hook.
  */
@@ -437,721 +273,6 @@ static bool hasFile(const char* file) {
     return false;
 }
 
-/*
- * Read the persistent locale. Inspects the following system properties
- * (in order) and returns the first non-empty property in the list :
- *
- * (1) persist.sys.locale
- * (2) persist.sys.language/country/localevar (country and localevar are
- * inspected iff. language is non-empty.
- * (3) ro.product.locale
- * (4) ro.product.locale.language/region
- *
- * Note that we need to inspect persist.sys.language/country/localevar to
- * preserve language settings for devices that are upgrading from Lollipop
- * to M. The same goes for ro.product.locale.language/region as well.
- */
-const std::string readLocale()
-{
-    const std::string locale = GetProperty("persist.sys.locale", "");
-    if (!locale.empty()) {
-        return locale;
-    }
-
-    const std::string language = GetProperty("persist.sys.language", "");
-    if (!language.empty()) {
-        const std::string country = GetProperty("persist.sys.country", "");
-        const std::string variant = GetProperty("persist.sys.localevar", "");
-
-        std::string out = language;
-        if (!country.empty()) {
-            out = out + "-" + country;
-        }
-
-        if (!variant.empty()) {
-            out = out + "-" + variant;
-        }
-
-        return out;
-    }
-
-    const std::string productLocale = GetProperty("ro.product.locale", "");
-    if (!productLocale.empty()) {
-        return productLocale;
-    }
-
-    // If persist.sys.locale and ro.product.locale are missing,
-    // construct a locale value from the individual locale components.
-    const std::string productLanguage = GetProperty("ro.product.locale.language", "en");
-    const std::string productRegion = GetProperty("ro.product.locale.region", "US");
-
-    return productLanguage + "-" + productRegion;
-}
-
-void AndroidRuntime::addOption(const char* optionString, void* extraInfo)
-{
-    JavaVMOption opt;
-    opt.optionString = optionString;
-    opt.extraInfo = extraInfo;
-    mOptions.add(opt);
-}
-
-/*
- * Parse a property containing space-separated options that should be
- * passed directly to the VM, e.g. "-Xmx32m -verbose:gc -Xregenmap".
- *
- * This will cut up "extraOptsBuf" as we chop it into individual options.
- *
- * If "quotingArg" is non-null, it is passed before each extra option in mOptions.
- *
- * Adds the strings, if any, to mOptions.
- */
-void AndroidRuntime::parseExtraOpts(char* extraOptsBuf, const char* quotingArg)
-{
-    char* start = extraOptsBuf;
-    char* end = NULL;
-    while (*start != '\0') {
-        while (*start == ' ')                   /* skip leading whitespace */
-            start++;
-        if (*start == '\0')                     /* was trailing ws, bail */
-            break;
-
-        end = start+1;
-        while (*end != ' ' && *end != '\0')     /* find end of token */
-            end++;
-        if (*end == ' ')
-            *end++ = '\0';          /* mark end, advance to indicate more */
-
-        if (quotingArg != NULL) {
-            addOption(quotingArg);
-        }
-        addOption(start);
-        start = end;
-    }
-}
-
-/*
- * Reads a "property" into "buffer" with a default of "defaultArg". If
- * the property is non-empty, it is treated as a runtime option such
- * as "-Xmx32m".
- *
- * The "runtimeArg" is a prefix for the option such as "-Xms" or "-Xmx".
- *
- * If an argument is found, it is added to mOptions.
- *
- * If an option is found, it is added to mOptions and true is
- * returned. Otherwise false is returned.
- */
-bool AndroidRuntime::parseRuntimeOption(const char* property,
-                                        char* buffer,
-                                        const char* runtimeArg,
-                                        const char* defaultArg)
-{
-    strcpy(buffer, runtimeArg);
-    size_t runtimeArgLen = strlen(runtimeArg);
-    property_get(property, buffer+runtimeArgLen, defaultArg);
-    if (buffer[runtimeArgLen] == '\0') {
-        return false;
-    }
-    addOption(buffer);
-    return true;
-}
-
-/*
- * Reads a "property" into "buffer". If the property is non-empty, it
- * is treated as a dex2oat compiler option that should be
- * passed as a quoted option, e.g. "-Ximage-compiler-option --compiler-filter=assume-verified".
- *
- * The "compilerArg" is a prefix for the option such as "--compiler-filter=".
- *
- * The "quotingArg" should be "-Ximage-compiler-option" or "-Xcompiler-option".
- *
- * If an option is found, it is added to mOptions and true is
- * returned. Otherwise false is returned.
- */
-bool AndroidRuntime::parseCompilerOption(const char* property,
-                                         char* buffer,
-                                         const char* compilerArg,
-                                         const char* quotingArg)
-{
-    strcpy(buffer, compilerArg);
-    size_t compilerArgLen = strlen(compilerArg);
-    property_get(property, buffer+compilerArgLen, "");
-    if (buffer[compilerArgLen] == '\0') {
-        return false;
-    }
-    addOption(quotingArg);
-    addOption(buffer);
-    return true;
-}
-
-/*
- * Reads a "property" into "buffer". If the property is non-empty, it
- * is treated as a dex2oat compiler runtime option that should be
- * passed as a quoted option, e.g. "-Ximage-compiler-option
- * --runtime-arg -Ximage-compiler-option -Xmx32m".
- *
- * The "runtimeArg" is a prefix for the option such as "-Xms" or "-Xmx".
- *
- * The "quotingArg" should be "-Ximage-compiler-option" or "-Xcompiler-option".
- *
- * If an option is found, it is added to mOptions and true is
- * returned. Otherwise false is returned.
- */
-bool AndroidRuntime::parseCompilerRuntimeOption(const char* property,
-                                                char* buffer,
-                                                const char* runtimeArg,
-                                                const char* quotingArg)
-{
-    strcpy(buffer, runtimeArg);
-    size_t runtimeArgLen = strlen(runtimeArg);
-    property_get(property, buffer+runtimeArgLen, "");
-    if (buffer[runtimeArgLen] == '\0') {
-        return false;
-    }
-    addOption(quotingArg);
-    addOption("--runtime-arg");
-    addOption(quotingArg);
-    addOption(buffer);
-    return true;
-}
-
-/*
- * Start the Dalvik Virtual Machine.
- *
- * Various arguments, most determined by system properties, are passed in.
- * The "mOptions" vector is updated.
- *
- * CAUTION: when adding options in here, be careful not to put the
- * char buffer inside a nested scope.  Adding the buffer to the
- * options using mOptions.add() does not copy the buffer, so if the
- * buffer goes out of scope the option may be overwritten.  It's best
- * to put the buffer at the top of the function so that it is more
- * unlikely that someone will surround it in a scope at a later time
- * and thus introduce a bug.
- *
- * Returns 0 on success.
- */
-int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, bool zygote, bool primary_zygote)
-{
-    JavaVMInitArgs initArgs;
-    char propBuf[PROPERTY_VALUE_MAX];
-    char jniOptsBuf[sizeof("-Xjniopts:")-1 + PROPERTY_VALUE_MAX];
-    char heapstartsizeOptsBuf[sizeof("-Xms")-1 + PROPERTY_VALUE_MAX];
-    char heapsizeOptsBuf[sizeof("-Xmx")-1 + PROPERTY_VALUE_MAX];
-    char heapgrowthlimitOptsBuf[sizeof("-XX:HeapGrowthLimit=")-1 + PROPERTY_VALUE_MAX];
-    char heapminfreeOptsBuf[sizeof("-XX:HeapMinFree=")-1 + PROPERTY_VALUE_MAX];
-    char heapmaxfreeOptsBuf[sizeof("-XX:HeapMaxFree=")-1 + PROPERTY_VALUE_MAX];
-    char usejitOptsBuf[sizeof("-Xusejit:")-1 + PROPERTY_VALUE_MAX];
-    char jitpthreadpriorityOptsBuf[sizeof("-Xjitpthreadpriority:")-1 + PROPERTY_VALUE_MAX];
-    char jitmaxsizeOptsBuf[sizeof("-Xjitmaxsize:")-1 + PROPERTY_VALUE_MAX];
-    char jitinitialsizeOptsBuf[sizeof("-Xjitinitialsize:")-1 + PROPERTY_VALUE_MAX];
-    char jitthresholdOptsBuf[sizeof("-Xjitthreshold:")-1 + PROPERTY_VALUE_MAX];
-    char jitprithreadweightOptBuf[sizeof("-Xjitprithreadweight:")-1 + PROPERTY_VALUE_MAX];
-    char jittransitionweightOptBuf[sizeof("-Xjittransitionweight:")-1 + PROPERTY_VALUE_MAX];
-    char hotstartupsamplesOptsBuf[sizeof("-Xps-hot-startup-method-samples:")-1 + PROPERTY_VALUE_MAX];
-    char saveResolvedClassesDelayMsOptsBuf[
-            sizeof("-Xps-save-resolved-classes-delay-ms:")-1 + PROPERTY_VALUE_MAX];
-    char profileMinSavePeriodOptsBuf[sizeof("-Xps-min-save-period-ms:")-1 + PROPERTY_VALUE_MAX];
-    char profileMinFirstSaveOptsBuf[sizeof("-Xps-min-first-save-ms:") - 1 + PROPERTY_VALUE_MAX];
-    char profileInlineCacheThresholdOptsBuf[
-            sizeof("-Xps-inline-cache-threshold:") - 1 + PROPERTY_VALUE_MAX];
-    char madviseWillNeedFileSizeVdex[
-            sizeof("-XMadviseWillNeedVdexFileSize:")-1 + PROPERTY_VALUE_MAX];
-    char madviseWillNeedFileSizeOdex[
-            sizeof("-XMadviseWillNeedOdexFileSize:")-1 + PROPERTY_VALUE_MAX];
-    char madviseWillNeedFileSizeArt[
-            sizeof("-XMadviseWillNeedArtFileSize:")-1 + PROPERTY_VALUE_MAX];
-    char gctypeOptsBuf[sizeof("-Xgc:")-1 + PROPERTY_VALUE_MAX];
-    char backgroundgcOptsBuf[sizeof("-XX:BackgroundGC=")-1 + PROPERTY_VALUE_MAX];
-    char heaptargetutilizationOptsBuf[sizeof("-XX:HeapTargetUtilization=")-1 + PROPERTY_VALUE_MAX];
-    char foregroundHeapGrowthMultiplierOptsBuf[
-            sizeof("-XX:ForegroundHeapGrowthMultiplier=")-1 + PROPERTY_VALUE_MAX];
-    char finalizerTimeoutMsOptsBuf[sizeof("-XX:FinalizerTimeoutMs=")-1 + PROPERTY_VALUE_MAX];
-    char threadSuspendTimeoutOptsBuf[sizeof("-XX:ThreadSuspendTimeout=")-1 + PROPERTY_VALUE_MAX];
-    char cachePruneBuf[sizeof("-Xzygote-max-boot-retry=")-1 + PROPERTY_VALUE_MAX];
-    char dex2oatXmsImageFlagsBuf[sizeof("-Xms")-1 + PROPERTY_VALUE_MAX];
-    char dex2oatXmxImageFlagsBuf[sizeof("-Xmx")-1 + PROPERTY_VALUE_MAX];
-    char dex2oatCompilerFilterBuf[sizeof("--compiler-filter=")-1 + PROPERTY_VALUE_MAX];
-    char dex2oatImageCompilerFilterBuf[sizeof("--compiler-filter=")-1 + PROPERTY_VALUE_MAX];
-    char dex2oatThreadsBuf[sizeof("-j")-1 + PROPERTY_VALUE_MAX];
-    char dex2oatThreadsImageBuf[sizeof("-j")-1 + PROPERTY_VALUE_MAX];
-    char dex2oatCpuSetBuf[sizeof("--cpu-set=")-1 + PROPERTY_VALUE_MAX];
-    char dex2oatCpuSetImageBuf[sizeof("--cpu-set=")-1 + PROPERTY_VALUE_MAX];
-    char dex2oat_isa_variant_key[PROPERTY_KEY_MAX];
-    char dex2oat_isa_variant[sizeof("--instruction-set-variant=") -1 + PROPERTY_VALUE_MAX];
-    char dex2oat_isa_features_key[PROPERTY_KEY_MAX];
-    char dex2oat_isa_features[sizeof("--instruction-set-features=") -1 + PROPERTY_VALUE_MAX];
-    char dex2oatFlagsBuf[PROPERTY_VALUE_MAX];
-    char dex2oatImageFlagsBuf[PROPERTY_VALUE_MAX];
-    char extraOptsBuf[PROPERTY_VALUE_MAX];
-    char perfettoHprofOptBuf[sizeof("-XX:PerfettoHprof=") + PROPERTY_VALUE_MAX];
-    char perfettoJavaHeapStackOptBuf[
-            sizeof("-XX:PerfettoJavaHeapStackProf=") + PROPERTY_VALUE_MAX];
-    enum {
-      kEMDefault,
-      kEMIntPortable,
-      kEMIntFast,
-      kEMJitCompiler,
-    } executionMode = kEMDefault;
-    char localeOption[sizeof("-Duser.locale=") + PROPERTY_VALUE_MAX];
-    char lockProfThresholdBuf[sizeof("-Xlockprofthreshold:")-1 + PROPERTY_VALUE_MAX];
-    char nativeBridgeLibrary[sizeof("-XX:NativeBridge=") + PROPERTY_VALUE_MAX];
-    char cpuAbiListBuf[sizeof("--cpu-abilist=") + PROPERTY_VALUE_MAX];
-    char corePlatformApiPolicyBuf[sizeof("-Xcore-platform-api-policy:") + PROPERTY_VALUE_MAX];
-    char methodTraceFileBuf[sizeof("-Xmethod-trace-file:") + PROPERTY_VALUE_MAX];
-    char methodTraceFileSizeBuf[sizeof("-Xmethod-trace-file-size:") + PROPERTY_VALUE_MAX];
-    std::string fingerprintBuf;
-    char javaZygoteForkLoopBuf[sizeof("-XX:ForceJavaZygoteForkLoop=") + PROPERTY_VALUE_MAX];
-    char jdwpProviderBuf[sizeof("-XjdwpProvider:") - 1 + PROPERTY_VALUE_MAX];
-    char opaqueJniIds[sizeof("-Xopaque-jni-ids:") - 1 + PROPERTY_VALUE_MAX];
-    char bootImageBuf[sizeof("-Ximage:") - 1 + PROPERTY_VALUE_MAX];
-
-    // Read if we are using the profile configuration, do this at the start since the last ART args
-    // take precedence.
-    std::string profile_boot_class_path_flag =
-            server_configurable_flags::GetServerConfigurableFlag(RUNTIME_NATIVE_BOOT_NAMESPACE,
-                                                                 PROFILE_BOOT_CLASS_PATH,
-                                                                 /*default_value=*/"");
-    bool profile_boot_class_path;
-    switch (ParseBool(profile_boot_class_path_flag)) {
-        case ParseBoolResult::kError:
-            // Default to the system property.
-            profile_boot_class_path =
-                    GetBoolProperty("dalvik.vm.profilebootclasspath", /*default_value=*/false);
-            break;
-        case ParseBoolResult::kTrue:
-            profile_boot_class_path = true;
-            break;
-        case ParseBoolResult::kFalse:
-            profile_boot_class_path = false;
-            break;
-    }
-    if (profile_boot_class_path) {
-        addOption("-Xcompiler-option");
-        addOption("--count-hotness-in-compiled-code");
-        addOption("-Xps-profile-boot-class-path");
-        addOption("-Xps-profile-aot-code");
-        addOption("-Xjitsaveprofilinginfo");
-    }
-
-    std::string use_jitzygote_image_flag =
-            server_configurable_flags::GetServerConfigurableFlag(RUNTIME_NATIVE_BOOT_NAMESPACE,
-                                                                 ENABLE_JITZYGOTE_IMAGE,
-                                                                 /*default_value=*/"");
-    // Use the APEX boot image for boot class path profiling to get JIT samples on BCP methods.
-    // Also use the APEX boot image if it's explicitly enabled via configuration flag.
-    const bool use_apex_image = profile_boot_class_path || (use_jitzygote_image_flag == "true");
-    if (use_apex_image) {
-        ALOGI("Using JIT Zygote image: '%s'\n", kJitZygoteImageOption);
-        addOption(kJitZygoteImageOption);
-    } else if (parseRuntimeOption("dalvik.vm.boot-image", bootImageBuf, "-Ximage:")) {
-        ALOGI("Using dalvik.vm.boot-image: '%s'\n", bootImageBuf);
-    } else {
-        ALOGI("Using default boot image");
-    }
-
-    std::string disable_lock_profiling =
-        server_configurable_flags::GetServerConfigurableFlag(RUNTIME_NATIVE_BOOT_NAMESPACE,
-                                                             DISABLE_LOCK_PROFILING,
-                                                             /*default_value=*/ "");
-    if (disable_lock_profiling == "true") {
-        addOption(kLockProfThresholdRuntimeOption);
-        ALOGI("Disabling lock profiling: '%s'\n", kLockProfThresholdRuntimeOption);
-    } else {
-        ALOGI("Leaving lock profiling enabled");
-    }
-
-    const bool checkJni = GetBoolProperty("dalvik.vm.checkjni", false);
-    if (checkJni) {
-        ALOGD("CheckJNI is ON");
-
-        /* extended JNI checking */
-        addOption("-Xcheck:jni");
-
-        /* with -Xcheck:jni, this provides a JNI function call trace */
-        //addOption("-verbose:jni");
-    }
-
-    const bool odsignVerificationSuccess = GetBoolProperty("odsign.verification.success", false);
-    if (!odsignVerificationSuccess) {
-        addOption("-Xdeny-art-apex-data-files");
-    }
-
-    property_get("dalvik.vm.execution-mode", propBuf, "");
-    if (strcmp(propBuf, "int:portable") == 0) {
-        executionMode = kEMIntPortable;
-    } else if (strcmp(propBuf, "int:fast") == 0) {
-        executionMode = kEMIntFast;
-    } else if (strcmp(propBuf, "int:jit") == 0) {
-        executionMode = kEMJitCompiler;
-    }
-
-    strcpy(jniOptsBuf, "-Xjniopts:");
-    if (parseRuntimeOption("dalvik.vm.jniopts", jniOptsBuf, "-Xjniopts:")) {
-        ALOGI("JNI options: '%s'\n", jniOptsBuf);
-    }
-
-    /* route exit() to our handler */
-    addOption("exit", (void*) runtime_exit);
-
-    /* route fprintf() to our handler */
-    addOption("vfprintf", (void*) runtime_vfprintf);
-
-    /* register the framework-specific "is sensitive thread" hook */
-    addOption("sensitiveThread", (void*) runtime_isSensitiveThread);
-
-    /* enable verbose; standard options are { jni, gc, class } */
-    //addOption("-verbose:jni");
-    addOption("-verbose:gc");
-    //addOption("-verbose:class");
-
-    // On Android, we always want to allow loading the PerfettoHprof plugin.
-    // Even with this option set, we will still only actually load the plugin
-    // if we are on a userdebug build or the app is debuggable or profileable.
-    // This is enforced in art/runtime/runtime.cc.
-    //
-    // We want to be able to disable this, because this does not work on host,
-    // and we do not want to enable it in tests.
-    parseRuntimeOption("dalvik.vm.perfetto_hprof", perfettoHprofOptBuf, "-XX:PerfettoHprof=",
-                       "true");
-
-    // Enable PerfettoJavaHeapStackProf in the zygote
-    parseRuntimeOption("dalvik.vm.perfetto_javaheap", perfettoJavaHeapStackOptBuf,
-                       "-XX:PerfettoJavaHeapStackProf=", "true");
-
-    if (primary_zygote) {
-        addOption("-Xprimaryzygote");
-    }
-
-    /*
-     * The default starting and maximum size of the heap.  Larger
-     * values should be specified in a product property override.
-     */
-    parseRuntimeOption("dalvik.vm.heapstartsize", heapstartsizeOptsBuf, "-Xms", "4m");
-    parseRuntimeOption("dalvik.vm.heapsize", heapsizeOptsBuf, "-Xmx", "16m");
-
-    parseRuntimeOption("dalvik.vm.heapgrowthlimit", heapgrowthlimitOptsBuf, "-XX:HeapGrowthLimit=");
-    parseRuntimeOption("dalvik.vm.heapminfree", heapminfreeOptsBuf, "-XX:HeapMinFree=");
-    parseRuntimeOption("dalvik.vm.heapmaxfree", heapmaxfreeOptsBuf, "-XX:HeapMaxFree=");
-    parseRuntimeOption("dalvik.vm.heaptargetutilization",
-                       heaptargetutilizationOptsBuf,
-                       "-XX:HeapTargetUtilization=");
-
-    /* Foreground heap growth multiplier option */
-    parseRuntimeOption("dalvik.vm.foreground-heap-growth-multiplier",
-                       foregroundHeapGrowthMultiplierOptsBuf,
-                       "-XX:ForegroundHeapGrowthMultiplier=");
-    /*
-     * Finalizer and thread suspend timeouts.
-     */
-    parseRuntimeOption("dalvik.vm.finalizer-timeout-ms",
-                       finalizerTimeoutMsOptsBuf,
-                       "-XX:FinalizerTimeoutMs=");
-    parseRuntimeOption("dalvik.vm.thread-suspend-timeout-ms",
-                       threadSuspendTimeoutOptsBuf,
-                       "-XX:ThreadSuspendTimeout=");
-    /*
-     * JIT related options.
-     */
-    parseRuntimeOption("dalvik.vm.usejit", usejitOptsBuf, "-Xusejit:");
-    parseRuntimeOption("dalvik.vm.jitmaxsize", jitmaxsizeOptsBuf, "-Xjitmaxsize:");
-    parseRuntimeOption("dalvik.vm.jitinitialsize", jitinitialsizeOptsBuf, "-Xjitinitialsize:");
-    parseRuntimeOption("dalvik.vm.jitthreshold", jitthresholdOptsBuf, "-Xjitthreshold:");
-    parseRuntimeOption("dalvik.vm.jitpthreadpriority",
-                       jitpthreadpriorityOptsBuf,
-                       "-Xjitpthreadpriority:");
-    addOption("-Xjitsaveprofilinginfo");
-
-    parseRuntimeOption("dalvik.vm.jitprithreadweight",
-                       jitprithreadweightOptBuf,
-                       "-Xjitprithreadweight:");
-
-    parseRuntimeOption("dalvik.vm.jittransitionweight", jittransitionweightOptBuf,
-                       "-Xjittransitionweight:");
-
-    /*
-     * Use default platform configuration as limits for madvising,
-     * when no properties are specified.
-     */
-    parseRuntimeOption("dalvik.vm.madvise.vdexfile.size",
-                       madviseWillNeedFileSizeVdex,
-                       "-XMadviseWillNeedVdexFileSize:");
-
-    parseRuntimeOption("dalvik.vm.madvise.odexfile.size",
-                       madviseWillNeedFileSizeOdex,
-                       "-XMadviseWillNeedOdexFileSize:");
-
-    parseRuntimeOption("dalvik.vm.madvise.artfile.size",
-                       madviseWillNeedFileSizeArt,
-                       "-XMadviseWillNeedArtFileSize:");
-
-    /*
-     * Profile related options.
-     */
-    parseRuntimeOption("dalvik.vm.hot-startup-method-samples", hotstartupsamplesOptsBuf,
-            "-Xps-hot-startup-method-samples:");
-
-    parseRuntimeOption("dalvik.vm.ps-resolved-classes-delay-ms", saveResolvedClassesDelayMsOptsBuf,
-            "-Xps-save-resolved-classes-delay-ms:");
-
-    parseRuntimeOption("dalvik.vm.ps-min-save-period-ms", profileMinSavePeriodOptsBuf,
-            "-Xps-min-save-period-ms:");
-
-    parseRuntimeOption("dalvik.vm.ps-min-first-save-ms", profileMinFirstSaveOptsBuf,
-            "-Xps-min-first-save-ms:");
-
-    parseRuntimeOption("dalvik.vm.ps-inline-cache-threshold", profileInlineCacheThresholdOptsBuf,
-            "-Xps-inline-cache-threshold:");
-
-    property_get("ro.config.low_ram", propBuf, "");
-    if (strcmp(propBuf, "true") == 0) {
-      addOption("-XX:LowMemoryMode");
-    }
-
-    /*
-     * Garbage-collection related options.
-     */
-    parseRuntimeOption("dalvik.vm.gctype", gctypeOptsBuf, "-Xgc:");
-
-    // If it set, honor the "enable_generational_cc" device configuration;
-    // otherwise, let the runtime use its default behavior.
-    std::string enable_generational_cc =
-        server_configurable_flags::GetServerConfigurableFlag(RUNTIME_NATIVE_BOOT_NAMESPACE,
-                                                             ENABLE_GENERATIONAL_CC,
-                                                             /*default_value=*/ "");
-    if (enable_generational_cc == "true") {
-        addOption(kGenerationalCCRuntimeOption);
-    } else if (enable_generational_cc == "false") {
-        addOption(kNoGenerationalCCRuntimeOption);
-    }
-
-    parseRuntimeOption("dalvik.vm.backgroundgctype", backgroundgcOptsBuf, "-XX:BackgroundGC=");
-
-    /*
-     * Enable/disable zygote native fork loop.
-     */
-    parseRuntimeOption("dalvik.vm.force-java-zygote-fork-loop",
-                       javaZygoteForkLoopBuf,
-                       "-XX:ForceJavaZygoteForkLoop=");
-
-    /*
-     * Enable debugging only for apps forked from zygote.
-     */
-    if (zygote) {
-      // Set the JDWP provider and required arguments. By default let the runtime choose how JDWP is
-      // implemented. When this is not set the runtime defaults to not allowing JDWP.
-      addOption("-XjdwpOptions:suspend=n,server=y");
-      parseRuntimeOption("dalvik.vm.jdwp-provider",
-                         jdwpProviderBuf,
-                         "-XjdwpProvider:",
-                         "default");
-    }
-
-    // Only pass an explicit opaque-jni-ids to apps forked from zygote
-    if (zygote) {
-      parseRuntimeOption("dalvik.vm.opaque-jni-ids",
-                        opaqueJniIds,
-                        "-Xopaque-jni-ids:",
-                        "swapable");
-    }
-
-    parseRuntimeOption("dalvik.vm.lockprof.threshold",
-                       lockProfThresholdBuf,
-                       "-Xlockprofthreshold:");
-
-    if (executionMode == kEMIntPortable) {
-        addOption("-Xint:portable");
-    } else if (executionMode == kEMIntFast) {
-        addOption("-Xint:fast");
-    } else if (executionMode == kEMJitCompiler) {
-        addOption("-Xint:jit");
-    }
-
-    // Extra options for JIT.
-    parseCompilerOption("dalvik.vm.dex2oat-filter", dex2oatCompilerFilterBuf,
-                        "--compiler-filter=", "-Xcompiler-option");
-    parseCompilerOption("dalvik.vm.dex2oat-threads", dex2oatThreadsBuf, "-j", "-Xcompiler-option");
-    parseCompilerOption("dalvik.vm.dex2oat-cpu-set", dex2oatCpuSetBuf, "--cpu-set=",
-                        "-Xcompiler-option");
-
-    // Copy the variant.
-    sprintf(dex2oat_isa_variant_key, "dalvik.vm.isa.%s.variant", ABI_STRING);
-    parseCompilerOption(dex2oat_isa_variant_key, dex2oat_isa_variant,
-                        "--instruction-set-variant=", "-Xcompiler-option");
-    // Copy the features.
-    sprintf(dex2oat_isa_features_key, "dalvik.vm.isa.%s.features", ABI_STRING);
-    parseCompilerOption(dex2oat_isa_features_key, dex2oat_isa_features,
-                        "--instruction-set-features=", "-Xcompiler-option");
-
-    /*
-     * When running with debug.generate-debug-info, add --generate-debug-info to the compiler
-     * options so that both JITted code and the boot image, if it is compiled on device, will
-     * include native debugging information.
-     */
-    property_get("debug.generate-debug-info", propBuf, "");
-    bool generate_debug_info = (strcmp(propBuf, "true") == 0);
-    if (generate_debug_info) {
-        addOption("-Xcompiler-option");
-        addOption("--generate-debug-info");
-    }
-
-    // The mini-debug-info makes it possible to backtrace through compiled code.
-    bool generate_mini_debug_info = property_get_bool("dalvik.vm.minidebuginfo", 0);
-    if (generate_mini_debug_info) {
-        addOption("-Xcompiler-option");
-        addOption("--generate-mini-debug-info");
-    }
-
-    property_get("dalvik.vm.dex2oat-flags", dex2oatFlagsBuf, "");
-    parseExtraOpts(dex2oatFlagsBuf, "-Xcompiler-option");
-
-    /* extra options; parse this late so it overrides others */
-    property_get("dalvik.vm.extra-opts", extraOptsBuf, "");
-    parseExtraOpts(extraOptsBuf, NULL);
-
-    // Extra options for boot image generation.
-    parseCompilerRuntimeOption("dalvik.vm.image-dex2oat-Xms", dex2oatXmsImageFlagsBuf,
-                               "-Xms", "-Ximage-compiler-option");
-    parseCompilerRuntimeOption("dalvik.vm.image-dex2oat-Xmx", dex2oatXmxImageFlagsBuf,
-                               "-Xmx", "-Ximage-compiler-option");
-
-    parseCompilerOption("dalvik.vm.image-dex2oat-filter", dex2oatImageCompilerFilterBuf,
-                        "--compiler-filter=", "-Ximage-compiler-option");
-
-    // If there is a dirty-image-objects file, push it.
-    if (hasFile("/system/etc/dirty-image-objects")) {
-        addOption("-Ximage-compiler-option");
-        addOption("--dirty-image-objects=/system/etc/dirty-image-objects");
-    }
-
-    parseCompilerOption("dalvik.vm.image-dex2oat-threads", dex2oatThreadsImageBuf, "-j",
-                        "-Ximage-compiler-option");
-    parseCompilerOption("dalvik.vm.image-dex2oat-cpu-set", dex2oatCpuSetImageBuf, "--cpu-set=",
-                        "-Ximage-compiler-option");
-
-    // The runtime may compile a boot image, when necessary, not using installd. Thus, we need
-    // to pass the instruction-set-features/variant as an image-compiler-option.
-    // Note: it is OK to reuse the buffer, as the values are exactly the same between
-    //       * compiler-option, used for runtime compilation (DexClassLoader)
-    //       * image-compiler-option, used for boot-image compilation on device
-    parseCompilerOption(dex2oat_isa_variant_key, dex2oat_isa_variant,
-                        "--instruction-set-variant=", "-Ximage-compiler-option");
-    parseCompilerOption(dex2oat_isa_features_key, dex2oat_isa_features,
-                        "--instruction-set-features=", "-Ximage-compiler-option");
-
-    if (generate_debug_info) {
-        addOption("-Ximage-compiler-option");
-        addOption("--generate-debug-info");
-    }
-
-    if (generate_mini_debug_info) {
-        addOption("-Ximage-compiler-option");
-        addOption("--generate-mini-debug-info");
-    }
-
-    property_get("dalvik.vm.image-dex2oat-flags", dex2oatImageFlagsBuf, "");
-    parseExtraOpts(dex2oatImageFlagsBuf, "-Ximage-compiler-option");
-
-    /* Set the properties for locale */
-    {
-        strcpy(localeOption, "-Duser.locale=");
-        const std::string locale = readLocale();
-        strncat(localeOption, locale.c_str(), PROPERTY_VALUE_MAX);
-        addOption(localeOption);
-    }
-
-    // Trace files are stored in /data/misc/trace which is writable only in debug mode.
-    property_get("ro.debuggable", propBuf, "0");
-    if (strcmp(propBuf, "1") == 0) {
-        property_get("dalvik.vm.method-trace", propBuf, "false");
-        if (strcmp(propBuf, "true") == 0) {
-            addOption("-Xmethod-trace");
-            parseRuntimeOption("dalvik.vm.method-trace-file",
-                               methodTraceFileBuf,
-                               "-Xmethod-trace-file:");
-            parseRuntimeOption("dalvik.vm.method-trace-file-siz",
-                               methodTraceFileSizeBuf,
-                               "-Xmethod-trace-file-size:");
-            property_get("dalvik.vm.method-trace-stream", propBuf, "false");
-            if (strcmp(propBuf, "true") == 0) {
-                addOption("-Xmethod-trace-stream");
-            }
-        }
-    }
-
-    // Native bridge library. "0" means that native bridge is disabled.
-    //
-    // Note: bridging is only enabled for the zygote. Other runs of
-    //       app_process may not have the permissions to mount etc.
-    property_get("ro.dalvik.vm.native.bridge", propBuf, "");
-    if (propBuf[0] == '\0') {
-        ALOGW("ro.dalvik.vm.native.bridge is not expected to be empty");
-    } else if (zygote && strcmp(propBuf, "0") != 0) {
-        snprintf(nativeBridgeLibrary, sizeof("-XX:NativeBridge=") + PROPERTY_VALUE_MAX,
-                 "-XX:NativeBridge=%s", propBuf);
-        addOption(nativeBridgeLibrary);
-    }
-
-#if defined(__LP64__)
-    const char* cpu_abilist_property_name = "ro.product.cpu.abilist64";
-#else
-    const char* cpu_abilist_property_name = "ro.product.cpu.abilist32";
-#endif  // defined(__LP64__)
-    property_get(cpu_abilist_property_name, propBuf, "");
-    if (propBuf[0] == '\0') {
-        ALOGE("%s is not expected to be empty", cpu_abilist_property_name);
-        return -1;
-    }
-    snprintf(cpuAbiListBuf, sizeof(cpuAbiListBuf), "--cpu-abilist=%s", propBuf);
-    addOption(cpuAbiListBuf);
-
-    // Dalvik-cache pruning counter.
-    parseRuntimeOption("dalvik.vm.zygote.max-boot-retry", cachePruneBuf,
-                       "-Xzygote-max-boot-retry=");
-
-    // If set, the property below can be used to enable core platform API violation reporting.
-    property_get("persist.debug.dalvik.vm.core_platform_api_policy", propBuf, "");
-    if (propBuf[0] != '\0') {
-      snprintf(corePlatformApiPolicyBuf,
-               sizeof(corePlatformApiPolicyBuf),
-               "-Xcore-platform-api-policy:%s",
-               propBuf);
-      addOption(corePlatformApiPolicyBuf);
-    }
-
-    /*
-     * Retrieve the build fingerprint and provide it to the runtime. That way, ANR dumps will
-     * contain the fingerprint and can be parsed.
-     * Fingerprints are potentially longer than PROPERTY_VALUE_MAX, so parseRuntimeOption() cannot
-     * be used here.
-     * Do not ever re-assign fingerprintBuf as its c_str() value is stored in mOptions.
-     */
-    std::string fingerprint = GetProperty("ro.build.fingerprint", "");
-    if (!fingerprint.empty()) {
-        fingerprintBuf = "-Xfingerprint:" + fingerprint;
-        addOption(fingerprintBuf.c_str());
-    }
-
-    initArgs.version = JNI_VERSION_1_4;
-    initArgs.options = mOptions.editArray();
-    initArgs.nOptions = mOptions.size();
-    initArgs.ignoreUnrecognized = JNI_FALSE;
-
-    /*
-     * Initialize the VM.
-     *
-     * The JavaVM* is essentially per-process, and the JNIEnv* is per-thread.
-     * If this call succeeds, the VM is ready, and we can start issuing
-     * JNI calls.
-     */
-    if (JNI_CreateJavaVM(pJavaVM, pEnv, &initArgs) < 0) {
-        ALOGE("JNI_CreateJavaVM failed\n");
-        return -1;
-    }
-
-    return 0;
-}
 
 char* AndroidRuntime::toSlashClassName(const char* className)
 {
@@ -1164,20 +285,6 @@ char* AndroidRuntime::toSlashClassName(const char* className)
     return result;
 }
 
-/** Create a Java string from an ASCII or Latin-1 string */
-jstring AndroidRuntime::NewStringLatin1(JNIEnv* env, const char* bytes) {
-    if (!bytes) return NULL;
-    int length = strlen(bytes);
-    jchar* buffer = (jchar *)alloca(length * sizeof(jchar));
-    if (!buffer) return NULL;
-    jchar* chp = buffer;
-    for (int i = 0; i < length; i++) {
-        *chp++ = *bytes++;
-    }
-    return env->NewString(buffer, length);
-}
-
-
 /*
  * Start the Android runtime.  This involves starting the virtual machine
  * and calling the "static void main(String[] args)" method in the class
@@ -1191,121 +298,19 @@ void AndroidRuntime::start(const char* className, const Vector<String8>& options
     ALOGD(">>>>>> START %s uid %d <<<<<<\n",
             className != NULL ? className : "(unknown)", getuid());
 
-    static const String8 startSystemServer("start-system-server");
-    // Whether this is the primary zygote, meaning the zygote which will fork system server.
-    bool primary_zygote = false;
-
-    /*
-     * 'startSystemServer == true' means runtime is obsolete and not run from
-     * init.rc anymore, so we print out the boot start event here.
-     */
-    for (size_t i = 0; i < options.size(); ++i) {
-        if (options[i] == startSystemServer) {
-            primary_zygote = true;
-           /* track our progress through the boot sequence */
-           const int LOG_BOOT_PROGRESS_START = 3000;
-           LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));
-        }
-    }
-
-    const char* rootDir = getenv("ANDROID_ROOT");
-    if (rootDir == NULL) {
-        rootDir = "/system";
-        if (!hasDir("/system")) {
-            LOG_FATAL("No root directory specified, and /system does not exist.");
-            return;
-        }
-        setenv("ANDROID_ROOT", rootDir, 1);
-    }
-
-    const char* artRootDir = getenv("ANDROID_ART_ROOT");
-    if (artRootDir == NULL) {
-        LOG_FATAL("No ART directory specified with ANDROID_ART_ROOT environment variable.");
-        return;
-    }
-
-    const char* i18nRootDir = getenv("ANDROID_I18N_ROOT");
-    if (i18nRootDir == NULL) {
-        LOG_FATAL("No runtime directory specified with ANDROID_I18N_ROOT environment variable.");
-        return;
-    }
-
-    const char* tzdataRootDir = getenv("ANDROID_TZDATA_ROOT");
-    if (tzdataRootDir == NULL) {
-        LOG_FATAL("No tz data directory specified with ANDROID_TZDATA_ROOT environment variable.");
-        return;
-    }
-
-    //const char* kernelHack = getenv("LD_ASSUME_KERNEL");
-    //ALOGD("Found LD_ASSUME_KERNEL='%s'\n", kernelHack);
-
-    /* start the virtual machine */
-    JniInvocation jni_invocation;
-    jni_invocation.Init(NULL);
-    JNIEnv* env;
-    if (startVm(&mJavaVM, &env, zygote, primary_zygote) != 0) {
-        return;
-    }
-    onVmCreated(env);
-
+    JNIEnv* env = mJniEnv;
     /*
      * Register android functions.
      */
     if (startReg(env) < 0) {
         ALOGE("Unable to register all android natives\n");
         return;
-    }
-
-    /*
-     * We want to call main() with a String array with arguments in it.
-     * At present we have two arguments, the class name and an option string.
-     * Create an array to hold them.
-     */
-    jclass stringClass;
-    jobjectArray strArray;
-    jstring classNameStr;
-
-    stringClass = env->FindClass("java/lang/String");
-    assert(stringClass != NULL);
-    strArray = env->NewObjectArray(options.size() + 1, stringClass, NULL);
-    assert(strArray != NULL);
-    classNameStr = env->NewStringUTF(className);
-    assert(classNameStr != NULL);
-    env->SetObjectArrayElement(strArray, 0, classNameStr);
-
-    for (size_t i = 0; i < options.size(); ++i) {
-        jstring optionsStr = env->NewStringUTF(options.itemAt(i).c_str());
-        assert(optionsStr != NULL);
-        env->SetObjectArrayElement(strArray, i + 1, optionsStr);
-    }
-
-    /*
-     * Start VM.  This thread becomes the main thread of the VM, and will
-     * not return until the VM exits.
-     */
-    char* slashClassName = toSlashClassName(className != NULL ? className : "");
-    jclass startClass = env->FindClass(slashClassName);
-    if (startClass == NULL) {
-        ALOGE("JavaVM unable to locate class '%s'\n", slashClassName);
-        /* keep going */
     } else {
-        jmethodID startMeth = env->GetStaticMethodID(startClass, "main",
-            "([Ljava/lang/String;)V");
-        if (startMeth == NULL) {
-            ALOGE("JavaVM unable to find main() in '%s'\n", className);
-            /* keep going */
-        } else {
-            env->CallStaticVoidMethod(startClass, startMeth, strArray);
-
-#if 0
-            if (env->ExceptionCheck())
-                threadExitUncaughtException(env);
-#endif
-        }
+        ALOGE("start Reg success!!");
+        return ;
     }
-    free(slashClassName);
 
-    ALOGD("Shutting down VM\n");
+    ALOGE("Shutting down VM\n");
     if (mJavaVM->DetachCurrentThread() != JNI_OK)
         ALOGW("Warning: unable to detach main thread\n");
     if (mJavaVM->DestroyJavaVM() != 0)
@@ -1332,9 +337,15 @@ void AndroidRuntime::exit(int code)
 #endif
 }
 
+void AndroidRuntime::onJavaVmCreated(JavaVM* vm)
+{
+    AndroidRuntime::mJavaVM = vm;
+}
+
 void AndroidRuntime::onVmCreated(JNIEnv* env)
 {
     // If AndroidRuntime had anything to do here, we'd have done it in 'start'.
+    mJniEnv = env;
 }
 
 /*static*/ JavaVM* AndroidRuntime::getJavaVM() {
@@ -1483,18 +494,18 @@ static void quickTest(void* arg)
 }
 #endif
 
-#ifdef NDEBUG
+// #ifdef NDEBUG
     #define REG_JNI(name)      { name }
     struct RegJNIRec {
         int (*mProc)(JNIEnv*);
     };
-#else
-    #define REG_JNI(name)      { name, #name }
-    struct RegJNIRec {
-        int (*mProc)(JNIEnv*);
-        const char* mName;
-    };
-#endif
+// #else
+//     #define REG_JNI(name)      { name, #name }
+//     struct RegJNIRec {
+//         int (*mProc)(JNIEnv*);
+//         const char* mName;
+//     };
+// #endif
 
 typedef void (*RegJAMProc)();
 
@@ -1502,9 +513,6 @@ static int register_jni_procs(const RegJNIRec array[], size_t count, JNIEnv* env
 {
     for (size_t i = 0; i < count; i++) {
         if (array[i].mProc(env) < 0) {
-#ifndef NDEBUG
-            ALOGD("----------!!! %s failed to load\n", array[i].mName);
-#endif
             return -1;
         }
     }
@@ -1512,172 +520,73 @@ static int register_jni_procs(const RegJNIRec array[], size_t count, JNIEnv* env
 }
 
 static const RegJNIRec gRegJNI[] = {
-        REG_JNI(register_com_android_internal_os_RuntimeInit),
-        REG_JNI(register_com_android_internal_os_ZygoteInit_nativeZygoteInit),
-        REG_JNI(register_android_os_SystemClock),
-        REG_JNI(register_android_util_CharsetUtils),
+        // REG_JNI(register_android_os_SystemClock),
         REG_JNI(register_android_util_EventLog),
         REG_JNI(register_android_util_Log),
-        REG_JNI(register_android_util_MemoryIntArray),
-        REG_JNI(register_android_app_admin_SecurityLog),
-        REG_JNI(register_android_content_AssetManager),
+        // REG_JNI(register_android_content_AssetManager),
         REG_JNI(register_android_content_StringBlock),
         REG_JNI(register_android_content_XmlBlock),
-        REG_JNI(register_android_content_res_ApkAssets),
-        REG_JNI(register_android_content_res_ResourceTimer),
+        // REG_JNI(register_android_content_res_ApkAssets),
         REG_JNI(register_android_text_AndroidCharacter),
-        REG_JNI(register_android_text_Hyphenator),
         REG_JNI(register_android_view_InputDevice),
         REG_JNI(register_android_view_KeyCharacterMap),
-        REG_JNI(register_android_os_Process),
         REG_JNI(register_android_os_SystemProperties),
-        REG_JNI(register_android_os_Binder),
-        REG_JNI(register_android_os_Parcel),
-        REG_JNI(register_android_os_PerformanceHintManager),
-        REG_JNI(register_android_os_HidlMemory),
-        REG_JNI(register_android_os_HidlSupport),
-        REG_JNI(register_android_os_HwBinder),
-        REG_JNI(register_android_os_HwBlob),
-        REG_JNI(register_android_os_HwParcel),
-        REG_JNI(register_android_os_HwRemoteBinder),
-        REG_JNI(register_android_os_NativeHandle),
-        REG_JNI(register_android_os_ServiceManager),
-        REG_JNI(register_android_os_storage_StorageManager),
-        REG_JNI(register_android_service_DataLoaderService),
-        REG_JNI(register_android_view_DisplayEventReceiver),
-        REG_JNI(register_android_view_Surface),
-        REG_JNI(register_android_view_SurfaceControl),
-        REG_JNI(register_android_view_SurfaceControlHdrLayerInfoListener),
-        REG_JNI(register_android_view_SurfaceSession),
-        REG_JNI(register_android_view_InputApplicationHandle),
-        // This must be called after register_android_view_SurfaceControl since it has a dependency
-        // on the Java SurfaceControl object that references a native resource via static request.
-        REG_JNI(register_android_view_InputWindowHandle),
-        REG_JNI(register_android_view_CompositionSamplingListener),
-        REG_JNI(register_android_view_TextureView),
-        REG_JNI(register_android_view_TunnelModeEnabledListener),
-        REG_JNI(register_com_google_android_gles_jni_EGLImpl),
-        REG_JNI(register_com_google_android_gles_jni_GLImpl),
-        REG_JNI(register_android_opengl_jni_EGL14),
-        REG_JNI(register_android_opengl_jni_EGL15),
-        REG_JNI(register_android_opengl_jni_EGLExt),
-        REG_JNI(register_android_opengl_jni_GLES10),
-        REG_JNI(register_android_opengl_jni_GLES10Ext),
-        REG_JNI(register_android_opengl_jni_GLES11),
-        REG_JNI(register_android_opengl_jni_GLES11Ext),
-        REG_JNI(register_android_opengl_jni_GLES20),
-        REG_JNI(register_android_opengl_jni_GLES30),
-        REG_JNI(register_android_opengl_jni_GLES31),
-        REG_JNI(register_android_opengl_jni_GLES31Ext),
-        REG_JNI(register_android_opengl_jni_GLES32),
-        REG_JNI(register_android_graphics_classes),
-        REG_JNI(register_android_graphics_BLASTBufferQueue),
-        REG_JNI(register_android_graphics_GraphicBuffer),
-        REG_JNI(register_android_graphics_GraphicsStatsService),
-        REG_JNI(register_android_graphics_SurfaceTexture),
-        REG_JNI(register_android_database_CursorWindow),
-        REG_JNI(register_android_database_SQLiteConnection),
-        REG_JNI(register_android_database_SQLiteGlobal),
-        REG_JNI(register_android_database_SQLiteDebug),
-        REG_JNI(register_android_database_SQLiteRawStatement),
-        REG_JNI(register_android_os_Debug),
-        REG_JNI(register_android_os_FileObserver),
-        REG_JNI(register_android_os_GraphicsEnvironment),
-        REG_JNI(register_android_os_MessageQueue),
-        REG_JNI(register_android_os_SELinux),
+        // REG_JNI(register_android_os_Parcel),
+        // REG_JNI(register_android_database_CursorWindow),
+        // REG_JNI(register_android_database_SQLiteConnection),
+        // REG_JNI(register_android_database_SQLiteGlobal),
+        // REG_JNI(register_android_database_SQLiteDebug),
+        // REG_JNI(register_android_os_FileObserver),
+        // REG_JNI(register_android_os_MessageQueue),
         REG_JNI(register_android_os_Trace),
-        REG_JNI(register_android_os_UEventObserver),
-        REG_JNI(register_android_net_LocalSocketImpl),
-        REG_JNI(register_android_os_MemoryFile),
-        REG_JNI(register_android_os_SharedMemory),
-        REG_JNI(register_android_os_incremental_IncrementalManager),
-        REG_JNI(register_com_android_internal_content_om_OverlayConfig),
-        REG_JNI(register_com_android_internal_content_om_OverlayManagerImpl),
-        REG_JNI(register_com_android_internal_net_NetworkUtilsInternal),
-        REG_JNI(register_com_android_internal_os_ClassLoaderFactory),
-        REG_JNI(register_com_android_internal_os_LongArrayMultiStateCounter),
-        REG_JNI(register_com_android_internal_os_LongMultiStateCounter),
-        REG_JNI(register_com_android_internal_os_Zygote),
-        REG_JNI(register_com_android_internal_os_ZygoteCommandBuffer),
-        REG_JNI(register_com_android_internal_os_ZygoteInit),
-        REG_JNI(register_com_android_internal_security_VerityUtils),
         REG_JNI(register_com_android_internal_util_VirtualRefBasePtr),
-        REG_JNI(register_android_hardware_Camera),
-        REG_JNI(register_android_hardware_camera2_CameraMetadata),
-        REG_JNI(register_android_hardware_camera2_DngCreator),
-        REG_JNI(register_android_hardware_camera2_impl_CameraExtensionJpegProcessor),
-        REG_JNI(register_android_hardware_camera2_utils_SurfaceUtils),
-        REG_JNI(register_android_hardware_display_DisplayManagerGlobal),
-        REG_JNI(register_android_hardware_HardwareBuffer),
-        REG_JNI(register_android_hardware_OverlayProperties),
-        REG_JNI(register_android_hardware_SensorManager),
-        REG_JNI(register_android_hardware_SerialPort),
-        REG_JNI(register_android_hardware_SyncFence),
-        REG_JNI(register_android_hardware_UsbDevice),
-        REG_JNI(register_android_hardware_UsbDeviceConnection),
-        REG_JNI(register_android_hardware_UsbRequest),
-        REG_JNI(register_android_hardware_location_ActivityRecognitionHardware),
-        REG_JNI(register_android_media_AudioDeviceAttributes),
-        REG_JNI(register_android_media_AudioEffectDescriptor),
-        REG_JNI(register_android_media_AudioSystem),
-        REG_JNI(register_android_media_AudioRecord),
-        REG_JNI(register_android_media_AudioTrack),
-        REG_JNI(register_android_media_AudioAttributes),
-        REG_JNI(register_android_media_AudioProductStrategies),
-        REG_JNI(register_android_media_AudioVolumeGroups),
-        REG_JNI(register_android_media_AudioVolumeGroupChangeHandler),
-        REG_JNI(register_android_media_MediaMetrics),
-        REG_JNI(register_android_media_MicrophoneInfo),
-        REG_JNI(register_android_media_RemoteDisplay),
-        REG_JNI(register_android_media_ToneGenerator),
-        REG_JNI(register_android_media_audio_common_AidlConversion),
-        REG_JNI(register_android_media_midi),
-
-        REG_JNI(register_android_opengl_classes),
-        REG_JNI(register_android_ddm_DdmHandleNativeHeap),
-        REG_JNI(register_android_backup_BackupDataInput),
-        REG_JNI(register_android_backup_BackupDataOutput),
-        REG_JNI(register_android_backup_FileBackupHelperBase),
-        REG_JNI(register_android_backup_BackupHelperDispatcher),
-        REG_JNI(register_android_app_backup_FullBackup),
-        REG_JNI(register_android_app_Activity),
-        REG_JNI(register_android_app_ActivityThread),
-        REG_JNI(register_android_app_NativeActivity),
-        REG_JNI(register_android_util_jar_StrictJarFile),
-        REG_JNI(register_android_view_InputChannel),
-        REG_JNI(register_android_view_InputEventReceiver),
-        REG_JNI(register_android_view_InputEventSender),
-        REG_JNI(register_android_view_InputQueue),
+        // REG_JNI(register_android_util_jar_StrictJarFile),
         REG_JNI(register_android_view_KeyEvent),
         REG_JNI(register_android_view_MotionEvent),
-        REG_JNI(register_android_view_MotionPredictor),
-        REG_JNI(register_android_view_PointerIcon),
         REG_JNI(register_android_view_VelocityTracker),
-        REG_JNI(register_android_view_VerifiedKeyEvent),
-        REG_JNI(register_android_view_VerifiedMotionEvent),
-
-        REG_JNI(register_android_content_res_ObbScanner),
-        REG_JNI(register_android_content_res_Configuration),
-
         REG_JNI(register_android_animation_PropertyValuesHolder),
-        REG_JNI(register_android_security_Scrypt),
-        REG_JNI(register_com_android_internal_content_F2fsUtils),
-        REG_JNI(register_com_android_internal_content_NativeLibraryHelper),
-        REG_JNI(register_com_android_internal_os_FuseAppLoop),
-        REG_JNI(register_com_android_internal_os_KernelAllocationStats),
-        REG_JNI(register_com_android_internal_os_KernelCpuBpfTracking),
-        REG_JNI(register_com_android_internal_os_KernelCpuTotalBpfMapReader),
-        REG_JNI(register_com_android_internal_os_KernelCpuUidBpfMapReader),
-        REG_JNI(register_com_android_internal_os_KernelSingleProcessCpuThreadReader),
-        REG_JNI(register_com_android_internal_os_KernelSingleUidTimeReader),
-
-        REG_JNI(register_android_window_WindowInfosListener),
-        REG_JNI(register_android_window_ScreenCapture),
-        REG_JNI(register_jni_common),
-
-        REG_JNI(register_android_tracing_PerfettoDataSource),
-        REG_JNI(register_android_tracing_PerfettoDataSourceInstance),
-        REG_JNI(register_android_tracing_PerfettoProducer),
+        REG_JNI(register_android_graphics_Region),
+        REG_JNI(register_android_view_LayoutlibRenderer),
+        REG_JNI(register_android_view_Surface),
+        REG_JNI(register_android_view_ThreadedRenderer),
+        REG_JNI(register_android_graphics_Bitmap),
+        REG_JNI(register_android_graphics_BitmapFactory),
+        REG_JNI(register_android_graphics_ByteBufferStreamAdaptor),
+        REG_JNI(register_android_graphics_CreateJavaOutputStreamAdaptor),
+        REG_JNI(register_android_graphics_Graphics),
+        REG_JNI(register_android_graphics_ImageDecoder),
+        REG_JNI(register_android_graphics_Interpolator),
+        REG_JNI(register_android_graphics_MaskFilter),
+        REG_JNI(register_android_graphics_NinePatch),
+        REG_JNI(register_android_graphics_PathEffect),
+        REG_JNI(register_android_graphics_Shader),
+        REG_JNI(register_android_graphics_RenderEffect),
+        REG_JNI(register_android_graphics_Typeface),
+        REG_JNI(register_android_graphics_Canvas),
+        REG_JNI(register_android_graphics_ColorFilter),
+        REG_JNI(register_android_graphics_ColorSpace),
+        REG_JNI(register_android_graphics_DrawFilter),
+        REG_JNI(register_android_graphics_FontFamily),
+        REG_JNI(register_android_graphics_Matrix),
+        REG_JNI(register_android_graphics_Paint),
+        REG_JNI(register_android_graphics_Path),
+        REG_JNI(register_android_graphics_PathMeasure),
+        REG_JNI(register_android_graphics_Picture),
+        REG_JNI(register_android_graphics_animation_NativeInterpolatorFactory),
+        REG_JNI(register_android_graphics_animation_RenderNodeAnimator),
+        REG_JNI(register_android_graphics_drawable_AnimatedVectorDrawable),
+        REG_JNI(register_android_graphics_drawable_VectorDrawable),
+        REG_JNI(register_android_graphics_fonts_Font),
+        REG_JNI(register_android_graphics_fonts_FontFamily),
+        REG_JNI(register_android_graphics_text_LineBreaker),
+        REG_JNI(register_android_graphics_text_MeasuredText),
+        REG_JNI(register_android_util_PathParser),
+        REG_JNI(register_android_view_RenderNode),
+        REG_JNI(register_android_view_DisplayListCanvas),
+        REG_JNI(register_android_graphics_text_TextShaper),
+        REG_JNI(register_android_text_Hyphenator),
+
+        // 
 };
 
 /*
@@ -1693,7 +602,7 @@ static const RegJNIRec gRegJNI[] = {
      */
     androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);
 
-    ALOGV("--- registering native functions ---\n");
+    ALOGE("--- registering native functions ---\n");
 
     /*
      * Every "register" function calls one or more things that return
@@ -1726,4 +635,5 @@ AndroidRuntime* AndroidRuntime::getRuntime()
 extern "C" jint registerFrameworkNatives(JNIEnv* env) {
     return register_jni_procs(gRegJNI, NELEM(gRegJNI), env);
 }
+
 }   // namespace android
diff --git a/core/jni/LayoutlibLoader.cpp b/core/jni/LayoutlibLoader.cpp
index d5f17da0a072..0c41ad926002 100644
--- a/core/jni/LayoutlibLoader.cpp
+++ b/core/jni/LayoutlibLoader.cpp
@@ -174,6 +174,7 @@ int AndroidRuntime::registerNativeMethods(JNIEnv* env,
     return jniRegisterNativeMethods(env, className, gMethods, numMethods);
 }
 
+#if 0
 JNIEnv* AndroidRuntime::getJNIEnv() {
     JNIEnv* env;
     if (javaVM->GetEnv((void**) &env, JNI_VERSION_1_6) != JNI_OK)
@@ -184,6 +185,7 @@ JNIEnv* AndroidRuntime::getJNIEnv() {
 JavaVM* AndroidRuntime::getJavaVM() {
     return javaVM;
 }
+#endif
 
 static vector<string> parseCsv(const string& csvString) {
     vector<string>   result;
@@ -323,7 +325,8 @@ static bool init_icu(const char* dataPath) {
     return true;
 }
 
-// Creates an array of InputDevice from key character map files
+#if 0
+Creates an array of InputDevice from key character map files
 static void init_keyboard(JNIEnv* env, const vector<string>& keyboardPaths) {
     jclass inputDevice = FindClassOrDie(env, "android/view/InputDevice");
     jobjectArray inputDevicesArray =
@@ -357,6 +360,7 @@ static void init_keyboard(JNIEnv* env, const vector<string>& keyboardPaths) {
     env->CallStaticVoidMethod(bridge, setInputManager, inputDevicesArray);
     env->DeleteLocalRef(inputDevicesArray);
 }
+#endif
 
 } // namespace android
 
@@ -472,7 +476,7 @@ JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void*) {
 
     // Use English locale for number format to ensure correct parsing of floats when using strtof
     setlocale(LC_NUMERIC, "en_US.UTF-8");
-
+#if 0
     auto keyboardPathsJString =
             (jstring)env->CallStaticObjectMethod(system, getPropertyMethod,
                                                  env->NewStringUTF("keyboard_paths"),
@@ -485,7 +489,7 @@ JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void*) {
         fprintf(stderr, "Skip initializing keyboard\n");
     }
     env->ReleaseStringUTFChars(keyboardPathsJString, keyboardPathsString);
-
+#endif
     return JNI_VERSION_1_6;
 }
 
diff --git a/core/jni/android_text_Hyphenator.cpp b/core/jni/android_text_Hyphenator.cpp
index b6bf617b40ae..24746e5fd2f6 100644
--- a/core/jni/android_text_Hyphenator.cpp
+++ b/core/jni/android_text_Hyphenator.cpp
@@ -15,20 +15,44 @@
  */
 
 #include <fcntl.h>
+#ifdef __ANDROID__
 #include <sys/mman.h>
+#else
+#include <android-base/mapped_file.h>
+#endif
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <unistd.h>
 
 #include <algorithm>
+#include <string>
 
 #include <core_jni_helpers.h>
 #include <minikin/Hyphenator.h>
 
 namespace android {
 
+static std::string hyphenDataDir = "";
+// returns result from android.os.SystemProperties.get
+static std::string getJavaProperty(JNIEnv* env, const char* property_name,
+                                   const char* defaultValue = "") {
+    jclass system = FindClassOrDie(env, "android/os/SystemProperties");
+    jmethodID getPropertyMethod =
+            GetStaticMethodIDOrDie(env, system, "get",
+                                   "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");
+    auto jString = (jstring)env->CallStaticObjectMethod(system, getPropertyMethod,
+                                                        env->NewStringUTF(property_name),
+                                                        env->NewStringUTF(defaultValue));
+    ScopedUtfChars chars(env, jString);
+    return std::string(chars.c_str());
+}
+
 static std::string buildFileName(const std::string& locale) {
+#ifdef __ANDROID__
     constexpr char SYSTEM_HYPHENATOR_PREFIX[] = "/system/usr/hyphen-data/hyph-";
+#else
+    std::string SYSTEM_HYPHENATOR_PREFIX = hyphenDataDir + "/hyph-";
+#endif
     constexpr char SYSTEM_HYPHENATOR_SUFFIX[] = ".hyb";
     std::string lowerLocale;
     lowerLocale.reserve(locale.size());
@@ -49,12 +73,23 @@ static const uint8_t* mmapPatternFile(const std::string& locale) {
         return nullptr;
     }
 
+#ifdef __ANDROID__
     void* ptr = mmap(nullptr, st.st_size, PROT_READ, MAP_SHARED, fd, 0 /* offset */);
     close(fd);
     if (ptr == MAP_FAILED) {
         return nullptr;
     }
     return reinterpret_cast<const uint8_t*>(ptr);
+#else
+    std::unique_ptr<base::MappedFile> patternFile =
+            base::MappedFile::FromFd(fd, 0, st.st_size, PROT_READ);
+    close(fd);
+    if (patternFile == nullptr) {
+        return nullptr;
+    }
+    auto* mappedPtr = new base::MappedFile(std::move(*patternFile));
+    return reinterpret_cast<const uint8_t*>(mappedPtr->data());
+#endif
 }
 
 static void addHyphenatorWithoutPatternFile(const std::string& locale, int minPrefix,
@@ -77,7 +112,11 @@ static void addHyphenatorAlias(const std::string& from, const std::string& to) {
     minikin::addHyphenatorAlias(from, to);
 }
 
-static void init() {
+static void init(JNIEnv* env) {
+    hyphenDataDir = getJavaProperty(env, "ro.hyphen.data.dir", "");
+    if (hyphenDataDir.empty()) {
+        jniThrowRuntimeException(env, "The system property ro.hyphen.data.dir is not set");
+    }
     // TODO: Confirm that these are the best values. Various sources suggest (1, 1), but that
     // appears too small.
     constexpr int INDIC_MIN_PREFIX = 2;
diff --git a/core/jni/android_view_LayoutlibRenderer.cpp b/core/jni/android_view_LayoutlibRenderer.cpp
new file mode 100755
index 000000000000..883d4ee590b3
--- /dev/null
+++ b/core/jni/android_view_LayoutlibRenderer.cpp
@@ -0,0 +1,199 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "LayoutlibRenderer"
+#define LOG_NDEBUG 1
+
+#include <gui/BufferQueue.h>
+#include <gui/IGraphicBufferConsumer.h>
+#include <gui/IGraphicBufferProducer.h>
+#include <ui/GraphicBuffer.h>
+
+#include "android_runtime/android_view_Surface.h"
+#include "core_jni_helpers.h"
+#include "jni.h"
+#include <utils/Log.h>
+#include <android_runtime/Log.h>
+#include <log/log_main.h>
+#include <android-base/logging.h>
+#include <android-base/properties.h>
+JNIEnv* mEnv;
+static jclass bridge;
+static jclass layoutLog;
+static jmethodID getLogId;
+static jmethodID logMethodId;
+
+namespace android {
+
+jfieldID gNativeContextFieldId;
+
+void RLayoutlibLogger(base::LogId, base::LogSeverity severity, const char* tag, const char* file,
+                     unsigned int line, const char* message) {
+    JNIEnv* env = mEnv;
+    jint logPrio = severity;
+    jstring tagString = env->NewStringUTF(tag);
+    jstring messageString = env->NewStringUTF(message);
+
+    jobject bridgeLog = env->CallStaticObjectMethod(bridge, getLogId);
+
+    env->CallVoidMethod(bridgeLog, logMethodId, logPrio, tagString, messageString);
+
+    env->DeleteLocalRef(tagString);
+    env->DeleteLocalRef(messageString);
+    env->DeleteLocalRef(bridgeLog);
+}
+
+void RLayoutlibAborter(const char* abort_message) {
+    // Layoutlib should not call abort() as it would terminate Studio.
+    // Throw an exception back to Java instead.
+    JNIEnv* env = mEnv;
+    jniThrowRuntimeException(env, "The Android framework has encountered a fatal error xd");
+}
+
+/**
+ * Class to store information needed by the Layoutlib renderer
+ */
+class JNILayoutlibRendererContext : public RefBase {
+public:
+    void onFirstRef() {
+    }
+    void onLastStrongRef(const void* id) {
+
+    }
+    bool onIncStrongAttempted(uint32_t flags, const void* id) {
+        return false;
+    }
+    void onLastWeakRef(const void* id) {
+
+    }
+    ~JNILayoutlibRendererContext() override {
+        if (mBufferConsumer != nullptr) {
+            mBufferConsumer.clear();
+        }
+    }
+
+    void setBufferConsumer(const sp<IGraphicBufferConsumer>& consumer) {
+        mBufferConsumer = consumer;
+    }
+
+    IGraphicBufferConsumer* getBufferConsumer() {
+        return mBufferConsumer.get();
+    }
+
+private:
+    sp<IGraphicBufferConsumer> mBufferConsumer;
+};
+
+static jobject android_view_LayoutlibRenderer_createSurface(JNIEnv* env, jobject thiz) {
+
+    sp<IGraphicBufferProducer> gbProducer;
+    sp<IGraphicBufferConsumer> gbConsumer;
+    BufferQueue::createBufferQueue(&gbProducer, &gbConsumer);
+
+    // // Save the IGraphicBufferConsumer in the context so that it can be reused for buffer creation
+    sp<JNILayoutlibRendererContext> newCtx = sp<JNILayoutlibRendererContext>::make();
+
+    newCtx->setBufferConsumer(gbConsumer);
+    auto* const currentCtx = reinterpret_cast<JNILayoutlibRendererContext*>(
+            env->GetLongField(thiz, gNativeContextFieldId));
+    if (newCtx != nullptr) {
+        // Create a strong reference to the new context to avoid it being destroyed
+        newCtx->incStrong((void*)android_view_LayoutlibRenderer_createSurface);
+    }
+    if (currentCtx != nullptr) {
+        // Delete the reference to the previous context as it is not needed and can be destroyed
+        currentCtx->decStrong((void*)android_view_LayoutlibRenderer_createSurface);
+    }
+    env->SetLongField(thiz, gNativeContextFieldId, reinterpret_cast<jlong>(newCtx.get()));
+    return android_view_Surface_createFromIGraphicBufferProducer(env, gbProducer);
+}
+
+static jobject android_view_LayoutlibRenderer_createBuffer(JNIEnv* env, jobject thiz, jint width,
+                                                           jint height) {
+    auto* ctx = reinterpret_cast<JNILayoutlibRendererContext*>(env->GetLongField(thiz, gNativeContextFieldId));
+    if (ctx == nullptr) {
+        jniThrowException(env, "java/lang/IllegalStateException", "No Rendener has been created");
+        return nullptr;
+    }
+
+    // if (width <= 0 || height <= 0) {
+    //     width = 512;
+    //     height = 1024;
+    //     jniThrowException(env, "java/lang/IllegalStateException", "No width-height has been created");
+    // }
+
+    IGraphicBufferConsumer* bufferConsumer = ctx->getBufferConsumer();
+    bufferConsumer->setDefaultBufferSize(width, height);
+    auto* bufferItem = new BufferItem();
+    bufferConsumer->acquireBuffer(bufferItem, 0);
+    sp<GraphicBuffer> buffer = bufferItem->mGraphicBuffer;
+    delete bufferItem;
+
+    int bytesPerPixel = 4;
+    uint32_t dataSize = buffer->getStride() * buffer->getHeight() * bytesPerPixel;
+
+    void* pData = nullptr;
+    buffer->lockAsync(0, Rect::EMPTY_RECT, &pData, 0);
+    // if (dataSize == 0) {
+    //     dataSize = 3 * 512 * bytesPerPixel;
+    //     jniThrowException(env, "java/lang/IllegalStateException", "No dataSize has been created");
+    // }
+
+    // if (pData == nullptr) {
+    //     jniThrowException(env, "java/lang/IllegalStateException", "pData No surface has been created");
+    //     return nullptr;
+    // }
+    jobject byteBuffer = env->NewDirectByteBuffer(pData, dataSize);
+    return byteBuffer;
+}
+
+static void android_view_LayoutlibRenderer_destroy(JNIEnv* env, jobject thiz) {
+    auto* const currentCtx = reinterpret_cast<JNILayoutlibRendererContext*>(
+            env->GetLongField(thiz, gNativeContextFieldId));
+    if (currentCtx != nullptr) {
+        IGraphicBufferConsumer* bufferConsumer = currentCtx->getBufferConsumer();
+        bufferConsumer->detachBuffer(0);
+        currentCtx->decStrong((void*)android_view_LayoutlibRenderer_createSurface);
+    }
+    env->SetLongField(thiz, gNativeContextFieldId, 0);
+}
+
+static const JNINativeMethod gMethods[] = {
+        {"nativeCreateSurface", "()Landroid/view/Surface;",
+         (void*)android_view_LayoutlibRenderer_createSurface},
+        {"nativeCreateBuffer", "(II)Ljava/nio/ByteBuffer;",
+         (void*)android_view_LayoutlibRenderer_createBuffer},
+        {"nativeDestroy", "()V", (void*)android_view_LayoutlibRenderer_destroy},
+};
+
+int register_android_view_LayoutlibRenderer(JNIEnv* env) {
+
+    jclass layoutlibRendererClass = FindClassOrDie(env, "android/view/LayoutlibRenderer");
+    gNativeContextFieldId = GetFieldIDOrDie(env, layoutlibRendererClass, "mNativeContext", "J");
+
+    layoutLog = FindClassOrDie(env, "com/android/ide/common/rendering/api/ILayoutLog");
+    layoutLog = MakeGlobalRefOrDie(env, layoutLog);
+    logMethodId = GetMethodIDOrDie(env, layoutLog, "logAndroidFramework",
+                                   "(ILjava/lang/String;Ljava/lang/String;)V");
+    bridge = FindClassOrDie(env, "com/android/layoutlib/bridge/Bridge");
+    bridge = MakeGlobalRefOrDie(env, bridge);
+    getLogId = GetStaticMethodIDOrDie(env, bridge, "getLog",
+                                      "()Lcom/android/ide/common/rendering/api/ILayoutLog;");
+
+    return RegisterMethodsOrDie(env, "android/view/LayoutlibRenderer", gMethods, NELEM(gMethods));
+}
+
+} // namespace android
diff --git a/core/jni/android_view_Surface.cpp b/core/jni/android_view_Surface.cpp
index 869b53df2837..5bc61295f91b 100644
--- a/core/jni/android_view_Surface.cpp
+++ b/core/jni/android_view_Surface.cpp
@@ -27,15 +27,23 @@
 #include <android_runtime/android_graphics_SurfaceTexture.h>
 #include <android_runtime/android_view_Surface.h>
 #include <android_runtime/Log.h>
+#ifdef __ANDROID__ // host does not support hardware buffer
 #include <private/android/AHardwareBufferHelpers.h>
+#endif
 
 #include "android_os_Parcel.h"
+#ifdef __ANDROID__ // host does not support Parcel
 #include <binder/Parcel.h>
+#endif
 
+#ifdef __ANDROID__ // host does not support BufferQueue
 #include <gui/BLASTBufferQueue.h>
+#endif
 #include <gui/Surface.h>
+#ifdef __ANDROID__ // host does not support SurfaceControl
 #include <gui/SurfaceControl.h>
 #include <gui/view/Surface.h>
+#endif
 
 #include <ui/GraphicBuffer.h>
 #include <ui/Rect.h>
@@ -51,6 +59,7 @@
 namespace android {
 
 static const char* const IllegalArgumentException = "java/lang/IllegalArgumentException";
+
 static const char* const OutOfResourcesException = "android/view/Surface$OutOfResourcesException";
 
 static struct {
@@ -67,6 +76,7 @@ static struct {
     jfieldID bottom;
 } gRectClassInfo;
 
+#ifdef __ANDROID__ // host does not support Dataspace HAL
 class JNamedColorSpace {
 public:
     // ColorSpace.Named.SRGB.ordinal() = 0;
@@ -84,6 +94,7 @@ constexpr ui::Dataspace fromNamedColorSpaceValueToDataspace(const jint colorSpac
             return ui::Dataspace::V0_SRGB;
     }
 }
+#endif
 
 // ----------------------------------------------------------------------------
 
@@ -146,6 +157,7 @@ static inline bool isSurfaceValid(const sp<Surface>& sur) {
 
 static jlong nativeCreateFromSurfaceTexture(JNIEnv* env, jclass clazz,
         jobject surfaceTextureObj) {
+#ifdef __ANDROID__ // host does not support SurfaceTexture
     sp<IGraphicBufferProducer> producer(SurfaceTexture_getProducer(env, surfaceTextureObj));
     if (producer == NULL) {
         jniThrowException(env, IllegalArgumentException,
@@ -161,6 +173,9 @@ static jlong nativeCreateFromSurfaceTexture(JNIEnv* env, jclass clazz,
 
     surface->incStrong(&sRefBaseOwner);
     return jlong(surface.get());
+#else
+    return 0;
+#endif
 }
 
 static void nativeRelease(JNIEnv* env, jclass clazz, jlong nativeObject) {
@@ -272,17 +287,22 @@ static void nativeAllocateBuffers(JNIEnv* /* env */ , jclass /* clazz */,
 
 static jlong nativeCreateFromSurfaceControl(JNIEnv* env, jclass clazz,
         jlong surfaceControlNativeObj) {
+#ifdef __ANDROID__ // hoost does not support Parcel
     sp<SurfaceControl> ctrl(reinterpret_cast<SurfaceControl *>(surfaceControlNativeObj));
     sp<Surface> surface(ctrl->createSurface());
     if (surface != NULL) {
         surface->incStrong(&sRefBaseOwner);
     }
     return reinterpret_cast<jlong>(surface.get());
+#else
+    return 0;
+#endif
 }
 
 static jlong nativeGetFromSurfaceControl(JNIEnv* env, jclass clazz,
         jlong nativeObject,
         jlong surfaceControlNativeObj) {
+#ifdef __ANDROID__ // host does not support Parcel
     Surface* self(reinterpret_cast<Surface *>(nativeObject));
     sp<SurfaceControl> ctrl(reinterpret_cast<SurfaceControl *>(surfaceControlNativeObj));
 
@@ -299,10 +319,14 @@ static jlong nativeGetFromSurfaceControl(JNIEnv* env, jclass clazz,
     }
 
     return reinterpret_cast<jlong>(surface.get());
+#else
+    return 0;
+#endif
 }
 
 static jlong nativeGetFromBlastBufferQueue(JNIEnv* env, jclass clazz, jlong nativeObject,
                                            jlong blastBufferQueueNativeObj) {
+#ifdef __ANDROID__ // host does not support BufferQueue
     Surface* self(reinterpret_cast<Surface*>(nativeObject));
     sp<BLASTBufferQueue> queue = reinterpret_cast<BLASTBufferQueue*>(blastBufferQueueNativeObj);
     const sp<IGraphicBufferProducer>& bufferProducer = queue->getIGraphicBufferProducer();
@@ -319,10 +343,14 @@ static jlong nativeGetFromBlastBufferQueue(JNIEnv* env, jclass clazz, jlong nati
     }
 
     return reinterpret_cast<jlong>(surface.get());
+#else
+    return 0;
+#endif
 }
 
 static jlong nativeReadFromParcel(JNIEnv* env, jclass clazz,
         jlong nativeObject, jobject parcelObj) {
+#ifdef __ANDROID__ // host does not support Parcel
     Parcel* parcel = parcelForJavaObject(env, parcelObj);
     if (parcel == NULL) {
         jniThrowNullPointerException(env, NULL);
@@ -361,10 +389,14 @@ static jlong nativeReadFromParcel(JNIEnv* env, jclass clazz,
     }
 
     return jlong(sur.get());
+#else
+    return 0;
+#endif
 }
 
 static void nativeWriteToParcel(JNIEnv* env, jclass clazz,
         jlong nativeObject, jobject parcelObj) {
+#ifdef __ANDROID__ // host does not support Parcel
     Parcel* parcel = parcelForJavaObject(env, parcelObj);
     if (parcel == NULL) {
         jniThrowNullPointerException(env, NULL);
@@ -379,6 +411,7 @@ static void nativeWriteToParcel(JNIEnv* env, jclass clazz,
     // Calling code in Surface.java has already written the name of the Surface
     // to the Parcel
     surfaceShim.writeToParcel(parcel, /*nameAlreadyWritten*/true);
+#endif
 }
 
 static jint nativeGetWidth(JNIEnv* env, jclass clazz, jlong nativeObject) {
@@ -414,6 +447,7 @@ static jint nativeForceScopedDisconnect(JNIEnv *env, jclass clazz, jlong nativeO
 
 static jint nativeAttachAndQueueBufferWithColorSpace(JNIEnv* env, jclass clazz, jlong nativeObject,
                                                      jobject hardwareBuffer, jint colorSpaceId) {
+#ifdef __ANDROID__ // host does not need this (no shadows)
     Surface* surface = reinterpret_cast<Surface*>(nativeObject);
     AHardwareBuffer* ahb =
             android_hardware_HardwareBuffer_getNativeHardwareBuffer(env, hardwareBuffer);
@@ -421,6 +455,9 @@ static jint nativeAttachAndQueueBufferWithColorSpace(JNIEnv* env, jclass clazz,
     int err = Surface::attachAndQueueBufferWithDataspace(surface, gb,
             fromNamedColorSpaceValueToDataspace(colorSpaceId));
     return err;
+#else
+    return -1;
+#endif
 }
 
 static jint nativeSetSharedBufferModeEnabled(JNIEnv* env, jclass clazz, jlong nativeObject,
diff --git a/core/jni/include/android_runtime/AndroidRuntime.h b/core/jni/include/android_runtime/AndroidRuntime.h
index bf2ba772c39d..44923a56de25 100644
--- a/core/jni/include/android_runtime/AndroidRuntime.h
+++ b/core/jni/include/android_runtime/AndroidRuntime.h
@@ -78,6 +78,7 @@ public:
      * to use CLASSPATH.
      */
     virtual void onVmCreated(JNIEnv* env);
+    virtual void onJavaVmCreated(JavaVM* vm);
 
     /**
      * This gets called after the JavaVM has initialized.  Override it
diff --git a/libs/hostgraphics/ANativeWindow.cpp b/libs/hostgraphics/ANativeWindow.cpp
new file mode 100755
index 000000000000..442a49ae48dd
--- /dev/null
+++ b/libs/hostgraphics/ANativeWindow.cpp
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Host implementation of ANativeWindow interface
+#include <system/window.h>
+
+static int32_t query(ANativeWindow* window, int what) {
+    int value;
+    int res = window->query(window, what, &value);
+    return res < 0 ? res : value;
+}
+
+static int64_t query64(ANativeWindow* window, int what) {
+    int64_t value;
+    int res = window->perform(window, what, &value);
+    return res < 0 ? res : value;
+}
+
+int ANativeWindow_setCancelBufferInterceptor(ANativeWindow* window,
+                                             ANativeWindow_cancelBufferInterceptor interceptor,
+                                             void* data) {
+    return window->perform(window, NATIVE_WINDOW_SET_CANCEL_INTERCEPTOR, interceptor, data);
+}
+
+int ANativeWindow_setDequeueBufferInterceptor(ANativeWindow* window,
+                                              ANativeWindow_dequeueBufferInterceptor interceptor,
+                                              void* data) {
+    return window->perform(window, NATIVE_WINDOW_SET_DEQUEUE_INTERCEPTOR, interceptor, data);
+}
+
+int ANativeWindow_setQueueBufferInterceptor(ANativeWindow* window,
+                                            ANativeWindow_queueBufferInterceptor interceptor,
+                                            void* data) {
+    return window->perform(window, NATIVE_WINDOW_SET_QUEUE_INTERCEPTOR, interceptor, data);
+}
+
+int ANativeWindow_setPerformInterceptor(ANativeWindow* window,
+                                        ANativeWindow_performInterceptor interceptor, void* data) {
+    return window->perform(window, NATIVE_WINDOW_SET_PERFORM_INTERCEPTOR, interceptor, data);
+}
+
+int ANativeWindow_dequeueBuffer(ANativeWindow* window, ANativeWindowBuffer** buffer, int* fenceFd) {
+    return window->dequeueBuffer(window, buffer, fenceFd);
+}
+
+int ANativeWindow_cancelBuffer(ANativeWindow* window, ANativeWindowBuffer* buffer, int fenceFd) {
+    return window->cancelBuffer(window, buffer, fenceFd);
+}
+
+int ANativeWindow_setDequeueTimeout(ANativeWindow* window, int64_t timeout) {
+    return window->perform(window, NATIVE_WINDOW_SET_DEQUEUE_TIMEOUT, timeout);
+}
+
+// extern "C", so that it can be used outside libhostgraphics (in host hwui/.../CanvasContext.cpp)
+extern "C" void ANativeWindow_tryAllocateBuffers(ANativeWindow* window) {
+    if (!window || !query(window, NATIVE_WINDOW_IS_VALID)) {
+        return;
+    }
+    window->perform(window, NATIVE_WINDOW_ALLOCATE_BUFFERS);
+}
+
+int64_t ANativeWindow_getLastDequeueStartTime(ANativeWindow* window) {
+    return query64(window, NATIVE_WINDOW_GET_LAST_DEQUEUE_START);
+}
+
+int64_t ANativeWindow_getLastDequeueDuration(ANativeWindow* window) {
+    return query64(window, NATIVE_WINDOW_GET_LAST_DEQUEUE_DURATION);
+}
+
+int64_t ANativeWindow_getLastQueueDuration(ANativeWindow* window) {
+    return query64(window, NATIVE_WINDOW_GET_LAST_QUEUE_DURATION);
+}
+
+int32_t ANativeWindow_getWidth(ANativeWindow* window) {
+    return query(window, NATIVE_WINDOW_WIDTH);
+}
+
+int32_t ANativeWindow_getHeight(ANativeWindow* window) {
+    return query(window, NATIVE_WINDOW_HEIGHT);
+}
+
+int32_t ANativeWindow_getFormat(ANativeWindow* window) {
+    return query(window, NATIVE_WINDOW_FORMAT);
+}
+
+void ANativeWindow_acquire(ANativeWindow* window) {
+    // incStrong/decStrong token must be the same, doesn't matter what it is
+    window->incStrong((void*)ANativeWindow_acquire);
+}
+
+void ANativeWindow_release(ANativeWindow* window) {
+    // incStrong/decStrong token must be the same, doesn't matter what it is
+    window->decStrong((void*)ANativeWindow_acquire);
+}
diff --git a/libs/hostgraphics/Android.bp b/libs/hostgraphics/Android.bp
index 4407af68de99..5c7b8dc729fd 100644
--- a/libs/hostgraphics/Android.bp
+++ b/libs/hostgraphics/Android.bp
@@ -7,22 +7,37 @@ package {
     default_applicable_licenses: ["frameworks_base_license"],
 }
 
+cc_library_headers {
+    name: "libhostgraphics_headers",
+    export_include_dirs: ["."],
+    host_supported: true,
+    target: {
+        windows: {
+            enabled: true,
+        },
+    },
+}
+
 cc_library_host_static {
     name: "libhostgraphics",
 
     cflags: [
         "-Wno-unused-parameter",
+        "-D__INTRODUCED_IN(n)=",
     ],
 
     static_libs: [
         "libbase",
         "libmath",
         "libutils",
+        "libui-types",
     ],
 
     srcs: [
+        ":framework_native_aidl",
         ":libui_host_common",
         "ADisplay.cpp",
+        "ANativeWindow.cpp",
         "Fence.cpp",
         "HostBufferQueue.cpp",
         "PublicFormat.cpp",
@@ -33,16 +48,13 @@ cc_library_host_static {
         // When frameworks/native/include will be removed from the list of automatic includes.
         // We will have to copy necessary headers with a pre-build step (generated headers).
         ".",
+        "frameworks/native/libs/nativebase/include",
+        "frameworks/native/libs/nativewindow/include",
+        "frameworks/native/libs/nativedisplay/include",
         "frameworks/native/libs/arect/include",
         "frameworks/native/libs/ui/include_private",
+        "frameworks/native/libs/ui/include",
     ],
-
-    header_libs: [
-        "libnativebase_headers",
-        "libnativedisplay_headers",
-        "libnativewindow_headers",
-    ],
-
     export_include_dirs: ["."],
 
     target: {
diff --git a/libs/hostgraphics/HostBufferQueue.cpp b/libs/hostgraphics/HostBufferQueue.cpp
index ec304378c6c4..ad925d57a39c 100644
--- a/libs/hostgraphics/HostBufferQueue.cpp
+++ b/libs/hostgraphics/HostBufferQueue.cpp
@@ -16,12 +16,15 @@
 
 #include <gui/BufferQueue.h>
 
+#include <system/window.h>
+
 namespace android {
 
 class HostBufferQueue : public IGraphicBufferProducer, public IGraphicBufferConsumer {
 public:
     HostBufferQueue() : mWidth(0), mHeight(0) { }
 
+// Consumer
     virtual status_t setConsumerIsProtected(bool isProtected) { return OK; }
 
     virtual status_t detachBuffer(int slot) { return OK; }
@@ -51,6 +54,27 @@ public:
     virtual status_t setMaxAcquiredBufferCount(int maxAcquiredBuffers) { return OK; }
 
     virtual status_t setConsumerUsageBits(uint64_t usage) { return OK; }
+
+// Producer
+    virtual int query(int what, int* value) {
+        switch(what) {
+            case NATIVE_WINDOW_WIDTH:
+                *value = mWidth;
+                break;
+            case NATIVE_WINDOW_HEIGHT:
+                *value = mHeight;
+                break;
+            default:
+                *value = 0;
+                break;
+        }
+        return OK;
+    }
+
+    virtual status_t requestBuffer(int slot, sp<GraphicBuffer>* buf) {
+        *buf = mBuffer;
+        return OK;
+    }
 private:
     sp<GraphicBuffer> mBuffer;
     uint32_t mWidth;
diff --git a/libs/hostgraphics/gui/IGraphicBufferProducer.h b/libs/hostgraphics/gui/IGraphicBufferProducer.h
index a1efd0bcfa4c..0def5182929b 100644
--- a/libs/hostgraphics/gui/IGraphicBufferProducer.h
+++ b/libs/hostgraphics/gui/IGraphicBufferProducer.h
@@ -19,7 +19,10 @@
 
 #include <utils/RefBase.h>
 
-#include <ui/GraphicBuffer.h>
+#include <ui/Fence.h>
+#include "../ui/GraphicBuffer.h"
+
+#include <utils/Timers.h>
 
 namespace android {
 
@@ -31,6 +34,10 @@ public:
         // Disconnect any API originally connected from the process calling disconnect.
         AllLocal
     };
+
+    virtual int query(int what, int* value) = 0;
+
+    virtual status_t requestBuffer(int slot, sp<GraphicBuffer>* buf) = 0;
 };
 
 } // namespace android
diff --git a/libs/hostgraphics/gui/Surface.h b/libs/hostgraphics/gui/Surface.h
index 2573931c8543..528b7c1a969a 100644
--- a/libs/hostgraphics/gui/Surface.h
+++ b/libs/hostgraphics/gui/Surface.h
@@ -17,9 +17,15 @@
 #ifndef ANDROID_GUI_SURFACE_H
 #define ANDROID_GUI_SURFACE_H
 
+#include <mutex>
+
 #include <gui/IGraphicBufferProducer.h>
 #include <ui/ANativeObjectBase.h>
+
+#include <utils/Condition.h>
+#include <utils/Mutex.h>
 #include <utils/RefBase.h>
+
 #include <system/window.h>
 
 namespace android {
@@ -27,8 +33,10 @@ namespace android {
 class Surface : public ANativeObjectBase<ANativeWindow, Surface, RefBase> {
 public:
     explicit Surface(const sp<IGraphicBufferProducer>& bufferProducer,
-                     bool controlledByApp = false) {
+                     bool controlledByApp = false) : mBufferProducer(bufferProducer) {
         ANativeWindow::perform = hook_perform;
+        ANativeWindow::dequeueBuffer = hook_dequeueBuffer;
+        ANativeWindow::query = hook_query;
     }
     static bool isValid(const sp<Surface>& surface) { return surface != nullptr; }
     void allocateBuffers() {}
@@ -48,19 +56,60 @@ public:
         return 0;
     }
     virtual int unlockAndPost() { return 0; }
-    virtual int query(int what, int* value) const { return 0; }
+    virtual int query(int what, int* value) const { return mBufferProducer->query(what, value); }
+	virtual void destroy() {}
+
+    status_t setDequeueTimeout(nsecs_t timeout) { return OK; }
 
-    virtual void destroy() {}
+    nsecs_t getLastDequeueStartTime() const { return 0; }
+
+    int getBuffersDataSpace() {
+         return 0;
+    }
 
 protected:
     virtual ~Surface() {}
 
-    static int hook_perform(ANativeWindow* window, int operation, ...) { return 0; }
+    static int hook_perform(ANativeWindow* window, int operation, ...) {
+        va_list args;
+        va_start(args, operation);
+        Surface* c = getSelf(window);
+        int result = c->perform(operation, args);
+        va_end(args);
+        return result;
+    }
 
+    static int hook_query(const ANativeWindow* window, int what, int* value) {
+        const Surface* c = getSelf(window);
+        return c->query(what, value);
+    }
+
+    static int hook_dequeueBuffer(ANativeWindow* window,
+            ANativeWindowBuffer** buffer, int* fenceFd) {
+        Surface* c = getSelf(window);
+        return c->dequeueBuffer(buffer, fenceFd);
+    }
+
+    virtual int dequeueBuffer(ANativeWindowBuffer** buffer, int* fenceFd) {
+        mBufferProducer->requestBuffer(0, &mBuffer);
+        *buffer = (ANativeWindowBuffer*) mBuffer.get();
+        return OK;
+    }
+    virtual int cancelBuffer(ANativeWindowBuffer* buffer, int fenceFd) { return 0; }
+    virtual int queueBuffer(ANativeWindowBuffer* buffer, int fenceFd) { return 0; }
+    virtual int perform(int operation, va_list args) { return 0; }
+    virtual int setSwapInterval(int interval) { return 0; }
+
+    virtual int lockBuffer_DEPRECATED(ANativeWindowBuffer* buffer)  { return 0; }
+
+    virtual int setBufferCount(int bufferCount) { return 0; }
 private:
     // can't be copied
     Surface& operator=(const Surface& rhs);
     Surface(const Surface& rhs);
+
+    const sp<IGraphicBufferProducer> mBufferProducer;
+    sp<GraphicBuffer> mBuffer;
 };
 
 } // namespace android
diff --git a/libs/hostgraphics/ui/GraphicBuffer.h b/libs/hostgraphics/ui/GraphicBuffer.h
index ac88e44dbc65..6a3fd06536a3 100644
--- a/libs/hostgraphics/ui/GraphicBuffer.h
+++ b/libs/hostgraphics/ui/GraphicBuffer.h
@@ -22,17 +22,22 @@
 
 #include <vector>
 
+#include <ui/ANativeObjectBase.h>
 #include <ui/PixelFormat.h>
 #include <ui/Rect.h>
-
 #include <utils/RefBase.h>
 
+#include <nativebase/nativebase.h>
+
 namespace android {
 
-class GraphicBuffer : virtual public RefBase {
+class GraphicBuffer : public ANativeObjectBase<ANativeWindowBuffer, GraphicBuffer, RefBase> {
 public:
     GraphicBuffer(uint32_t w, uint32_t h):width(w),height(h) {
         data.resize(w*h);
+        reserved[0] = data.data();
+        width = w;
+        height = h;
     }
     uint32_t getWidth() const           { return static_cast<uint32_t>(width); }
     uint32_t getHeight() const          { return static_cast<uint32_t>(height); }
diff --git a/libs/hwui/Android.bp b/libs/hwui/Android.bp
index 54f94f5c4b14..533011d25fd5 100644
--- a/libs/hwui/Android.bp
+++ b/libs/hwui/Android.bp
@@ -78,6 +78,7 @@ cc_defaults {
     include_dirs: [
         "external/skia/include/private",
         "external/skia/src/core",
+        "external/skia/src/utils",
     ],
 
     target: {
@@ -95,6 +96,9 @@ cc_defaults {
             ],
             cflags: [
                 "-Wno-unused-variable",
+                // Use all declarations in native_window.h in Layoutlib
+                "-D__INTRODUCED_IN(n)=",
+                "-D__ANDROID_API__=10000",
             ],
         },
     },
@@ -265,6 +269,8 @@ cc_defaults {
     cppflags: ["-Wno-conversion-null"],
 
     srcs: [
+        "apex/android_bitmap.cpp",
+        "apex/android_canvas.cpp",
         "apex/android_matrix.cpp",
         "apex/android_paint.cpp",
         "apex/android_region.cpp",
@@ -276,8 +282,6 @@ cc_defaults {
     target: {
         android: {
             srcs: [ // sources that depend on android only libraries
-                "apex/android_bitmap.cpp",
-                "apex/android_canvas.cpp",
                 "apex/jni_runtime.cpp",
             ],
         },
@@ -336,6 +340,7 @@ cc_defaults {
         "jni/android_graphics_ColorSpace.cpp",
         "jni/android_graphics_drawable_AnimatedVectorDrawable.cpp",
         "jni/android_graphics_drawable_VectorDrawable.cpp",
+        "jni/android_graphics_HardwareRenderer.cpp",
         "jni/android_graphics_HardwareRendererObserver.cpp",
         "jni/android_graphics_Matrix.cpp",
         "jni/android_graphics_Picture.cpp",
@@ -396,6 +401,8 @@ cc_defaults {
         "external/skia/include/private",
         "external/skia/src/codec",
         "external/skia/src/core",
+        "external/skia/src/effects",
+        "external/skia/src/image",
     ],
 
     shared_libs: [
@@ -420,7 +427,6 @@ cc_defaults {
             srcs: [ // sources that depend on android only libraries
                 "jni/AnimatedImageDrawable.cpp",
                 "jni/android_graphics_TextureLayer.cpp",
-                "jni/android_graphics_HardwareRenderer.cpp",
                 "jni/android_graphics_HardwareBufferRenderer.cpp",
                 "jni/GIFMovie.cpp",
                 "jni/GraphicsStatsService.cpp",
@@ -448,6 +454,9 @@ cc_defaults {
             ],
         },
         host: {
+            header_libs: [
+                "libnativebase_headers",
+            ],
             cflags: [
                 "-Wno-unused-const-variable",
                 "-Wno-unused-function",
@@ -531,12 +540,19 @@ cc_defaults {
         "pipeline/skia/BackdropFilterDrawable.cpp",
         "pipeline/skia/HolePunch.cpp",
         "pipeline/skia/SkiaDisplayList.cpp",
+        "pipeline/skia/SkiaHostPipeline.cpp",
+        "pipeline/skia/SkiaPipeline.cpp",
         "pipeline/skia/SkiaRecordingCanvas.cpp",
         "pipeline/skia/StretchMask.cpp",
         "pipeline/skia/RenderNodeDrawable.cpp",
         "pipeline/skia/ReorderBarrierDrawables.cpp",
         "pipeline/skia/TransformCanvas.cpp",
+        "renderstate/RenderState.cpp",
+        "renderthread/CanvasContext.cpp",
+        "renderthread/DrawFrameTask.cpp",
         "renderthread/Frame.cpp",
+        "renderthread/ReliableSurface.cpp",
+        "renderthread/RenderProxy.cpp",
         "renderthread/RenderTask.cpp",
         "renderthread/TimeLord.cpp",
         "hwui/AnimatedImageDrawable.cpp",
@@ -566,6 +582,9 @@ cc_defaults {
         "Gainmap.cpp",
         "Interpolator.cpp",
         "JankTracker.cpp",
+
+        "Layer.cpp",
+        "LayerUpdateQueue.cpp",
         "LightingInfo.cpp",
         "Matrix.cpp",
         "Mesh.cpp",
@@ -582,6 +601,7 @@ cc_defaults {
         "SkiaCanvas.cpp",
         "SkiaInterpolator.cpp",
         "Tonemapper.cpp",
+        "TreeInfo.cpp",
         "VectorDrawable.cpp",
     ],
 
@@ -605,21 +625,15 @@ cc_defaults {
                 "pipeline/skia/ShaderCache.cpp",
                 "pipeline/skia/SkiaMemoryTracer.cpp",
                 "pipeline/skia/SkiaOpenGLPipeline.cpp",
-                "pipeline/skia/SkiaPipeline.cpp",
                 "pipeline/skia/SkiaProfileRenderer.cpp",
                 "pipeline/skia/SkiaVulkanPipeline.cpp",
                 "pipeline/skia/VkFunctorDrawable.cpp",
                 "pipeline/skia/VkInteropFunctorDrawable.cpp",
-                "renderstate/RenderState.cpp",
                 "renderthread/CacheManager.cpp",
-                "renderthread/CanvasContext.cpp",
-                "renderthread/DrawFrameTask.cpp",
                 "renderthread/EglManager.cpp",
-                "renderthread/ReliableSurface.cpp",
                 "renderthread/RenderEffectCapabilityQuery.cpp",
                 "renderthread/VulkanManager.cpp",
                 "renderthread/VulkanSurface.cpp",
-                "renderthread/RenderProxy.cpp",
                 "renderthread/RenderThread.cpp",
                 "renderthread/HintSessionWrapper.cpp",
                 "service/GraphicsStatsService.cpp",
@@ -630,11 +644,8 @@ cc_defaults {
                 "DeferredLayerUpdater.cpp",
                 "HardwareBitmapUploader.cpp",
                 "HWUIProperties.sysprop",
-                "Layer.cpp",
-                "LayerUpdateQueue.cpp",
                 "ProfileDataContainer.cpp",
                 "Readback.cpp",
-                "TreeInfo.cpp",
                 "WebViewFunctorManager.cpp",
                 "protos/graphicsstats.proto",
             ],
@@ -656,13 +667,23 @@ cc_defaults {
                 "platform/host/ProfileDataContainer.cpp",
                 "platform/host/Readback.cpp",
                 "platform/host/WebViewFunctorManager.cpp",
+                "utils/HostColorSpace.cpp",
+            ],
+	    export_static_lib_headers: [
+                "libarect",
             ],
-
             cflags: [
                 "-DHWUI_NULL_GPU",
                 "-DNULL_GPU_MAX_TEXTURE_SIZE=4096",
                 "-Wno-unused-private-field",
             ],
+
+            include_dirs: [
+                ".",
+                "frameworks/native/libs/nativebase/include",
+                "frameworks/native/libs/nativewindow/include",
+                "frameworks/native/libs/nativedisplay/include",
+            ],
         },
     },
 }
diff --git a/libs/hwui/RootRenderNode.cpp b/libs/hwui/RootRenderNode.cpp
index ddbbf58b3071..cc1c2df0040d 100644
--- a/libs/hwui/RootRenderNode.cpp
+++ b/libs/hwui/RootRenderNode.cpp
@@ -48,6 +48,8 @@ private:
     uint32_t mRequestId;
 };
 
+#endif
+
 void RootRenderNode::prepareTree(TreeInfo& info) {
     info.errorHandler = mErrorHandler.get();
 
@@ -236,10 +238,12 @@ void RootRenderNode::detachVectorDrawableAnimator(PropertyValuesAnimatorSet* ani
         // removal is necessary: the end time of animation will not change unless triggered by
         // user events, in which case the already posted listener's id will become stale, and
         // the onFinished callback will then be ignored.
+#ifdef __ANDROID__  // Layoutlib does not support Looper
         sp<FinishAndInvokeListener> message = new FinishAndInvokeListener(anim);
         auto looper = Looper::getForThread();
         LOG_ALWAYS_FATAL_IF(looper == nullptr, "Not on a looper thread?");
         looper->sendMessageDelayed(ms2ns(remainingTimeInMs), message, 0);
+#endif
         anim->clearOneShotListener();
     }
 }
@@ -285,22 +289,5 @@ private:
 AnimationContext* ContextFactoryImpl::createAnimationContext(renderthread::TimeLord& clock) {
     return new AnimationContextBridge(clock, mRootNode);
 }
-#else
-
-void RootRenderNode::prepareTree(TreeInfo& info) {
-    info.errorHandler = mErrorHandler.get();
-    info.updateWindowPositions = true;
-    RenderNode::prepareTree(info);
-    info.updateWindowPositions = false;
-    info.errorHandler = nullptr;
-}
-
-void RootRenderNode::attachAnimatingNode(RenderNode* animatingNode) { }
-
-void RootRenderNode::destroy() { }
-
-void RootRenderNode::addVectorDrawableAnimator(PropertyValuesAnimatorSet* anim) { }
-
-#endif
 
 }  // namespace android::uirenderer
diff --git a/libs/hwui/RootRenderNode.h b/libs/hwui/RootRenderNode.h
index 1d3f5a8a51e0..7a5cda7041ed 100644
--- a/libs/hwui/RootRenderNode.h
+++ b/libs/hwui/RootRenderNode.h
@@ -74,7 +74,6 @@ private:
     void detachVectorDrawableAnimator(PropertyValuesAnimatorSet* anim);
 };
 
-#ifdef __ANDROID__ // Layoutlib does not support Animations
 class ContextFactoryImpl : public IContextFactory {
 public:
     explicit ContextFactoryImpl(RootRenderNode* rootNode) : mRootNode(rootNode) {}
@@ -84,6 +83,5 @@ public:
 private:
     RootRenderNode* mRootNode;
 };
-#endif
 
 }  // namespace android::uirenderer
diff --git a/libs/hwui/apex/android_bitmap.cpp b/libs/hwui/apex/android_bitmap.cpp
index c80a9b4ae97f..c46eef46319a 100644
--- a/libs/hwui/apex/android_bitmap.cpp
+++ b/libs/hwui/apex/android_bitmap.cpp
@@ -306,9 +306,13 @@ int ABitmap_compress(const AndroidBitmapInfo* info, ADataSpace dataSpace, const
 
 AHardwareBuffer* ABitmap_getHardwareBuffer(ABitmap* bitmapHandle) {
     Bitmap* bitmap = TypeCast::toBitmap(bitmapHandle);
+#ifdef __ANDROID__
     AHardwareBuffer* buffer = bitmap->hardwareBuffer();
     if (buffer) {
         AHardwareBuffer_acquire(buffer);
     }
     return buffer;
+#else
+    return nullptr;
+#endif
 }
diff --git a/libs/hwui/apex/android_canvas.cpp b/libs/hwui/apex/android_canvas.cpp
index 19f726a31b33..69c09a71b6e5 100644
--- a/libs/hwui/apex/android_canvas.cpp
+++ b/libs/hwui/apex/android_canvas.cpp
@@ -41,6 +41,7 @@ static bool convert(const ANativeWindow_Buffer* buffer,
         return false;
     }
 
+#ifdef __ANDROID__
     sk_sp<SkColorSpace> cs(uirenderer::DataSpaceToColorSpace((android_dataspace)dataspace));
     SkImageInfo imageInfo = uirenderer::ANativeWindowToImageInfo(*buffer, cs);
     size_t rowBytes = buffer->stride * imageInfo.bytesPerPixel();
@@ -55,6 +56,7 @@ static bool convert(const ANativeWindow_Buffer* buffer,
         }
         return true;
     }
+#endif
     return false;
 }
 
diff --git a/libs/hwui/jni/android_graphics_HardwareRenderer.cpp b/libs/hwui/jni/android_graphics_HardwareRenderer.cpp
index d15b1680de94..2e76c94b9f6c 100644
--- a/libs/hwui/jni/android_graphics_HardwareRenderer.cpp
+++ b/libs/hwui/jni/android_graphics_HardwareRenderer.cpp
@@ -14,6 +14,8 @@
  * limitations under the License.
  */
 
+#undef LOG_TAG
+#define LOG_TAG "ThreadedRenderer"
 #define ATRACE_TAG ATRACE_TAG_VIEW
 
 #include <FrameInfo.h>
@@ -31,16 +33,22 @@
 #include <SkSerialProcs.h>
 #include <SkStream.h>
 #include <SkTypeface.h>
+#ifdef __ANDROID__
 #include <dlfcn.h>
+#endif
 #include <gui/TraceUtils.h>
 #include <include/encode/SkPngEncoder.h>
 #include <inttypes.h>
 #include <log/log.h>
+#ifdef __ANDROID__  // Layoutlib does not support hardware
 #include <media/NdkImage.h>
 #include <media/NdkImageReader.h>
+#endif
 #include <nativehelper/JNIPlatformHelp.h>
+#ifdef __ANDROID__  // Layoutlib does not support shader cache
 #include <pipeline/skia/ShaderCache.h>
 #include <private/EGL/cache.h>
+#endif
 #include <renderthread/CanvasContext.h>
 #include <renderthread/RenderProxy.h>
 #include <renderthread/RenderTask.h>
@@ -57,9 +65,15 @@
 #include <vector>
 
 #include "JvmErrorReporter.h"
+#ifdef __ANDROID__  // Layoutlib does not support Frame Metrics and shaders
 #include "android_graphics_HardwareRendererObserver.h"
+#endif
 #include "utils/ForceDark.h"
 
+#ifndef __ANDROID__
+#include <gui/Surface.h>
+#endif
+
 namespace android {
 
 using namespace android::uirenderer;
@@ -103,6 +117,30 @@ static JNIEnv* getenv(JavaVM* vm) {
     return env;
 }
 
+#ifndef __ANDROID__
+static struct {
+    jclass clazz;
+    jfieldID mNativeObject;
+    jfieldID mLock;
+    jmethodID ctor;
+} gSurfaceClassInfo;
+
+ANativeWindow* layoutlibFromSurface(JNIEnv* env, jobject surfaceObj) {
+    sp<ANativeWindow> win;
+    jobject lock = env->GetObjectField(surfaceObj, gSurfaceClassInfo.mLock);
+    if (env->MonitorEnter(lock) == JNI_OK) {
+        win = reinterpret_cast<Surface*>(
+                env->GetLongField(surfaceObj, gSurfaceClassInfo.mNativeObject));
+        env->MonitorExit(lock);
+    }
+    env->DeleteLocalRef(lock);
+    if (win != NULL) {
+        win->incStrong((void*)layoutlibFromSurface);
+    }
+    return win.get();
+}
+#endif
+
 typedef ANativeWindow* (*ANW_fromSurface)(JNIEnv* env, jobject surface);
 ANW_fromSurface fromSurface;
 
@@ -498,7 +536,9 @@ public:
                 return sk_ref_sp(img);
             }
             bm.setImmutable();
+#ifdef __ANDROID__
             return SkImages::PinnableRasterFromBitmap(bm);
+#endif
         }
         return sk_ref_sp(img);
     }
@@ -669,6 +709,7 @@ static void android_view_ThreadedRenderer_setFrameCompleteCallback(JNIEnv* env,
     }
 }
 
+#ifdef __ANDROID__
 class CopyRequestAdapter : public CopyRequest {
 public:
     CopyRequestAdapter(JavaVM* vm, jobject jCopyRequest, Rect srcRect)
@@ -690,11 +731,13 @@ public:
 private:
     JGlobalRefHolder mRefHolder;
 };
+#endif
 
 static void android_view_ThreadedRenderer_copySurfaceInto(JNIEnv* env, jobject clazz,
                                                           jobject jsurface, jint left, jint top,
                                                           jint right, jint bottom,
                                                           jobject jCopyRequest) {
+#ifdef __ANDROID__
     JavaVM* vm = nullptr;
     LOG_ALWAYS_FATAL_IF(env->GetJavaVM(&vm) != JNI_OK, "Unable to get Java VM");
     auto copyRequest = std::make_shared<CopyRequestAdapter>(vm, env->NewGlobalRef(jCopyRequest),
@@ -702,6 +745,7 @@ static void android_view_ThreadedRenderer_copySurfaceInto(JNIEnv* env, jobject c
     ANativeWindow* window = fromSurface(env, jsurface);
     RenderProxy::copySurfaceInto(window, std::move(copyRequest));
     ANativeWindow_release(window);
+#endif
 }
 
 class ContextFactory : public IContextFactory {
@@ -713,6 +757,7 @@ public:
 
 static jobject android_view_ThreadedRenderer_createHardwareBitmapFromRenderNode(JNIEnv* env,
         jobject clazz, jlong renderNodePtr, jint jwidth, jint jheight) {
+#ifdef __ANDROID__  // Layoutlib does not support hardware
     RenderNode* renderNode = reinterpret_cast<RenderNode*>(renderNodePtr);
     if (jwidth <= 0 || jheight <= 0) {
         ALOGW("Invalid width %d or height %d", jwidth, jheight);
@@ -796,6 +841,9 @@ static jobject android_view_ThreadedRenderer_createHardwareBitmapFromRenderNode(
     sk_sp<Bitmap> bitmap = Bitmap::createFrom(buffer, cs);
     return bitmap::createBitmap(env, bitmap.release(),
             android::bitmap::kBitmapCreateFlag_Premultiplied);
+#else
+    return 0;
+#endif
 }
 
 static void android_view_ThreadedRenderer_disableVsync(JNIEnv*, jclass) {
@@ -852,15 +900,18 @@ static void android_view_ThreadedRenderer_notifyExpensiveFrame(JNIEnv*, jclass,
 
 // Plumbs the display density down to DeviceInfo.
 static void android_view_ThreadedRenderer_setDisplayDensityDpi(JNIEnv*, jclass, jint densityDpi) {
+#ifdef __ANDROID__  // host does not support native display
     // Convert from dpi to density-independent pixels.
     const float density = densityDpi / 160.0;
     DeviceInfo::setDensity(density);
+#endif
 }
 
 static void android_view_ThreadedRenderer_initDisplayInfo(
         JNIEnv* env, jclass, jint physicalWidth, jint physicalHeight, jfloat refreshRate,
         jint wideColorDataspace, jlong appVsyncOffsetNanos, jlong presentationDeadlineNanos,
         jboolean supportFp16ForHdr, jboolean supportMixedColorSpaces) {
+#ifdef __ANDROID__  // host does not support native display
     DeviceInfo::setWidth(physicalWidth);
     DeviceInfo::setHeight(physicalHeight);
     DeviceInfo::setRefreshRate(refreshRate);
@@ -869,6 +920,7 @@ static void android_view_ThreadedRenderer_initDisplayInfo(
     DeviceInfo::setPresentationDeadlineNanos(presentationDeadlineNanos);
     DeviceInfo::setSupportFp16ForHdr(supportFp16ForHdr);
     DeviceInfo::setSupportMixedColorSpaces(supportMixedColorSpaces);
+#endif
 }
 
 static void android_view_ThreadedRenderer_setDrawingEnabled(JNIEnv*, jclass, jboolean enabled) {
@@ -885,20 +937,24 @@ static jboolean android_view_ThreadedRenderer_isDrawingEnabled(JNIEnv*, jclass)
 
 static void android_view_ThreadedRenderer_addObserver(JNIEnv* env, jclass clazz,
         jlong proxyPtr, jlong observerPtr) {
+#ifdef __ANDROID__  // Layoutlib does not support frame metrics
     HardwareRendererObserver* observer = reinterpret_cast<HardwareRendererObserver*>(observerPtr);
     renderthread::RenderProxy* renderProxy =
             reinterpret_cast<renderthread::RenderProxy*>(proxyPtr);
 
     renderProxy->addFrameMetricsObserver(observer);
+#endif
 }
 
 static void android_view_ThreadedRenderer_removeObserver(JNIEnv* env, jclass clazz,
         jlong proxyPtr, jlong observerPtr) {
+#ifdef __ANDROID__  // Layoutlib does not support frame metrics
     HardwareRendererObserver* observer = reinterpret_cast<HardwareRendererObserver*>(observerPtr);
     renderthread::RenderProxy* renderProxy =
             reinterpret_cast<renderthread::RenderProxy*>(proxyPtr);
 
     renderProxy->removeFrameMetricsObserver(observer);
+#endif
 }
 
 // ----------------------------------------------------------------------------
@@ -907,6 +963,7 @@ static void android_view_ThreadedRenderer_removeObserver(JNIEnv* env, jclass cla
 
 static void android_view_ThreadedRenderer_setupShadersDiskCache(JNIEnv* env, jobject clazz,
         jstring diskCachePath, jstring skiaDiskCachePath) {
+#ifdef __ANDROID__  // Layoutlib does not support EGL
     const char* cacheArray = env->GetStringUTFChars(diskCachePath, NULL);
     android::egl_set_cache_filename(cacheArray);
     env->ReleaseStringUTFChars(diskCachePath, cacheArray);
@@ -914,6 +971,7 @@ static void android_view_ThreadedRenderer_setupShadersDiskCache(JNIEnv* env, job
     const char* skiaCacheArray = env->GetStringUTFChars(skiaDiskCachePath, NULL);
     uirenderer::skiapipeline::ShaderCache::get().setFilename(skiaCacheArray);
     env->ReleaseStringUTFChars(skiaDiskCachePath, skiaCacheArray);
+#endif
 }
 
 static jboolean android_view_ThreadedRenderer_isWebViewOverlaysEnabled(JNIEnv* env, jobject clazz) {
@@ -1050,8 +1108,9 @@ static void attachRenderThreadToJvm(const char* name) {
 
 int register_android_view_ThreadedRenderer(JNIEnv* env) {
     env->GetJavaVM(&mJvm);
+#ifdef __ANDROID__  // Layoutlib does not use a separate renderthread
     RenderThread::setOnStartHook(&attachRenderThreadToJvm);
-
+#endif
     jclass hardwareRenderer = FindClassOrDie(env,
             "android/graphics/HardwareRenderer");
     gHardwareRenderer.clazz = reinterpret_cast<jclass>(env->NewGlobalRef(hardwareRenderer));
@@ -1089,11 +1148,22 @@ int register_android_view_ThreadedRenderer(JNIEnv* env) {
     gCopyRequest.onCopyFinished = GetMethodIDOrDie(env, copyRequest, "onCopyFinished", "(I)V");
     gCopyRequest.getDestinationBitmap =
             GetMethodIDOrDie(env, copyRequest, "getDestinationBitmap", "(II)J");
-
+#ifdef __ANDROID__
     void* handle_ = dlopen("libandroid.so", RTLD_NOW | RTLD_NODELETE);
     fromSurface = (ANW_fromSurface)dlsym(handle_, "ANativeWindow_fromSurface");
     LOG_ALWAYS_FATAL_IF(fromSurface == nullptr,
                         "Failed to find required symbol ANativeWindow_fromSurface!");
+#else
+    jclass clazz = FindClassOrDie(env, "android/view/Surface");
+    gSurfaceClassInfo.clazz = MakeGlobalRefOrDie(env, clazz);
+    gSurfaceClassInfo.mNativeObject =
+            GetFieldIDOrDie(env, gSurfaceClassInfo.clazz, "mNativeObject", "J");
+    gSurfaceClassInfo.mLock =
+            GetFieldIDOrDie(env, gSurfaceClassInfo.clazz, "mLock", "Ljava/lang/Object;");
+    gSurfaceClassInfo.ctor = GetMethodIDOrDie(env, gSurfaceClassInfo.clazz, "<init>", "(J)V");
+
+    fromSurface = layoutlibFromSurface;
+#endif
 
     return RegisterMethodsOrDie(env, kClassPathName, gMethods, NELEM(gMethods));
 }
diff --git a/libs/hwui/pipeline/skia/SkiaHostPipeline.cpp b/libs/hwui/pipeline/skia/SkiaHostPipeline.cpp
new file mode 100755
index 000000000000..e8c0d1e57e26
--- /dev/null
+++ b/libs/hwui/pipeline/skia/SkiaHostPipeline.cpp
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "SkiaHostPipeline.h"
+
+#include "LightingInfo.h"
+#include "renderthread/Frame.h"
+
+#include "SkColor.h"
+#include "SkPaint.h"
+#include <SkSurface.h>
+
+#include <strings.h>
+#include <system/window.h>
+
+using namespace android::uirenderer::renderthread;
+
+namespace android {
+namespace uirenderer {
+namespace skiapipeline {
+
+MakeCurrentResult SkiaHostPipeline::makeCurrent() {
+    return MakeCurrentResult::Succeeded;
+}
+
+Frame SkiaHostPipeline::getFrame() {
+    return Frame(mSurface->width(), mSurface->height(), 0);
+}
+
+IRenderPipeline::DrawResult SkiaHostPipeline::draw(
+        const Frame& frame, const SkRect& screenDirty, const SkRect& dirty,
+        const LightGeometry& lightGeometry, LayerUpdateQueue* layerUpdateQueue,
+        const Rect& contentDrawBounds, bool opaque, const LightInfo& lightInfo,
+        const std::vector<sp<RenderNode>>& renderNodes, FrameInfoVisualizer* profiler,
+        const HardwareBufferRenderParams& bufferParams, std::mutex& profilerLock) {
+    LightingInfo::updateLighting(lightGeometry, lightInfo);
+    renderFrame(*layerUpdateQueue, dirty, renderNodes, opaque, contentDrawBounds, mSurface,
+                SkMatrix::I());
+
+    return {true, IRenderPipeline::DrawResult::kUnknownTime, android::base::unique_fd{}};
+}
+
+DeferredLayerUpdater* SkiaHostPipeline::createTextureLayer() {
+    return nullptr;
+}
+
+bool SkiaHostPipeline::swapBuffers(const renderthread::Frame& frame, IRenderPipeline::DrawResult& drawResult,
+                     const SkRect& screenDirty, FrameInfo* currentFrameInfo,
+                     bool* requireSwap) {
+    return false;
+}
+
+void SkiaHostPipeline::onStop() {}
+
+bool SkiaHostPipeline::setSurface(ANativeWindow* surface, SwapBehavior swapBehavior) {
+    if (surface) {
+        ANativeWindowBuffer* buffer;
+        surface->dequeueBuffer(surface, &buffer, nullptr);
+        int width, height;
+        surface->query(surface, NATIVE_WINDOW_WIDTH, &width);
+        surface->query(surface, NATIVE_WINDOW_HEIGHT, &height);
+        // The ColorType param here must match the ColorType used by
+        // Bitmap.Config.ARGB_8888. Android Bitmap objects use kN32_SkColorType
+        // by default for Bitmap.Config.ARGB_8888. The value of this is
+        // determined at compile time based on architecture (either BGRA or
+        // RGBA). If other Android Bitmap configs are used, 'kN32_SkColorType'
+        // may not be correct.
+        SkImageInfo imageInfo = SkImageInfo::Make(width, height, kN32_SkColorType,
+                                                  SkAlphaType::kPremul_SkAlphaType);
+        size_t widthBytes = width * 4;
+        void* pixels = buffer->reserved[0];
+        mSurface = SkSurfaces::WrapPixels(imageInfo, pixels, widthBytes);
+    } else {
+        mSurface = sk_sp<SkSurface>();
+    }
+    return true;
+}
+
+bool SkiaHostPipeline::isSurfaceReady() {
+    return CC_UNLIKELY(mSurface.get() != nullptr);
+}
+
+bool SkiaHostPipeline::isContextReady() {
+    return true;
+}
+
+} /* namespace skiapipeline */
+} /* namespace uirenderer */
+} /* namespace android */
diff --git a/libs/hwui/pipeline/skia/SkiaHostPipeline.h b/libs/hwui/pipeline/skia/SkiaHostPipeline.h
new file mode 100755
index 000000000000..4bdc82e433c6
--- /dev/null
+++ b/libs/hwui/pipeline/skia/SkiaHostPipeline.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "SkiaPipeline.h"
+
+namespace android {
+
+namespace uirenderer {
+namespace skiapipeline {
+
+class SkiaHostPipeline : public SkiaPipeline {
+public:
+    SkiaHostPipeline(renderthread::RenderThread& thread) : SkiaPipeline(thread) {}
+    virtual ~SkiaHostPipeline() {}
+
+    renderthread::MakeCurrentResult makeCurrent() override;
+    renderthread::Frame getFrame() override;
+    renderthread::IRenderPipeline::DrawResult draw(
+            const renderthread::Frame& frame, const SkRect& screenDirty, const SkRect& dirty,
+            const LightGeometry& lightGeometry, LayerUpdateQueue* layerUpdateQueue,
+            const Rect& contentDrawBounds, bool opaque, const LightInfo& lightInfo,
+            const std::vector<sp<RenderNode> >& renderNodes, FrameInfoVisualizer* profiler,
+            const renderthread::HardwareBufferRenderParams& bufferParams,
+            std::mutex& profilerLock) override;
+    DeferredLayerUpdater* createTextureLayer() override;
+    bool swapBuffers(const renderthread::Frame& frame, IRenderPipeline::DrawResult& drawResult,
+                     const SkRect& screenDirty, FrameInfo* currentFrameInfo,
+                     bool* requireSwap) override;
+    bool setSurface(ANativeWindow* surface, renderthread::SwapBehavior swapBehavior) override;
+    void onStop() override;
+    bool isSurfaceReady() override;
+    bool isContextReady() override;
+
+private:
+    sk_sp<SkSurface> mSurface;
+};
+
+} /* namespace skiapipeline */
+} /* namespace uirenderer */
+} /* namespace android */
diff --git a/libs/hwui/pipeline/skia/SkiaPipeline.cpp b/libs/hwui/pipeline/skia/SkiaPipeline.cpp
index 326b6ed77fe0..cf0d07686be6 100644
--- a/libs/hwui/pipeline/skia/SkiaPipeline.cpp
+++ b/libs/hwui/pipeline/skia/SkiaPipeline.cpp
@@ -72,6 +72,7 @@ void SkiaPipeline::onDestroyHardwareResources() {
 }
 
 bool SkiaPipeline::pinImages(std::vector<SkImage*>& mutableImages) {
+#ifdef __ANDROID__  // Layoutlib does not support Gr
     if (!mRenderThread.getGrContext()) {
         ALOGD("Trying to pin an image with an invalid GrContext");
         return false;
@@ -83,14 +84,17 @@ bool SkiaPipeline::pinImages(std::vector<SkImage*>& mutableImages) {
             return false;
         }
     }
+#endif
     return true;
 }
 
 void SkiaPipeline::unpinImages() {
+#ifdef __ANDROID__  // Layoutlib does not support Gr
     for (auto& image : mPinnedImages) {
         skgpu::ganesh::UnpinTexture(mRenderThread.getGrContext(), image.get());
     }
     mPinnedImages.clear();
+#endif
 }
 
 void SkiaPipeline::renderLayers(const LightGeometry& lightGeometry,
@@ -103,7 +107,9 @@ void SkiaPipeline::renderLayers(const LightGeometry& lightGeometry,
 }
 
 void SkiaPipeline::renderLayersImpl(const LayerUpdateQueue& layers, bool opaque) {
+#ifdef __ANDROID__  // Layoutlib does not support Gr
     sk_sp<GrDirectContext> cachedContext;
+#endif
 
     // Render all layers that need to be updated, in order.
     for (size_t i = 0; i < layers.entries().size(); i++) {
@@ -156,7 +162,7 @@ void SkiaPipeline::renderLayersImpl(const LayerUpdateQueue& layers, bool opaque)
         layerCanvas->restoreToCount(saveCount);
 
         LightingInfo::setLightCenterRaw(savedLightCenter);
-
+#ifdef __ANDROID__  // Layoutlib does not support Gr
         // cache the current context so that we can defer flushing it until
         // either all the layers have been rendered or the context changes
         GrDirectContext* currentContext =
@@ -168,12 +174,14 @@ void SkiaPipeline::renderLayersImpl(const LayerUpdateQueue& layers, bool opaque)
             }
             cachedContext.reset(SkSafeRef(currentContext));
         }
+#endif
     }
-
+#ifdef __ANDROID__  // Layoutlib dose not support Gr
     if (cachedContext.get()) {
         ATRACE_NAME("flush layers");
         cachedContext->flushAndSubmit();
     }
+#endif
 }
 
 bool SkiaPipeline::createOrUpdateLayer(RenderNode* node, const DamageAccumulator& damageAccumulator,
@@ -188,10 +196,14 @@ bool SkiaPipeline::createOrUpdateLayer(RenderNode* node, const DamageAccumulator
         info = SkImageInfo::Make(surfaceWidth, surfaceHeight, getSurfaceColorType(),
                                  kPremul_SkAlphaType, getSurfaceColorSpace());
         SkSurfaceProps props(0, kUnknown_SkPixelGeometry);
+#ifdef __ANDROID__  // Layoutlib does not support Gr
         SkASSERT(mRenderThread.getGrContext() != nullptr);
         node->setLayerSurface(SkSurfaces::RenderTarget(mRenderThread.getGrContext(),
                                                        skgpu::Budgeted::kYes, info, 0,
                                                        this->getSurfaceOrigin(), &props));
+#else
+        node->setLayerSurface(SkSurfaces::Raster(info, &props));
+#endif
         if (node->getLayerSurface()) {
             // update the transform in window of the layer to reset its origin wrt light source
             // position
@@ -199,6 +211,7 @@ bool SkiaPipeline::createOrUpdateLayer(RenderNode* node, const DamageAccumulator
             damageAccumulator.computeCurrentTransform(&windowTransform);
             node->getSkiaLayer()->inverseTransformInWindow.loadInverse(windowTransform);
         } else {
+#ifdef __ANDROID__  // Layoutlib does not support Gr
             String8 cachesOutput;
             mRenderThread.cacheManager().dumpMemoryUsage(cachesOutput,
                                                          &mRenderThread.renderState());
@@ -212,6 +225,7 @@ bool SkiaPipeline::createOrUpdateLayer(RenderNode* node, const DamageAccumulator
                     << (int)(mRenderThread.getGrContext() != nullptr);
                 errorHandler->onError(err.str());
             }
+#endif
         }
         return true;
     }
@@ -219,6 +233,7 @@ bool SkiaPipeline::createOrUpdateLayer(RenderNode* node, const DamageAccumulator
 }
 
 void SkiaPipeline::prepareToDraw(const RenderThread& thread, Bitmap* bitmap) {
+#ifdef __ANDROID__  // Layoutlib does not support Gr
     GrDirectContext* context = thread.getGrContext();
     if (context && !bitmap->isHardware()) {
         ATRACE_FORMAT("Bitmap#prepareToDraw %dx%d", bitmap->width(), bitmap->height());
@@ -232,9 +247,11 @@ void SkiaPipeline::prepareToDraw(const RenderThread& thread, Bitmap* bitmap) {
             context->flushAndSubmit();
         }
     }
+#endif
 }
 
 static void savePictureAsync(const sk_sp<SkData>& data, const std::string& filename) {
+#ifdef __ANDROID__  // Layoutlib does not support CommonPool
     CommonPool::post([data, filename] {
         if (0 == access(filename.c_str(), F_OK)) {
             return;
@@ -248,6 +265,7 @@ static void savePictureAsync(const sk_sp<SkData>& data, const std::string& filen
                      filename.c_str());
         }
     });
+#endif
 }
 
 // Note multiple SkiaPipeline instances may be loaded if more than one app is visible.
@@ -279,6 +297,7 @@ bool SkiaPipeline::shouldStartNewFileCapture() {
     return false;
 }
 
+#ifdef __ANDROID__  // Layoutlib does not support multiframe capture
 // performs the first-frame work of a multi frame SKP capture. Returns true if successful.
 bool SkiaPipeline::setupMultiFrameCapture() {
     ALOGD("Set up multi-frame capture, frames = %d", mCaptureSequence);
@@ -309,6 +328,7 @@ bool SkiaPipeline::setupMultiFrameCapture() {
         return false;
     }
 }
+#endif
 
 // recurse through the rendernode's children, add any nodes which are layers to the queue.
 static void collectLayers(RenderNode* node, LayerUpdateQueue* layers) {
@@ -360,6 +380,7 @@ SkCanvas* SkiaPipeline::tryCapture(SkSurface* surface, RenderNode* root,
     }
     // Note that shouldStartNewFileCapture tells us if this is the *first* frame of a capture.
     bool firstFrameOfAnim = false;
+#ifdef __ANDROID__  // Layoutlib does not support multiframe capture
     if (shouldStartNewFileCapture() && mCaptureMode == CaptureMode::MultiFrameSKP) {
         // set a reminder to record every layer near the end of this method, after we have set up
         // the nway canvas.
@@ -368,6 +389,7 @@ SkCanvas* SkiaPipeline::tryCapture(SkSurface* surface, RenderNode* root,
             return surface->getCanvas();
         }
     }
+#endif
 
     // Create a canvas pointer, fill it depending on what kind of capture is requested (if any)
     SkCanvas* pictureCanvas = nullptr;
@@ -413,6 +435,7 @@ void SkiaPipeline::endCapture(SkSurface* surface) {
     if (CC_LIKELY(mCaptureMode == CaptureMode::None)) { return; }
     mNwayCanvas.reset();
     ATRACE_CALL();
+#ifdef __ANDROID__  // Layoutlib does not support multiframe capture
     if (mCaptureSequence > 0 && mCaptureMode == CaptureMode::MultiFrameSKP) {
         mMultiPic->endPage();
         mCaptureSequence--;
@@ -431,6 +454,9 @@ void SkiaPipeline::endCapture(SkSurface* surface) {
             });
         }
     } else {
+#else
+    {
+#endif
         sk_sp<SkPicture> picture = mRecorder->finishRecordingAsPicture();
         if (picture->approximateOpCount() > 0) {
             if (mPictureCapturedCallback) {
@@ -600,6 +626,7 @@ void SkiaPipeline::renderFrameImpl(const SkRect& clip,
 }
 
 void SkiaPipeline::dumpResourceCacheUsage() const {
+#ifdef __ANDROID__  // Layoutlib does not support resource cache
     int resources;
     size_t bytes;
     mRenderThread.getGrContext()->getResourceCacheUsage(&resources, &bytes);
@@ -611,8 +638,10 @@ void SkiaPipeline::dumpResourceCacheUsage() const {
                 bytes * (1.0f / (1024.0f * 1024.0f)), maxBytes * (1.0f / (1024.0f * 1024.0f)));
 
     ALOGD("%s", log.c_str());
+#endif
 }
 
+#ifdef __ANDROID__  // Layoutlib does not support
 void SkiaPipeline::setHardwareBuffer(AHardwareBuffer* buffer) {
     if (mHardwareBuffer) {
         AHardwareBuffer_release(mHardwareBuffer);
@@ -637,6 +666,7 @@ sk_sp<SkSurface> SkiaPipeline::getBufferSkSurface(
     }
     return mBufferSurface;
 }
+#endif
 
 void SkiaPipeline::setSurfaceColorProperties(ColorMode colorMode) {
     mColorMode = colorMode;
@@ -646,8 +676,10 @@ void SkiaPipeline::setSurfaceColorProperties(ColorMode colorMode) {
             mSurfaceColorSpace = SkColorSpace::MakeSRGB();
             break;
         case ColorMode::WideColorGamut:
+#ifdef __ANDROID__  // Layoutlib does not support DeviceInfo
             mSurfaceColorType = DeviceInfo::get()->getWideColorType();
             mSurfaceColorSpace = DeviceInfo::get()->getWideColorSpace();
+#endif
             break;
         case ColorMode::Hdr:
             if (DeviceInfo::get()->isSupportFp16ForHdr()) {
diff --git a/libs/hwui/pipeline/skia/SkiaPipeline.h b/libs/hwui/pipeline/skia/SkiaPipeline.h
index befee8989383..c92b956ea280 100644
--- a/libs/hwui/pipeline/skia/SkiaPipeline.h
+++ b/libs/hwui/pipeline/skia/SkiaPipeline.h
@@ -74,23 +74,27 @@ public:
         mPictureCapturedCallback = callback;
         mCaptureMode = callback ? CaptureMode::CallbackAPI : CaptureMode::None;
     }
-
+#ifdef __ANDROID__  // Layoutlib does not support
     virtual void setHardwareBuffer(AHardwareBuffer* buffer) override;
+#endif
     bool hasHardwareBuffer() override { return mHardwareBuffer != nullptr; }
 
     void setTargetSdrHdrRatio(float ratio) override;
 
 protected:
+#ifdef __ANDROID__  // Layoutlib does not support
     sk_sp<SkSurface> getBufferSkSurface(
             const renderthread::HardwareBufferRenderParams& bufferParams);
+#endif
     void dumpResourceCacheUsage() const;
 
     renderthread::RenderThread& mRenderThread;
 
     AHardwareBuffer* mHardwareBuffer = nullptr;
+#ifdef __ANDROID__  // Layoutlib does not support
     sk_sp<SkSurface> mBufferSurface = nullptr;
     sk_sp<SkColorSpace> mBufferColorSpace = nullptr;
-
+#endif
     ColorMode mColorMode = ColorMode::Default;
     SkColorType mSurfaceColorType;
     sk_sp<SkColorSpace> mSurfaceColorSpace;
diff --git a/libs/hwui/renderthread/CanvasContext.cpp b/libs/hwui/renderthread/CanvasContext.cpp
index ad864ece9198..6e30248f0db3 100644
--- a/libs/hwui/renderthread/CanvasContext.cpp
+++ b/libs/hwui/renderthread/CanvasContext.cpp
@@ -31,17 +31,26 @@
 #include "../Properties.h"
 #include "AnimationContext.h"
 #include "Frame.h"
+#ifdef __ANDROID__  // Layoutlib does not support Layers
 #include "LayerUpdateQueue.h"
+#endif
 #include "Properties.h"
 #include "RenderThread.h"
 #include "hwui/Canvas.h"
+#ifdef __ANDROID__  // Layoutlib does not support GPU
 #include "pipeline/skia/SkiaOpenGLPipeline.h"
 #include "pipeline/skia/SkiaPipeline.h"
 #include "pipeline/skia/SkiaVulkanPipeline.h"
 #include "thread/CommonPool.h"
 #include "utils/GLUtils.h"
+#else
+#include "pipeline/skia/SkiaHostPipeline.h"
+#endif
 #include "utils/TimeUtils.h"
 
+#define TRIM_MEMORY_COMPLETE 80
+#define TRIM_MEMORY_UI_HIDDEN 20
+
 #define LOG_FRAMETIME_MMA 0
 
 #if LOG_FRAMETIME_MMA
@@ -73,6 +82,7 @@ CanvasContext* ScopedActiveContext::sActiveContext = nullptr;
 CanvasContext* CanvasContext::create(RenderThread& thread, bool translucent,
                                      RenderNode* rootRenderNode, IContextFactory* contextFactory,
                                      int32_t uiThreadId, int32_t renderThreadId) {
+#ifdef __ANDROID__  // Layoutlib does not support GPU
     auto renderType = Properties::getRenderPipelineType();
 
     switch (renderType) {
@@ -89,9 +99,15 @@ CanvasContext* CanvasContext::create(RenderThread& thread, bool translucent,
             break;
     }
     return nullptr;
+#else
+    return new CanvasContext(thread, translucent, rootRenderNode, contextFactory,
+                             std::make_unique<skiapipeline::SkiaHostPipeline>(thread),
+                             uiThreadId, renderThreadId);
+#endif
 }
 
 void CanvasContext::invokeFunctor(const RenderThread& thread, Functor* functor) {
+#ifdef __ANDROID__  // Layoutlib does not support GPU
     ATRACE_CALL();
     auto renderType = Properties::getRenderPipelineType();
     switch (renderType) {
@@ -105,6 +121,7 @@ void CanvasContext::invokeFunctor(const RenderThread& thread, Functor* functor)
             LOG_ALWAYS_FATAL("canvas context type %d not supported", (int32_t)renderType);
             break;
     }
+#endif
 }
 
 void CanvasContext::prepareToDraw(const RenderThread& thread, Bitmap* bitmap) {
@@ -119,16 +136,25 @@ CanvasContext::CanvasContext(RenderThread& thread, bool translucent, RenderNode*
         , mGenerationID(0)
         , mOpaque(!translucent)
         , mAnimationContext(contextFactory->createAnimationContext(mRenderThread.timeLord()))
+#ifdef __ANDROID__  // Layoutlib does not support Profiling, DeviceInfo
         , mJankTracker(&thread.globalProfileData())
         , mProfiler(mJankTracker.frames(), thread.timeLord().frameIntervalNanos())
+#endif
         , mContentDrawBounds(0, 0, 0, 0)
         , mRenderPipeline(std::move(renderPipeline))
-        , mHintSessionWrapper(std::make_shared<HintSessionWrapper>(uiThreadId, renderThreadId)) {
+#ifdef __ANDROID__  // Layoutlib does not support
+        , mHintSessionWrapper(std::make_shared<HintSessionWrapper>(uiThreadId, renderThreadId))
+#endif
+        {
+#ifdef __ANDROID__  // Layoutlib does not support Profiling, DeviceInfo
     mRenderThread.cacheManager().registerCanvasContext(this);
     mRenderThread.renderState().registerContextCallback(this);
+#endif
     rootRenderNode->makeRoot();
     mRenderNodes.emplace_back(rootRenderNode);
+#ifdef __ANDROID__  // Layoutlib does not support Profiling, DeviceInfo
     mProfiler.setDensity(DeviceInfo::getDensity());
+#endif
 }
 
 CanvasContext::~CanvasContext() {
@@ -137,9 +163,11 @@ CanvasContext::~CanvasContext() {
         node->clearRoot();
     }
     mRenderNodes.clear();
+#ifdef __ANDROID__  // Layoutlib does not support
     mRenderThread.cacheManager().unregisterCanvasContext(this);
     mRenderThread.renderState().removeContextCallback(this);
     mHintSessionWrapper->destroy();
+#endif
 }
 
 void CanvasContext::addRenderNode(RenderNode* node, bool placeFront) {
@@ -162,8 +190,10 @@ void CanvasContext::destroy() {
     freePrefetchedLayers();
     destroyHardwareResources();
     mAnimationContext->destroy();
+#ifdef __ANDROID__  // Layoutlib does not support
     mRenderThread.cacheManager().onContextStopped(this);
     mHintSessionWrapper->delayedDestroy(mRenderThread, 2_s, mHintSessionWrapper);
+#endif
 }
 
 static void setBufferCount(ANativeWindow* window) {
@@ -182,6 +212,7 @@ static void setBufferCount(ANativeWindow* window) {
 }
 
 void CanvasContext::setHardwareBuffer(AHardwareBuffer* buffer) {
+#ifdef __ANDROID__  // Layoutlib does not support
     if (mHardwareBuffer) {
         AHardwareBuffer_release(mHardwareBuffer);
         mHardwareBuffer = nullptr;
@@ -192,6 +223,7 @@ void CanvasContext::setHardwareBuffer(AHardwareBuffer* buffer) {
         mHardwareBuffer = buffer;
     }
     mRenderPipeline->setHardwareBuffer(mHardwareBuffer);
+#endif
 }
 
 void CanvasContext::setSurface(ANativeWindow* window, bool enableTimeout) {
@@ -212,6 +244,7 @@ void CanvasContext::setSurface(ANativeWindow* window, bool enableTimeout) {
 }
 
 void CanvasContext::setSurfaceControl(ASurfaceControl* surfaceControl) {
+#ifdef __ANDROID__  // Layoutlib does not support surface control
     if (surfaceControl == mSurfaceControl) return;
 
     auto funcs = mRenderThread.getASurfaceControlFunctions();
@@ -233,6 +266,7 @@ void CanvasContext::setSurfaceControl(ASurfaceControl* surfaceControl) {
         funcs.registerListenerFunc(surfaceControl, mSurfaceControlGenerationId, this,
                                    &onSurfaceStatsAvailable);
     }
+#endif
 }
 
 void CanvasContext::setupPipelineSurface() {
@@ -360,10 +394,12 @@ bool CanvasContext::makeCurrent() {
     return true;
 }
 
+#ifdef __ANDROID__  // Layoutlib does not support DeviceInfo
 static std::optional<SkippedFrameReason> wasSkipped(FrameInfo* info) {
     if (info) return info->getSkippedFrameReason();
     return std::nullopt;
 }
+#endif
 
 bool CanvasContext::isSwapChainStuffed() {
     static const auto SLOW_THRESHOLD = 6_ms;
@@ -408,7 +444,7 @@ bool CanvasContext::isSwapChainStuffed() {
 void CanvasContext::prepareTree(TreeInfo& info, int64_t* uiFrameInfo, int64_t syncQueued,
                                 RenderNode* target) {
     mRenderThread.removeFrameCallback(this);
-
+#ifdef __ANDROID__  // Layoutlib does not support Profiling
     // If the previous frame was dropped we don't need to hold onto it, so
     // just keep using the previous frame's structure instead
     if (const auto reason = wasSkipped(mCurrentFrameInfo)) {
@@ -440,6 +476,7 @@ void CanvasContext::prepareTree(TreeInfo& info, int64_t* uiFrameInfo, int64_t sy
     mCurrentFrameInfo->importUiThreadInfo(uiFrameInfo);
     mCurrentFrameInfo->set(FrameInfoIndex::SyncQueued) = syncQueued;
     mCurrentFrameInfo->markSyncStart();
+#endif
 
     info.damageAccumulator = &mDamageAccumulator;
     info.layerUpdateQueue = &mLayerUpdateQueue;
@@ -453,13 +490,17 @@ void CanvasContext::prepareTree(TreeInfo& info, int64_t* uiFrameInfo, int64_t sy
         // node(s) are non client / filler nodes.
         info.mode = (node.get() == target ? TreeInfo::MODE_FULL : TreeInfo::MODE_RT_ONLY);
         node->prepareTree(info);
+#ifdef __ANDROID__  // Layoutlib does not support GPU
         GL_CHECKPOINT(MODERATE);
+#endif
     }
     mAnimationContext->runRemainingAnimations(info);
+#ifdef __ANDROID__  // Layoutlib does not support GPU
     GL_CHECKPOINT(MODERATE);
 
     freePrefetchedLayers();
     GL_CHECKPOINT(MODERATE);
+#endif
 
     mIsDirty = true;
 
@@ -560,6 +601,7 @@ Frame CanvasContext::getFrame() {
 }
 
 void CanvasContext::draw(bool solelyTextureViewUpdates) {
+#ifdef __ANDROID__  // Layoutlib does not support GPU
     if (auto grContext = getGrContext()) {
         if (grContext->abandoned()) {
             if (grContext->isDeviceLost()) {
@@ -570,6 +612,7 @@ void CanvasContext::draw(bool solelyTextureViewUpdates) {
             return;
         }
     }
+#endif
     SkRect dirty;
     mDamageAccumulator.finish(&dirty);
 
@@ -592,12 +635,13 @@ void CanvasContext::draw(bool solelyTextureViewUpdates) {
     }();
     if (skippedFrameReason) {
         mCurrentFrameInfo->setSkippedFrameReason(*skippedFrameReason);
-
+#ifdef __ANDROID__  // Layoutlib does not support GPU
         if (auto grContext = getGrContext()) {
             // Submit to ensure that any texture uploads complete and Skia can
             // free its staging buffers.
             grContext->flushAndSubmit();
         }
+#endif
 
         // Notify the callbacks, even if there's nothing to draw so they aren't waiting
         // indefinitely
@@ -610,11 +654,12 @@ void CanvasContext::draw(bool solelyTextureViewUpdates) {
     }
 
     ScopedActiveContext activeContext(this);
+#ifdef __ANDROID__  // Layoutlib does not support Profiling
     mCurrentFrameInfo->set(FrameInfoIndex::FrameInterval) =
             mRenderThread.timeLord().frameIntervalNanos();
 
     mCurrentFrameInfo->markIssueDrawCommandsStart();
-
+#endif
     Frame frame = getFrame();
 
     SkRect windowDirty = computeDirtyRect(frame, &dirty);
@@ -627,9 +672,15 @@ void CanvasContext::draw(bool solelyTextureViewUpdates) {
         // or it can lead to memory corruption.
         drawResult = mRenderPipeline->draw(
                 frame, windowDirty, dirty, mLightGeometry, &mLayerUpdateQueue, mContentDrawBounds,
-                mOpaque, mLightInfo, mRenderNodes, &(profiler()), mBufferParams, profilerLock());
+                mOpaque, mLightInfo, mRenderNodes,
+#ifdef __ANDROID__  // Layoutlib does not support Profiling
+				&(profiler()),
+#else
+				nullptr,
+#endif
+                mBufferParams, profilerLock());
     }
-
+#ifdef __ANDROID__  // Layoutlib does not support Profiling, Layers
     uint64_t frameCompleteNr = getFrameNumber();
 
     waitOnFences();
@@ -781,10 +832,12 @@ void CanvasContext::draw(bool solelyTextureViewUpdates) {
     mLastDequeueBufferDuration = dequeueBufferDuration;
 
     mRenderThread.cacheManager().onFrameCompleted();
+#endif
     return;
 }
 
 void CanvasContext::reportMetricsWithPresentTime() {
+#ifdef __ANDROID__  // Layoutlib does not support FrameMetrics
     {  // acquire lock
         std::scoped_lock lock(mFrameInfoMutex);
         if (mFrameMetricsReporter == nullptr) {
@@ -827,8 +880,9 @@ void CanvasContext::reportMetricsWithPresentTime() {
                                                       frameNumber, surfaceControlId);
         }
     }  // release lock
+#endif
 }
-
+#ifdef __ANDROID__  // Layoutlib does not support FrameMetrics
 void CanvasContext::addFrameMetricsObserver(FrameMetricsObserver* observer) {
     std::scoped_lock lock(mFrameInfoMutex);
     if (mFrameMetricsReporter.get() == nullptr) {
@@ -852,8 +906,9 @@ void CanvasContext::removeFrameMetricsObserver(FrameMetricsObserver* observer) {
         }
     }
 }
-
+#endif
 FrameInfo* CanvasContext::getFrameInfoFromLast4(uint64_t frameNumber, uint32_t surfaceControlId) {
+#ifdef __ANDROID__  // Layoutlib does not support Profiling
     std::scoped_lock lock(mLast4FrameMetricsInfosMutex);
     for (size_t i = 0; i < mLast4FrameMetricsInfos.size(); i++) {
         if (mLast4FrameMetricsInfos[i].frameNumber == frameNumber &&
@@ -861,12 +916,13 @@ FrameInfo* CanvasContext::getFrameInfoFromLast4(uint64_t frameNumber, uint32_t s
             return mLast4FrameMetricsInfos[i].frameInfo;
         }
     }
-
+#endif
     return nullptr;
 }
 
 void CanvasContext::onSurfaceStatsAvailable(void* context, int32_t surfaceControlId,
                                             ASurfaceControlStats* stats) {
+#ifdef __ANDROID__  // Layoutlib does not support surface control
     auto* instance = static_cast<CanvasContext*>(context);
 
     const ASurfaceControlFunctions& functions =
@@ -889,6 +945,7 @@ void CanvasContext::onSurfaceStatsAvailable(void* context, int32_t surfaceContro
         instance->mJankTracker.finishFrame(*frameInfo, instance->mFrameMetricsReporter, frameNumber,
                                            surfaceControlId);
     }
+#endif
 }
 
 // Called by choreographer to do an RT-driven animation
@@ -913,9 +970,11 @@ SkISize CanvasContext::getNextFrameSize() const {
     return size;
 }
 
+#ifdef __ANDROID__
 const SkM44& CanvasContext::getPixelSnapMatrix() const {
     return mRenderPipeline->getPixelSnapMatrix();
 }
+#endif
 
 void CanvasContext::prepareAndDraw(RenderNode* node) {
     int64_t vsyncId = mRenderThread.timeLord().lastVsyncId();
@@ -1010,19 +1069,26 @@ DeferredLayerUpdater* CanvasContext::createTextureLayer() {
 }
 
 void CanvasContext::dumpFrames(int fd) {
+#ifdef __ANDROID__  // Layoutlib does not support Profiling
     mJankTracker.dumpStats(fd);
     mJankTracker.dumpFrames(fd);
+#endif
 }
 
 void CanvasContext::resetFrameStats() {
+#ifdef __ANDROID__  // Layoutlib does not support Profiling
     mJankTracker.reset();
+#endif
 }
 
 void CanvasContext::setName(const std::string&& name) {
+#ifdef __ANDROID__  // Layoutlib does not support Profiling
     mJankTracker.setDescription(JankTrackerType::Window, std::move(name));
+#endif
 }
 
 void CanvasContext::waitOnFences() {
+#ifdef __ANDROID__  // Layoutlib does not support Fence?
     if (mFrameFences.size()) {
         ATRACE_CALL();
         for (auto& fence : mFrameFences) {
@@ -1030,10 +1096,13 @@ void CanvasContext::waitOnFences() {
         }
         mFrameFences.clear();
     }
+#endif
 }
 
 void CanvasContext::enqueueFrameWork(std::function<void()>&& func) {
+#ifdef __ANDROID__  // Layoutlib does not support Common Pool
     mFrameFences.push_back(CommonPool::async(std::move(func)));
+#endif
 }
 
 uint64_t CanvasContext::getFrameNumber() {
@@ -1070,7 +1139,9 @@ SkRect CanvasContext::computeDirtyRect(const Frame& frame, SkRect* dirty) {
                   frame.width(), frame.height());
             dirty->setEmpty();
         }
+#ifdef __ANDROID__  // Layoutlib does not support Profiling
         profiler().unionDirty(dirty);
+#endif
     }
 
     if (dirty->isEmpty()) {
@@ -1123,11 +1194,15 @@ void CanvasContext::prepareSurfaceControlForWebview() {
 }
 
 void CanvasContext::sendLoadResetHint() {
+#ifdef __ANDROID__  // Layoutlib does not support
     mHintSessionWrapper->sendLoadResetHint();
+#endif
 }
 
 void CanvasContext::sendLoadIncreaseHint() {
+#ifdef __ANDROID__  // Layoutlib does not support
     mHintSessionWrapper->sendLoadIncreaseHint();
+#endif
 }
 
 void CanvasContext::setSyncDelayDuration(nsecs_t duration) {
@@ -1135,7 +1210,9 @@ void CanvasContext::setSyncDelayDuration(nsecs_t duration) {
 }
 
 void CanvasContext::startHintSession() {
+#ifdef __ANDROID__  // Layoutlib does not support
     mHintSessionWrapper->init();
+#endif
 }
 
 bool CanvasContext::shouldDither() {
diff --git a/libs/hwui/renderthread/CanvasContext.h b/libs/hwui/renderthread/CanvasContext.h
index e2e3fa35b9b0..5bdf46bf5582 100644
--- a/libs/hwui/renderthread/CanvasContext.h
+++ b/libs/hwui/renderthread/CanvasContext.h
@@ -49,6 +49,12 @@
 #include "utils/ForceDark.h"
 #include "utils/RingBuffer.h"
 
+#ifdef __ANDROID__  // Layoutlib does not support surface control
+typedef void* ASurfaceControl;
+typedef void* ASurfaceTransaction;
+typedef void* ASurfaceControlStats;
+#endif
+
 namespace android {
 namespace uirenderer {
 
@@ -115,11 +121,13 @@ public:
 
     static void prepareToDraw(const RenderThread& thread, Bitmap* bitmap);
 
+#ifdef __ANDROID__  // Layoutlib does not support Gr
     /*
      * If Properties::isSkiaEnabled() is true then this will return the Skia
      * grContext associated with the current RenderPipeline.
      */
     GrDirectContext* getGrContext() const { return mRenderThread.getGrContext(); }
+#endif
 
     ASurfaceControl* getSurfaceControl() const { return mSurfaceControl; }
     int32_t getSurfaceControlGenerationId() const { return mSurfaceControlGenerationId; }
@@ -163,9 +171,10 @@ public:
     void stopDrawing();
     void notifyFramePending();
 
+#ifdef __ANDROID__  // Layoutlib does not support Profiling
     FrameInfoVisualizer& profiler() { return mProfiler; }
+#endif
     std::mutex& profilerLock() { return mFrameInfoMutex; }
-
     void dumpFrames(int fd);
     void resetFrameStats();
 
@@ -176,8 +185,10 @@ public:
 
     void setContentDrawBounds(const Rect& bounds) { mContentDrawBounds = bounds; }
 
+#ifdef __ANDROID__  // Layoutlib does not support FrameMetrics
     void addFrameMetricsObserver(FrameMetricsObserver* observer);
     void removeFrameMetricsObserver(FrameMetricsObserver* observer);
+#endif
 
     // Used to queue up work that needs to be completed before this frame completes
     void enqueueFrameWork(std::function<void()>&& func);
@@ -202,9 +213,10 @@ public:
 
     SkISize getNextFrameSize() const;
 
+#ifdef __ANDROID__
     // Returns the matrix to use to nudge non-AA'd points/lines towards the fragment center
     const SkM44& getPixelSnapMatrix() const;
-
+#endif
     // Called when SurfaceStats are available.
     static void onSurfaceStatsAvailable(void* context, int32_t surfaceControlId,
                                         ASurfaceControlStats* stats);
@@ -341,9 +353,11 @@ private:
     std::mutex mLast4FrameMetricsInfosMutex;
 
     std::string mName;
+#ifdef __ANDROID__  // Layoutlib does not support Metrics
     JankTracker mJankTracker;
     FrameInfoVisualizer mProfiler;
     std::unique_ptr<FrameMetricsReporter> mFrameMetricsReporter GUARDED_BY(mFrameInfoMutex);
+#endif
     std::mutex mFrameInfoMutex;
 
     std::set<RenderNode*> mPrefetchedLayers;
diff --git a/libs/hwui/renderthread/DrawFrameTask.cpp b/libs/hwui/renderthread/DrawFrameTask.cpp
index 1b333bfccbf1..753f5ed841d2 100644
--- a/libs/hwui/renderthread/DrawFrameTask.cpp
+++ b/libs/hwui/renderthread/DrawFrameTask.cpp
@@ -21,7 +21,9 @@
 
 #include <algorithm>
 
+#ifdef __ANDROID__  // Layoutlib not Layers
 #include "../DeferredLayerUpdater.h"
+#endif
 #include "../DisplayList.h"
 #include "../Properties.h"
 #include "../RenderNode.h"
@@ -49,6 +51,7 @@ void DrawFrameTask::setContext(RenderThread* thread, CanvasContext* context,
 }
 
 void DrawFrameTask::pushLayerUpdate(DeferredLayerUpdater* layer) {
+#ifdef __ANDROID__  // Layoutlib not Layers
     LOG_ALWAYS_FATAL_IF(!mContext,
                         "Lifecycle violation, there's no context to pushLayerUpdate with!");
 
@@ -58,15 +61,18 @@ void DrawFrameTask::pushLayerUpdate(DeferredLayerUpdater* layer) {
         }
     }
     mLayers.push_back(layer);
+#endif
 }
 
 void DrawFrameTask::removeLayerUpdate(DeferredLayerUpdater* layer) {
+#ifdef __ANDROID__  // Layoutlib not Layers
     for (size_t i = 0; i < mLayers.size(); i++) {
         if (mLayers[i].get() == layer) {
             mLayers.erase(mLayers.begin() + i);
             return;
         }
     }
+#endif
 }
 
 int DrawFrameTask::drawFrame() {
@@ -80,10 +86,14 @@ int DrawFrameTask::drawFrame() {
 }
 
 void DrawFrameTask::postAndWait() {
+#ifdef __ANDROID__  // Layoutlib is singlethreaded, this produces a deadlock
     ATRACE_CALL();
     AutoMutex _lock(mLock);
+#endif
     mRenderThread->queue().post([this]() { run(); });
+#ifdef __ANDROID__  // Layoutlib is singlethreaded, this produces a deadlock
     mSignal.wait(mLock);
+#endif
 }
 
 void DrawFrameTask::run() {
@@ -140,12 +150,14 @@ void DrawFrameTask::run() {
     if (CC_LIKELY(canDrawThisFrame)) {
         context->draw(solelyTextureViewUpdates);
     } else {
+#ifdef __ANDROID__  // Layoutlib does not support GrContext
         // Do a flush in case syncFrameState performed any texture uploads. Since we skipped
         // the draw() call, those uploads (or deletes) will end up sitting in the queue.
         // Do them now
         if (GrDirectContext* grContext = mRenderThread->getGrContext()) {
             grContext->flushAndSubmit();
         }
+#endif
         // wait on fences so tasks don't overlap next frame
         context->waitOnFences();
     }
@@ -157,11 +169,12 @@ void DrawFrameTask::run() {
     if (!canUnblockUiThread) {
         unblockUiThread();
     }
-
+#ifdef __ANDROID__  // Layoutlib does not support
     if (pipeline->hasHardwareBuffer()) {
         auto fence = pipeline->flush();
         hardwareBufferParams.invokeRenderCallback(std::move(fence), 0);
     }
+#endif
 }
 
 bool DrawFrameTask::syncFrameState(TreeInfo& info) {
@@ -176,6 +189,7 @@ bool DrawFrameTask::syncFrameState(TreeInfo& info) {
     bool canDraw = mContext->makeCurrent();
     mContext->unpinImages();
 
+#ifdef __ANDROID__  // Layoutlib does not support Layers
     for (size_t i = 0; i < mLayers.size(); i++) {
         if (mLayers[i]) {
             mLayers[i]->apply();
@@ -183,6 +197,7 @@ bool DrawFrameTask::syncFrameState(TreeInfo& info) {
     }
 
     mLayers.clear();
+#endif
     mContext->setContentDrawBounds(mContentDrawBounds);
     mContext->prepareTree(info, mFrameInfo, mSyncQueued, mTargetNode);
 
@@ -213,8 +228,10 @@ bool DrawFrameTask::syncFrameState(TreeInfo& info) {
 }
 
 void DrawFrameTask::unblockUiThread() {
+#ifdef __ANDROID__  // Layoutlib is singlethreaded, this produces a deadlock
     AutoMutex _lock(mLock);
     mSignal.signal();
+#endif
 }
 
 } /* namespace renderthread */
diff --git a/libs/hwui/renderthread/DrawFrameTask.h b/libs/hwui/renderthread/DrawFrameTask.h
index 4130d4abe09e..f0f691cbbe5b 100644
--- a/libs/hwui/renderthread/DrawFrameTask.h
+++ b/libs/hwui/renderthread/DrawFrameTask.h
@@ -107,8 +107,10 @@ private:
     bool syncFrameState(TreeInfo& info);
     void unblockUiThread();
 
+#ifdef __ANDROID__  // Layoutlib is singlethreaded
     Mutex mLock;
     Condition mSignal;
+#endif
 
     RenderThread* mRenderThread;
     CanvasContext* mContext;
@@ -119,7 +121,9 @@ private:
     /*********************************************
      *  Single frame data
      *********************************************/
+#ifdef __ANDROID__  // Layoutlib does not support Layers
     std::vector<sp<DeferredLayerUpdater> > mLayers;
+#endif
 
     int mSyncResult;
     int64_t mSyncQueued;
diff --git a/libs/hwui/renderthread/IRenderPipeline.h b/libs/hwui/renderthread/IRenderPipeline.h
index b8c3a4de2bd4..dd5e533658de 100644
--- a/libs/hwui/renderthread/IRenderPipeline.h
+++ b/libs/hwui/renderthread/IRenderPipeline.h
@@ -74,8 +74,10 @@ public:
                              const SkRect& screenDirty, FrameInfo* currentFrameInfo,
                              bool* requireSwap) = 0;
     virtual DeferredLayerUpdater* createTextureLayer() = 0;
+#ifdef __ANDROID__  // Layoutlib does not support
     [[nodiscard]] virtual android::base::unique_fd flush() = 0;
     virtual void setHardwareBuffer(AHardwareBuffer* hardwareBuffer) = 0;
+#endif
     virtual bool hasHardwareBuffer() = 0;
     virtual bool setSurface(ANativeWindow* window, SwapBehavior swapBehavior) = 0;
     virtual void onStop() = 0;
@@ -94,13 +96,16 @@ public:
     virtual void setSurfaceColorProperties(ColorMode colorMode) = 0;
     virtual SkColorType getSurfaceColorType() const = 0;
     virtual sk_sp<SkColorSpace> getSurfaceColorSpace() = 0;
+#ifdef __ANDROID__  // Layoutlib does not support
     virtual GrSurfaceOrigin getSurfaceOrigin() = 0;
+#endif
     virtual void setPictureCapturedCallback(
             const std::function<void(sk_sp<SkPicture>&&)>& callback) = 0;
 
     virtual void setTargetSdrHdrRatio(float ratio) = 0;
+#ifdef __ANDROID__  // Layoutlib does not support
     virtual const SkM44& getPixelSnapMatrix() const = 0;
-
+#endif
     virtual ~IRenderPipeline() {}
 };
 
diff --git a/libs/hwui/renderthread/ReliableSurface.cpp b/libs/hwui/renderthread/ReliableSurface.cpp
index 64d38b9ef466..4b3f82f11aac 100644
--- a/libs/hwui/renderthread/ReliableSurface.cpp
+++ b/libs/hwui/renderthread/ReliableSurface.cpp
@@ -17,7 +17,9 @@
 #include "ReliableSurface.h"
 
 #include <log/log_main.h>
+#ifdef __ANDROID__  // Layoutlib does not Hardware
 #include <private/android/AHardwareBufferHelpers.h>
+#endif
 // TODO: this should be including apex instead.
 #include <system/window.h>
 #include <vndk/window.h>
@@ -104,7 +106,9 @@ int ReliableSurface::reserveNext() {
         std::lock_guard _lock{mMutex};
         LOG_ALWAYS_FATAL_IF(mReservedBuffer, "race condition in reserveNext");
         mReservedBuffer = buffer;
+#ifdef __ANDROID__  // Layoutlib no UniqueFd
         mReservedFenceFd.reset(fenceFd);
+#endif
     }
 
     return result;
@@ -118,10 +122,14 @@ void ReliableSurface::clearReservedBuffer() {
         if (mReservedBuffer) {
             ALOGW("Reserved buffer %p was never used", mReservedBuffer);
             buffer = mReservedBuffer;
+#ifdef __ANDROID__  // Layoutlib no UniqueFd
             releaseFd = mReservedFenceFd.release();
+#endif
         }
         mReservedBuffer = nullptr;
+#ifdef __ANDROID__  // Layoutlib no UniqueFd
         mReservedFenceFd.reset();
+#endif
         mHasDequeuedBuffer = false;
     }
     if (buffer) {
@@ -133,15 +141,20 @@ void ReliableSurface::clearReservedBuffer() {
 }
 
 bool ReliableSurface::isFallbackBuffer(const ANativeWindowBuffer* windowBuffer) const {
+#ifdef __ANDROID__  // Layoutlib does not support Fallback Buffer
     if (!mScratchBuffer || !windowBuffer) {
         return false;
     }
     ANativeWindowBuffer* scratchBuffer =
             AHardwareBuffer_to_ANativeWindowBuffer(mScratchBuffer.get());
     return windowBuffer == scratchBuffer;
+#else
+    return false;
+#endif
 }
 
 ANativeWindowBuffer* ReliableSurface::acquireFallbackBuffer(int error) {
+#ifdef __ANDROID__  // Layoutlib does not support Fallback Buffer
     std::lock_guard _lock{mMutex};
     mBufferQueueState = error;
 
@@ -170,6 +183,9 @@ ANativeWindowBuffer* ReliableSurface::acquireFallbackBuffer(int error) {
 
     mScratchBuffer.reset(newBuffer);
     return AHardwareBuffer_to_ANativeWindowBuffer(newBuffer);
+#else
+    return nullptr;
+#endif
 }
 
 int ReliableSurface::hook_dequeueBuffer(ANativeWindow* window,
@@ -180,7 +196,9 @@ int ReliableSurface::hook_dequeueBuffer(ANativeWindow* window,
         std::lock_guard _lock{rs->mMutex};
         if (rs->mReservedBuffer) {
             *buffer = rs->mReservedBuffer;
+#ifdef __ANDROID__  // Layoutlib no UniqueFd
             *fenceFd = rs->mReservedFenceFd.release();
+#endif
             rs->mReservedBuffer = nullptr;
             return OK;
         }
diff --git a/libs/hwui/renderthread/ReliableSurface.h b/libs/hwui/renderthread/ReliableSurface.h
index 595964741049..91aee503cabe 100644
--- a/libs/hwui/renderthread/ReliableSurface.h
+++ b/libs/hwui/renderthread/ReliableSurface.h
@@ -63,9 +63,13 @@ private:
 
     uint64_t mUsage = AHARDWAREBUFFER_USAGE_GPU_FRAMEBUFFER;
     AHardwareBuffer_Format mFormat = AHARDWAREBUFFER_FORMAT_R8G8B8A8_UNORM;
+#ifdef __ANDROID__  // Layoutlib does not support hardware acceleration
     UniqueAHardwareBuffer mScratchBuffer;
+#endif
     ANativeWindowBuffer* mReservedBuffer = nullptr;
+#ifdef __ANDROID__  // Layoutlib does not support UniqueFd
     base::unique_fd mReservedFenceFd;
+#endif
     bool mHasDequeuedBuffer = false;
     int mBufferQueueState = OK;
     size_t mExpectedBufferCount = 0;
diff --git a/libs/hwui/renderthread/RenderProxy.cpp b/libs/hwui/renderthread/RenderProxy.cpp
index eab36050896f..d51ba3f9fece 100644
--- a/libs/hwui/renderthread/RenderProxy.cpp
+++ b/libs/hwui/renderthread/RenderProxy.cpp
@@ -22,11 +22,14 @@
 #include <gui/TraceUtils.h>
 #include <pthread.h>
 #include <ui/GraphicBufferAllocator.h>
-
+#ifdef __ANDROID__  // Layoutlib does not support Layers
 #include "DeferredLayerUpdater.h"
+#endif
 #include "DisplayList.h"
 #include "Properties.h"
+#ifdef __ANDROID__  // Layoutlib does not support GPU
 #include "Readback.h"
+#endif
 #include "Rect.h"
 #include "WebViewFunctorManager.h"
 #include "renderthread/CanvasContext.h"
@@ -42,8 +45,13 @@ namespace renderthread {
 RenderProxy::RenderProxy(bool translucent, RenderNode* rootRenderNode,
                          IContextFactory* contextFactory)
         : mRenderThread(RenderThread::getInstance()), mContext(nullptr) {
+#ifdef __ANDROID__
     pid_t uiThreadId = pthread_gettid_np(pthread_self());
     pid_t renderThreadId = getRenderThreadTid();
+#else
+    pid_t uiThreadId = 0;
+    pid_t renderThreadId = 0;
+#endif
     mContext = mRenderThread.queue().runSync([=, this]() -> CanvasContext* {
         CanvasContext* context = CanvasContext::create(mRenderThread, translucent, rootRenderNode,
                                                        contextFactory, uiThreadId, renderThreadId);
@@ -74,6 +82,7 @@ void RenderProxy::setSwapBehavior(SwapBehavior swapBehavior) {
 }
 
 bool RenderProxy::loadSystemProperties() {
+#ifdef __ANDROID__  // Layoutlib does not support Profiling
     return mRenderThread.queue().runSync([this]() -> bool {
         bool needsRedraw = Properties::load();
         if (mContext->profiler().consumeProperties()) {
@@ -81,6 +90,9 @@ bool RenderProxy::loadSystemProperties() {
         }
         return needsRedraw;
     });
+#else
+    return true;
+#endif
 }
 
 void RenderProxy::setName(const char* name) {
@@ -90,6 +102,7 @@ void RenderProxy::setName(const char* name) {
 }
 
 void RenderProxy::setHardwareBuffer(AHardwareBuffer* buffer) {
+#ifdef __ANDROID__  // Layoutlib does not support
     if (buffer) {
         AHardwareBuffer_acquire(buffer);
     }
@@ -99,6 +112,7 @@ void RenderProxy::setHardwareBuffer(AHardwareBuffer* buffer) {
             AHardwareBuffer_release(hardwareBuffer);
         }
     });
+#endif
 }
 
 void RenderProxy::setSurface(ANativeWindow* window, bool enableTimeout) {
@@ -110,6 +124,7 @@ void RenderProxy::setSurface(ANativeWindow* window, bool enableTimeout) {
 }
 
 void RenderProxy::setSurfaceControl(ASurfaceControl* surfaceControl) {
+#ifdef __ANDROID__  // Layoutlib does not support surface control
     auto funcs = mRenderThread.getASurfaceControlFunctions();
     if (surfaceControl) {
         funcs.acquireFunc(surfaceControl);
@@ -120,6 +135,7 @@ void RenderProxy::setSurfaceControl(ASurfaceControl* surfaceControl) {
             funcs.releaseFunc(control);
         }
     });
+#endif
 }
 
 void RenderProxy::allocateBuffers() {
@@ -184,9 +200,11 @@ void RenderProxy::destroy() {
 }
 
 void RenderProxy::destroyFunctor(int functor) {
+#ifdef __ANDROID__  // Layoutlib does not support GPU
     ATRACE_CALL();
     RenderThread& thread = RenderThread::getInstance();
     thread.queue().post([=]() { WebViewFunctorManager::instance().destroyFunctor(functor); });
+#endif
 }
 
 DeferredLayerUpdater* RenderProxy::createTextureLayer() {
@@ -200,11 +218,15 @@ void RenderProxy::buildLayer(RenderNode* node) {
 }
 
 bool RenderProxy::copyLayerInto(DeferredLayerUpdater* layer, SkBitmap& bitmap) {
+#ifdef __ANDROID__  // Layoutlib does not support GPU
     ATRACE_NAME("TextureView#getBitmap");
     auto& thread = RenderThread::getInstance();
     return thread.queue().runSync([&]() -> bool {
         return thread.readback().copyLayerInto(layer, &bitmap) == CopyResult::Success;
     });
+#else
+    return false;
+#endif
 }
 
 void RenderProxy::pushLayerUpdate(DeferredLayerUpdater* layer) {
@@ -216,7 +238,9 @@ void RenderProxy::cancelLayerUpdate(DeferredLayerUpdater* layer) {
 }
 
 void RenderProxy::detachSurfaceTexture(DeferredLayerUpdater* layer) {
+#ifdef __ANDROID__  // Layoutlib does not support GPU
     return mRenderThread.queue().runSync([&]() { layer->detachSurfaceTexture(); });
+#endif
 }
 
 void RenderProxy::destroyHardwareResources() {
@@ -242,6 +266,7 @@ void RenderProxy::trimCaches(int level) {
 }
 
 void RenderProxy::purgeCaches() {
+#ifdef __ANDROID__  // Layoutlib does not support GrContext
     if (RenderThread::hasInstance()) {
         RenderThread& thread = RenderThread::getInstance();
         thread.queue().post([&thread]() {
@@ -250,6 +275,7 @@ void RenderProxy::purgeCaches() {
             }
         });
     }
+#endif
 }
 
 void RenderProxy::overrideProperty(const char* name, const char* value) {
@@ -263,9 +289,13 @@ void RenderProxy::fence() {
 }
 
 int RenderProxy::maxTextureSize() {
+#ifdef __ANDROID__  // Layoutlib does not support DeviceInfo
     static int maxTextureSize = RenderThread::getInstance().queue().runSync(
             []() { return DeviceInfo::get()->maxTextureSize(); });
     return maxTextureSize;
+#else
+    return 4096;
+#endif
 }
 
 void RenderProxy::stopDrawing() {
@@ -285,6 +315,7 @@ void RenderProxy::notifyExpensiveFrame() {
 }
 
 void RenderProxy::dumpProfileInfo(int fd, int dumpFlags) {
+#ifdef __ANDROID__  // Layoutlib does not support Profiling
     mRenderThread.queue().runSync([&]() {
         std::lock_guard lock(mRenderThread.getJankDataMutex());
         mContext->profiler().dumpData(fd);
@@ -298,20 +329,27 @@ void RenderProxy::dumpProfileInfo(int fd, int dumpFlags) {
             mContext->resetFrameStats();
         }
     });
+#endif
 }
 
 void RenderProxy::resetProfileInfo() {
+#ifdef __ANDROID__  // Layoutlib does not support Profiling
     mRenderThread.queue().runSync([this]() {
         std::lock_guard lock(mRenderThread.getJankDataMutex());
         mContext->resetFrameStats();
     });
+#endif
 }
 
 uint32_t RenderProxy::frameTimePercentile(int percentile) {
+#ifdef __ANDROID__  // Layoutlib does not support Profiling
     return mRenderThread.queue().runSync([&]() -> auto {
         std::lock_guard lock(mRenderThread.globalProfileData().getDataMutex());
         return mRenderThread.globalProfileData()->findPercentile(percentile);
     });
+#else
+    return 0;
+#endif
 }
 
 void RenderProxy::dumpGraphicsMemory(int fd, bool includeProfileData, bool resetProfile) {
@@ -324,11 +362,13 @@ void RenderProxy::dumpGraphicsMemory(int fd, bool includeProfileData, bool reset
             }
         });
     }
+#ifdef __ANDROID__
     if (!Properties::isolatedProcess) {
         std::string grallocInfo;
         GraphicBufferAllocator::getInstance().dump(grallocInfo);
         dprintf(fd, "%s\n", grallocInfo.c_str());
     }
+#endif
 }
 
 void RenderProxy::getMemoryUsage(size_t* cpuUsage, size_t* gpuUsage) {
@@ -339,20 +379,28 @@ void RenderProxy::getMemoryUsage(size_t* cpuUsage, size_t* gpuUsage) {
 }
 
 void RenderProxy::setProcessStatsBuffer(int fd) {
+#ifdef __ANDROID__  // Layoutlib does not support Profiling
     auto& rt = RenderThread::getInstance();
     rt.queue().post([&rt, fd = dup(fd)]() {
         rt.globalProfileData().switchStorageToAshmem(fd);
         close(fd);
     });
+#endif
 }
 
 void RenderProxy::rotateProcessStatsBuffer() {
+#ifdef __ANDROID__  // Layoutlib does not support Profiling
     auto& rt = RenderThread::getInstance();
     rt.queue().post([&rt]() { rt.globalProfileData().rotateStorage(); });
+#endif
 }
 
 int RenderProxy::getRenderThreadTid() {
+#ifdef __ANDROID__  // Layoutlib does not support
     return mRenderThread.getTid();
+#else
+    return 0;
+#endif
 }
 
 void RenderProxy::addRenderNode(RenderNode* node, bool placeFront) {
@@ -407,15 +455,19 @@ void RenderProxy::setFrameCompleteCallback(std::function<void()>&& callback) {
 }
 
 void RenderProxy::addFrameMetricsObserver(FrameMetricsObserver* observerPtr) {
+#ifdef __ANDROID__  // Layoutlib does not support Metrics
     mRenderThread.queue().post([this, observer = sp{observerPtr}]() {
         mContext->addFrameMetricsObserver(observer.get());
     });
+#endif
 }
 
 void RenderProxy::removeFrameMetricsObserver(FrameMetricsObserver* observerPtr) {
+#ifdef __ANDROID__  // Layoutlib does not support Metrics
     mRenderThread.queue().post([this, observer = sp{observerPtr}]() {
         mContext->removeFrameMetricsObserver(observer.get());
     });
+#endif
 }
 
 void RenderProxy::setForceDark(ForceDarkType type) {
@@ -423,12 +475,14 @@ void RenderProxy::setForceDark(ForceDarkType type) {
 }
 
 void RenderProxy::copySurfaceInto(ANativeWindow* window, std::shared_ptr<CopyRequest>&& request) {
+#ifdef __ANDROID__  // Layoutlib does not support
     auto& thread = RenderThread::getInstance();
     ANativeWindow_acquire(window);
     thread.queue().post([&thread, window, request = std::move(request)] {
         thread.readback().copySurfaceInto(window, request);
         ANativeWindow_release(window);
     });
+#endif
 }
 
 void RenderProxy::prepareToDraw(Bitmap& bitmap) {
@@ -459,6 +513,7 @@ void RenderProxy::prepareToDraw(Bitmap& bitmap) {
 }
 
 int RenderProxy::copyHWBitmapInto(Bitmap* hwBitmap, SkBitmap* bitmap) {
+#ifdef __ANDROID__  // Layoutlib does not support hardware acceleration
     ATRACE_NAME("HardwareBitmap readback");
     RenderThread& thread = RenderThread::getInstance();
     if (gettid() == thread.getTid()) {
@@ -468,9 +523,13 @@ int RenderProxy::copyHWBitmapInto(Bitmap* hwBitmap, SkBitmap* bitmap) {
         return thread.queue().runSync(
                 [&]() -> int { return (int)thread.readback().copyHWBitmapInto(hwBitmap, bitmap); });
     }
+#else
+    return 0;
+#endif
 }
 
 int RenderProxy::copyImageInto(const sk_sp<SkImage>& image, SkBitmap* bitmap) {
+#ifdef __ANDROID__  // Layoutlib does not support hardware acceleration
     RenderThread& thread = RenderThread::getInstance();
     if (gettid() == thread.getTid()) {
         // TODO: fix everything that hits this. We should never be triggering a readback ourselves.
@@ -479,6 +538,9 @@ int RenderProxy::copyImageInto(const sk_sp<SkImage>& image, SkBitmap* bitmap) {
         return thread.queue().runSync(
                 [&]() -> int { return (int)thread.readback().copyImageInto(image, bitmap); });
     }
+#else
+    return 0;
+#endif
 }
 
 void RenderProxy::disableVsync() {
@@ -486,9 +548,11 @@ void RenderProxy::disableVsync() {
 }
 
 void RenderProxy::preload() {
+#ifdef __ANDROID__  // Layoutlib does not support preload?
     // Create RenderThread object and start the thread. Then preload Vulkan/EGL driver.
     auto& thread = RenderThread::getInstance();
     thread.queue().post([&thread]() { thread.preload(); });
+#endif
 }
 
 void RenderProxy::setRtAnimationsEnabled(bool enabled) {
diff --git a/libs/hwui/utils/HostColorSpace.cpp b/libs/hwui/utils/HostColorSpace.cpp
new file mode 100755
index 000000000000..77a6820c6999
--- /dev/null
+++ b/libs/hwui/utils/HostColorSpace.cpp
@@ -0,0 +1,417 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+// This is copied from framework/native/libs/ui in order not to include libui in host build
+
+#include <ui/ColorSpace.h>
+
+using namespace std::placeholders;
+
+namespace android {
+
+static constexpr float linearResponse(float v) {
+    return v;
+}
+
+static constexpr float rcpResponse(float x, const ColorSpace::TransferParameters& p) {
+    return x >= p.d * p.c ? (std::pow(x, 1.0f / p.g) - p.b) / p.a : x / p.c;
+}
+
+static constexpr float response(float x, const ColorSpace::TransferParameters& p) {
+    return x >= p.d ? std::pow(p.a * x + p.b, p.g) : p.c * x;
+}
+
+static constexpr float rcpFullResponse(float x, const ColorSpace::TransferParameters& p) {
+    return x >= p.d * p.c ? (std::pow(x - p.e, 1.0f / p.g) - p.b) / p.a : (x - p.f) / p.c;
+}
+
+static constexpr float fullResponse(float x, const ColorSpace::TransferParameters& p) {
+    return x >= p.d ? std::pow(p.a * x + p.b, p.g) + p.e : p.c * x + p.f;
+}
+
+static float absRcpResponse(float x, float g,float a, float b, float c, float d) {
+    float xx = std::abs(x);
+    return std::copysign(xx >= d * c ? (std::pow(xx, 1.0f / g) - b) / a : xx / c, x);
+}
+
+static float absResponse(float x, float g, float a, float b, float c, float d) {
+   float xx = std::abs(x);
+   return std::copysign(xx >= d ? std::pow(a * xx + b, g) : c * xx, x);
+}
+
+static float safePow(float x, float e) {
+    return powf(x < 0.0f ? 0.0f : x, e);
+}
+
+static ColorSpace::transfer_function toOETF(const ColorSpace::TransferParameters& parameters) {
+    if (parameters.e == 0.0f && parameters.f == 0.0f) {
+        return std::bind(rcpResponse, _1, parameters);
+    }
+    return std::bind(rcpFullResponse, _1, parameters);
+}
+
+static ColorSpace::transfer_function toEOTF( const ColorSpace::TransferParameters& parameters) {
+    if (parameters.e == 0.0f && parameters.f == 0.0f) {
+        return std::bind(response, _1, parameters);
+    }
+    return std::bind(fullResponse, _1, parameters);
+}
+
+static ColorSpace::transfer_function toOETF(float gamma) {
+    if (gamma == 1.0f) {
+        return linearResponse;
+    }
+    return std::bind(safePow, _1, 1.0f / gamma);
+}
+
+static ColorSpace::transfer_function toEOTF(float gamma) {
+    if (gamma == 1.0f) {
+        return linearResponse;
+    }
+    return std::bind(safePow, _1, gamma);
+}
+
+static constexpr std::array<float2, 3> computePrimaries(const mat3& rgbToXYZ) {
+    float3 r(rgbToXYZ * float3{1, 0, 0});
+    float3 g(rgbToXYZ * float3{0, 1, 0});
+    float3 b(rgbToXYZ * float3{0, 0, 1});
+
+    return {{r.xy / dot(r, float3{1}),
+             g.xy / dot(g, float3{1}),
+             b.xy / dot(b, float3{1})}};
+}
+
+static constexpr float2 computeWhitePoint(const mat3& rgbToXYZ) {
+    float3 w(rgbToXYZ * float3{1});
+    return w.xy / dot(w, float3{1});
+}
+
+ColorSpace::ColorSpace(
+        const std::string& name,
+        const mat3& rgbToXYZ,
+        transfer_function OETF,
+        transfer_function EOTF,
+        clamping_function clamper) noexcept
+        : mName(name)
+        , mRGBtoXYZ(rgbToXYZ)
+        , mXYZtoRGB(inverse(rgbToXYZ))
+        , mOETF(std::move(OETF))
+        , mEOTF(std::move(EOTF))
+        , mClamper(std::move(clamper))
+        , mPrimaries(computePrimaries(rgbToXYZ))
+        , mWhitePoint(computeWhitePoint(rgbToXYZ)) {
+}
+
+ColorSpace::ColorSpace(
+        const std::string& name,
+        const mat3& rgbToXYZ,
+        const TransferParameters parameters,
+        clamping_function clamper) noexcept
+        : mName(name)
+        , mRGBtoXYZ(rgbToXYZ)
+        , mXYZtoRGB(inverse(rgbToXYZ))
+        , mParameters(parameters)
+        , mOETF(toOETF(mParameters))
+        , mEOTF(toEOTF(mParameters))
+        , mClamper(std::move(clamper))
+        , mPrimaries(computePrimaries(rgbToXYZ))
+        , mWhitePoint(computeWhitePoint(rgbToXYZ)) {
+}
+
+ColorSpace::ColorSpace(
+        const std::string& name,
+        const mat3& rgbToXYZ,
+        float gamma,
+        clamping_function clamper) noexcept
+        : mName(name)
+        , mRGBtoXYZ(rgbToXYZ)
+        , mXYZtoRGB(inverse(rgbToXYZ))
+        , mParameters({gamma, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f})
+        , mOETF(toOETF(gamma))
+        , mEOTF(toEOTF(gamma))
+        , mClamper(std::move(clamper))
+        , mPrimaries(computePrimaries(rgbToXYZ))
+        , mWhitePoint(computeWhitePoint(rgbToXYZ)) {
+}
+
+ColorSpace::ColorSpace(
+        const std::string& name,
+        const std::array<float2, 3>& primaries,
+        const float2& whitePoint,
+        transfer_function OETF,
+        transfer_function EOTF,
+        clamping_function clamper) noexcept
+        : mName(name)
+        , mRGBtoXYZ(computeXYZMatrix(primaries, whitePoint))
+        , mXYZtoRGB(inverse(mRGBtoXYZ))
+        , mOETF(std::move(OETF))
+        , mEOTF(std::move(EOTF))
+        , mClamper(std::move(clamper))
+        , mPrimaries(primaries)
+        , mWhitePoint(whitePoint) {
+}
+
+ColorSpace::ColorSpace(
+        const std::string& name,
+        const std::array<float2, 3>& primaries,
+        const float2& whitePoint,
+        const TransferParameters parameters,
+        clamping_function clamper) noexcept
+        : mName(name)
+        , mRGBtoXYZ(computeXYZMatrix(primaries, whitePoint))
+        , mXYZtoRGB(inverse(mRGBtoXYZ))
+        , mParameters(parameters)
+        , mOETF(toOETF(mParameters))
+        , mEOTF(toEOTF(mParameters))
+        , mClamper(std::move(clamper))
+        , mPrimaries(primaries)
+        , mWhitePoint(whitePoint) {
+}
+
+ColorSpace::ColorSpace(
+        const std::string& name,
+        const std::array<float2, 3>& primaries,
+        const float2& whitePoint,
+        float gamma,
+        clamping_function clamper) noexcept
+        : mName(name)
+        , mRGBtoXYZ(computeXYZMatrix(primaries, whitePoint))
+        , mXYZtoRGB(inverse(mRGBtoXYZ))
+        , mParameters({gamma, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f})
+        , mOETF(toOETF(gamma))
+        , mEOTF(toEOTF(gamma))
+        , mClamper(std::move(clamper))
+        , mPrimaries(primaries)
+        , mWhitePoint(whitePoint) {
+}
+
+constexpr mat3 ColorSpace::computeXYZMatrix(
+        const std::array<float2, 3>& primaries, const float2& whitePoint) {
+    const float2& R = primaries[0];
+    const float2& G = primaries[1];
+    const float2& B = primaries[2];
+    const float2& W = whitePoint;
+
+    float oneRxRy = (1 - R.x) / R.y;
+    float oneGxGy = (1 - G.x) / G.y;
+    float oneBxBy = (1 - B.x) / B.y;
+    float oneWxWy = (1 - W.x) / W.y;
+
+    float RxRy = R.x / R.y;
+    float GxGy = G.x / G.y;
+    float BxBy = B.x / B.y;
+    float WxWy = W.x / W.y;
+
+    float BY =
+            ((oneWxWy - oneRxRy) * (GxGy - RxRy) - (WxWy - RxRy) * (oneGxGy - oneRxRy)) /
+            ((oneBxBy - oneRxRy) * (GxGy - RxRy) - (BxBy - RxRy) * (oneGxGy - oneRxRy));
+    float GY = (WxWy - RxRy - BY * (BxBy - RxRy)) / (GxGy - RxRy);
+    float RY = 1 - GY - BY;
+
+    float RYRy = RY / R.y;
+    float GYGy = GY / G.y;
+    float BYBy = BY / B.y;
+
+    return {
+        float3{RYRy * R.x, RY, RYRy * (1 - R.x - R.y)},
+        float3{GYGy * G.x, GY, GYGy * (1 - G.x - G.y)},
+        float3{BYBy * B.x, BY, BYBy * (1 - B.x - B.y)}
+    };
+}
+
+const ColorSpace ColorSpace::sRGB() {
+    return {
+        "sRGB IEC61966-2.1",
+        {{float2{0.640f, 0.330f}, {0.300f, 0.600f}, {0.150f, 0.060f}}},
+        {0.3127f, 0.3290f},
+        {2.4f, 1 / 1.055f, 0.055f / 1.055f, 1 / 12.92f, 0.04045f, 0.0f, 0.0f}
+    };
+}
+
+const ColorSpace ColorSpace::linearSRGB() {
+    return {
+        "sRGB IEC61966-2.1 (Linear)",
+        {{float2{0.640f, 0.330f}, {0.300f, 0.600f}, {0.150f, 0.060f}}},
+        {0.3127f, 0.3290f}
+    };
+}
+
+const ColorSpace ColorSpace::extendedSRGB() {
+    return {
+        "scRGB-nl IEC 61966-2-2:2003",
+        {{float2{0.640f, 0.330f}, {0.300f, 0.600f}, {0.150f, 0.060f}}},
+        {0.3127f, 0.3290f},
+        std::bind(absRcpResponse, _1, 2.4f, 1 / 1.055f, 0.055f / 1.055f, 1 / 12.92f, 0.04045f),
+        std::bind(absResponse,    _1, 2.4f, 1 / 1.055f, 0.055f / 1.055f, 1 / 12.92f, 0.04045f),
+        std::bind(clamp<float>, _1, -0.799f, 2.399f)
+    };
+}
+
+const ColorSpace ColorSpace::linearExtendedSRGB() {
+    return {
+        "scRGB IEC 61966-2-2:2003",
+        {{float2{0.640f, 0.330f}, {0.300f, 0.600f}, {0.150f, 0.060f}}},
+        {0.3127f, 0.3290f},
+        1.0f,
+        std::bind(clamp<float>, _1, -0.5f, 7.499f)
+    };
+}
+
+const ColorSpace ColorSpace::NTSC() {
+    return {
+        "NTSC (1953)",
+        {{float2{0.67f, 0.33f}, {0.21f, 0.71f}, {0.14f, 0.08f}}},
+        {0.310f, 0.316f},
+        {1 / 0.45f, 1 / 1.099f, 0.099f / 1.099f, 1 / 4.5f, 0.081f, 0.0f, 0.0f}
+    };
+}
+
+const ColorSpace ColorSpace::BT709() {
+    return {
+        "Rec. ITU-R BT.709-5",
+        {{float2{0.640f, 0.330f}, {0.300f, 0.600f}, {0.150f, 0.060f}}},
+        {0.3127f, 0.3290f},
+        {1 / 0.45f, 1 / 1.099f, 0.099f / 1.099f, 1 / 4.5f, 0.081f, 0.0f, 0.0f}
+    };
+}
+
+const ColorSpace ColorSpace::BT2020() {
+    return {
+        "Rec. ITU-R BT.2020-1",
+        {{float2{0.708f, 0.292f}, {0.170f, 0.797f}, {0.131f, 0.046f}}},
+        {0.3127f, 0.3290f},
+        {1 / 0.45f, 1 / 1.099f, 0.099f / 1.099f, 1 / 4.5f, 0.081f, 0.0f, 0.0f}
+    };
+}
+
+const ColorSpace ColorSpace::AdobeRGB() {
+    return {
+        "Adobe RGB (1998)",
+        {{float2{0.64f, 0.33f}, {0.21f, 0.71f}, {0.15f, 0.06f}}},
+        {0.3127f, 0.3290f},
+        2.2f
+    };
+}
+
+const ColorSpace ColorSpace::ProPhotoRGB() {
+    return {
+        "ROMM RGB ISO 22028-2:2013",
+        {{float2{0.7347f, 0.2653f}, {0.1596f, 0.8404f}, {0.0366f, 0.0001f}}},
+        {0.34567f, 0.35850f},
+        {1.8f, 1.0f, 0.0f, 1 / 16.0f, 0.031248f, 0.0f, 0.0f}
+    };
+}
+
+const ColorSpace ColorSpace::DisplayP3() {
+    return {
+        "Display P3",
+        {{float2{0.680f, 0.320f}, {0.265f, 0.690f}, {0.150f, 0.060f}}},
+        {0.3127f, 0.3290f},
+        {2.4f, 1 / 1.055f, 0.055f / 1.055f, 1 / 12.92f, 0.039f, 0.0f, 0.0f}
+    };
+}
+
+const ColorSpace ColorSpace::DCIP3() {
+    return {
+        "SMPTE RP 431-2-2007 DCI (P3)",
+        {{float2{0.680f, 0.320f}, {0.265f, 0.690f}, {0.150f, 0.060f}}},
+        {0.314f, 0.351f},
+        2.6f
+    };
+}
+
+const ColorSpace ColorSpace::ACES() {
+    return {
+        "SMPTE ST 2065-1:2012 ACES",
+        {{float2{0.73470f, 0.26530f}, {0.0f, 1.0f}, {0.00010f, -0.0770f}}},
+        {0.32168f, 0.33767f},
+        1.0f,
+        std::bind(clamp<float>, _1, -65504.0f, 65504.0f)
+    };
+}
+
+const ColorSpace ColorSpace::ACEScg() {
+    return {
+        "Academy S-2014-004 ACEScg",
+        {{float2{0.713f, 0.293f}, {0.165f, 0.830f}, {0.128f, 0.044f}}},
+        {0.32168f, 0.33767f},
+        1.0f,
+        std::bind(clamp<float>, _1, -65504.0f, 65504.0f)
+    };
+}
+
+std::unique_ptr<float3[]> ColorSpace::createLUT(uint32_t size, const ColorSpace& src,
+                                                const ColorSpace& dst) {
+    size = clamp(size, 2u, 256u);
+    float m = 1.0f / float(size - 1);
+
+    std::unique_ptr<float3[]> lut(new float3[size * size * size]);
+    float3* data = lut.get();
+
+    ColorSpaceConnector connector(src, dst);
+
+    for (uint32_t z = 0; z < size; z++) {
+        for (int32_t y = int32_t(size - 1); y >= 0; y--) {
+            for (uint32_t x = 0; x < size; x++) {
+                *data++ = connector.transform({x * m, y * m, z * m});
+            }
+        }
+    }
+
+    return lut;
+}
+
+static const float2 ILLUMINANT_D50_XY = {0.34567f, 0.35850f};
+static const float3 ILLUMINANT_D50_XYZ = {0.964212f, 1.0f, 0.825188f};
+static const mat3 BRADFORD = mat3{
+    float3{ 0.8951f, -0.7502f,  0.0389f},
+    float3{ 0.2664f,  1.7135f, -0.0685f},
+    float3{-0.1614f,  0.0367f,  1.0296f}
+};
+
+static mat3 adaptation(const mat3& matrix, const float3& srcWhitePoint, const float3& dstWhitePoint) {
+    float3 srcLMS = matrix * srcWhitePoint;
+    float3 dstLMS = matrix * dstWhitePoint;
+    return inverse(matrix) * mat3{dstLMS / srcLMS} * matrix;
+}
+
+ColorSpaceConnector::ColorSpaceConnector(
+        const ColorSpace& src,
+        const ColorSpace& dst) noexcept
+        : mSource(src)
+        , mDestination(dst) {
+
+    if (all(lessThan(abs(src.getWhitePoint() - dst.getWhitePoint()), float2{1e-3f}))) {
+        mTransform = dst.getXYZtoRGB() * src.getRGBtoXYZ();
+    } else {
+        mat3 rgbToXYZ(src.getRGBtoXYZ());
+        mat3 xyzToRGB(dst.getXYZtoRGB());
+
+        float3 srcXYZ = ColorSpace::XYZ(float3{src.getWhitePoint(), 1});
+        float3 dstXYZ = ColorSpace::XYZ(float3{dst.getWhitePoint(), 1});
+
+        if (any(greaterThan(abs(src.getWhitePoint() - ILLUMINANT_D50_XY), float2{1e-3f}))) {
+            rgbToXYZ = adaptation(BRADFORD, srcXYZ, ILLUMINANT_D50_XYZ) * src.getRGBtoXYZ();
+        }
+
+        if (any(greaterThan(abs(dst.getWhitePoint() - ILLUMINANT_D50_XY), float2{1e-3f}))) {
+            xyzToRGB = inverse(adaptation(BRADFORD, dstXYZ, ILLUMINANT_D50_XYZ) * dst.getRGBtoXYZ());
+        }
+
+        mTransform = xyzToRGB * rgbToXYZ;
+    }
+}
+
+}; // namespace android
-- 
2.34.1

